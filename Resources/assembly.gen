[generic]
Name=Assembly Generator Script
Description=This script defines DSP assembly code generation templates used to generate user-tailored SMPS control loops using the DCLD SDK
Author=Andreas Reiter - M91406
Version=2.0.7
Date=04/14/2020

[history]
count=22
0=04/03/19;1.1.1;Added input offset compensation applied to input source
1=10/18/19;1.2.0;Changed existing input offset compensation to full bi-directional feedback implementation
2=10/19/19;1.2.1;Added code option for feedback signal rectification
3=10/22/19;1.2.2;Fixed typos in comments of data structure
4=11/07/19;1.2.3;Added 'Dummy Read of Source Buffer' when control loop is disabled\r\nAdded second ADC trigger placement target and offset
5=11/08/19;1.2.4;Added 'Changed data provider items from local copies in cNPNZ16b_t data structure to poinbter to external data buffers
6=01/10/19;1.3.0;Added support for cascaded functions. This allows a controller to call another controller or user-defined function extension code module
7=01/13/2020;1.3.1;Reordered cascaded function call to execute full cascade even if controller is disabled.
8=03/02/2020;1.3.2;Added comments to assembly building blocks
9=03/04/2020;1.3.3;Fixed bug in single bit-shift scaler data structure declaration
10=03/04/2020;1.3.4;Fixed bug with corrupted character in floating point scaling data structure
11=03/24/2020;1.3.5;Added Adaptive Gain Control Modulation factors to cNPNZ_t data structure
12=03/24/2020;1.3.8;Renamed data structure prefix NPMZ16_ to NPNZ16_
13=03/25/2020;1.3.9;Added Adaptive Gain Control Modulation to single.bit shifted, dual bit shifted and output factor scaling modes
14=03/26/2020;2.0.0;Introduction of unified 32-bit wide coefficient number format
15=03/27/2020;2.0.1;Separated controller input and output port definitions in individual data structures with normalization parameters
16=03/30/2020;2.0.2;Polished comments
17=03/31/2020;2.0.3;Added P-Term control loop  for plant measurement support
18=04/03/2020;2.0.4;option_token_test
19=04/03/2020;2.0.5;Added Token IDs for enahanced code generator option support
20=04/03/2020;2.0.6;Added Token IDs for enhanced code generator option support
21=04/14/2020;2.0.7;Added support of new tokens to Output Scaler Controller

[filter_block_scaling_modes]
count=6
0=%EMPTY%
1=sbsft
2=scscl
3=dbsft
4=fscl
5=ffloat

[filter_block_scaling_modes_descritpion]
sbsft=Single Bitshift-Scaling Mode
scscl=Single Coefficient Factor Scaling Mode
dbsft=Dual Bitshift-Scaling Mode
fscl=Fast Floating Point Coefficient Scaling Mode
ffloat=Fast Floating Point Mode

[filter_block_array_addressing_coeff]
addr_offset_sbft=4
addr_offset_scscl=4
addr_offset_dbsft=4
addr_offset_fscl=4
addr_offset_ffloat=4

[filter_block_array_addressing_data]
addr_offset_sbft=2
addr_offset_scscl=2
addr_offset_dbsft=2
addr_offset_fscl=2
addr_offset_ffloat=2

[MSExcelExport]
PoleAtOrigin=IMDIV(wp0 ,COMPLEX(0,[<SHEET.CELL.RADIANDS>]))
LeadLagBlock=IMDIV(IMSUM(IMDIV(COMPLEX(0,[<SHEET.CELL.RADIANDS>]),wz%FO%,1),IMSUM(IMDIV(COMPLEX(0,[<SHEET.CELL.RADIANDS>]),wp%FO%),1))
FORMULA=IMPRODUCT(%PoleAtOrigin%, %LeadLagBlock%)


[tokens]
count=18
0=%EMPTY%
1=%SPACE%
2=%IDENT%
3=%DATA_TYPE_FRACTIONAL%
4=%DATA_TYPE_INT32%
5=%FILE_NAME_PATTERN%
6=%PREFIX%
7=%FILTER_ORDER%
8=%FILTER_ORDER+1%
9=%STRUCTURE_LABEL%
10=%CGS_VERSION%
11=%CGS_VERSION_DATE%
12=%APP_PRODUCT_NAME%
13=%APP_PRODUCT_VERSION%
14=%SUPPORT_URL%
15=%VENDOR_URL%
16=%TOOL_HOME_URL%

[option_ids]
count=37
0=%{(1100)}%;context_management
1=%{(1101)}%;context_shadow
2=%{(1102)}%;context_mac_wreg
3=%{(1103)}%;context_acc
4=%{(1104)}%;context_acc_a
5=%{(1105)}%;context_acc_b
6=%{(1106)}%;context_core_config
7=%{(1107)}%;context_core_status
8=%{(1200)}%;option_enable
9=%{(1201)}%;option_store_reload_acc
10=%{(1202)}%;option_core_config
11=%{(1203)}%;option_enable_switch
12=%{(1204)}%;option_enable_switch_always_read
13=%{(1205)}%;option_error_normalization
14=%{(1206)}%;option_adc_trigger_a_placement
15=%{(1207)}%;option_adc_trigger_b_placement
16=%{(1208)}%;option_cascade_call
17=%{(1209)}%;option_add_p-term
18=%{(1300)}%;data_interface_enable
19=%{(1301)}%;data_interface_alt_input
20=%{(1302)}%;data_interface_alt_output
21=%{(1400)}%;data_provider_enable
22=%{(1401)}%;data_provider_control_input
23=%{(1402)}%;data_provider_control_error
24=%{(1403)}%;data_provider_control_output
25=%{(1500)}%;anti_windup_enable
26=%{(1501)}%;anti_windup_max
27=%{(1502)}%;anti_windup_max_status_flag
28=%{(1503)}%;anti_windup_min
29=%{(1504)}%;anti_windup_min_status_flag
30=%{(1505)}%;anti_windup_soft_desat_flag
31=%{(1600)}%;feedback_conditioning_enable
32=%{(1601)}%;feedback_offset_compensation
33=%{(1602)}%;bi_directional_feedback_flag
34=%{(1800)}%;agc_enable
35=%{(1801)}%;agc_enable_switch
36=%{(1802)}%;agc_get_factor_function_call


[add_data_structure_sbsft]
head_comment=%SEPARATOR%; Address offset declarations for data structure addressing (single bit-shift scaling)
cycles=0
lines=52
comment0=controller object status word at address-offset = 0
comment1=parameter group Ports.Source: pointer to source memory address
comment2=parameter group Ports.Source: bit-shift scaler of normalization factor
comment3=parameter group Ports.Source: Q15 normalization factor
comment4=parameter group Ports.Source: value of source input signal/value offset
comment5=parameter group Ports.AltSource: pointer to alternate source memory address
comment6=parameter group Ports.AltSource: bit-shift scaler of normalization factor
comment7=parameter group Ports.AltSource: Q15 normalization factor
comment8=parameter group Ports.AltSource: value of alternate source input signal/value offset
comment9=parameter group Ports.Target: pointer to target memory address
comment10=parameter group Ports.Target: bit-shift scaler of normalization factor
comment11=parameter group Ports.Target: Q15 normalization factor
comment12=parameter group Ports.Target: value of target output signal/value offset
comment13=parameter group Ports.AltTarget: pointer to alternate target memory address
comment14=parameter group Ports.AltTarget: bit-shift scaler of normalization factor
comment15=parameter group Ports.AltTarget: Q15 normalization factor
comment16=parameter group Ports.AltTarget: value of alternate target output sigal/value offset
comment17=parameter group Ports.ConrolReference: pointer to control reference variable/register memory address
comment18=parameter group Filter: pointer to A-coefficients array start address
comment19=parameter group Filter: pointer to B-coefficients array start address
comment20=parameter group Filter: pointer to control history array start address
comment21=parameter group Filter: pointer to error history array start address
comment22=parameter group Filter: size of the A-coefficients array
comment23=parameter group Filter: size of the B-coefficients array
comment24=parameter group Filter: size of the control history array
comment25=parameter group Filter: size of the error history array
comment26=parameter group Filter: value of input value normalization bit-shift scaler
comment27=parameter group Filter: value of A-term normalization bit-shift scaler
comment28=parameter group Filter: (reserved)
comment29=parameter group Filter: (reserved)
comment30=parameter group Filter: P-Term coefficient scaler
comment31=parameter group Filter: P-Term coefficient fractional factor
comment32=parameter group Limits: minimum clamping value of primary control output 
comment33=parameter group Limits: maximum clamping value of primary control output 
comment34=parameter group Limits: minimum clamping value of alternate control output 
comment35=parameter group Limits: maximum clamping value of alternate control output 
comment36=parameter group ADCTriggerControl: pointer to ADC trigger A register memory address
comment37=parameter group ADCTriggerControl: value of ADC trigger A offset
comment38=parameter group ADCTriggerControl: pointer to ADC trigger B register memory address
comment39=parameter group ADCTriggerControl: value of ADC trigger B offset
comment40=parameter group DataProviders: pointer to external variable/register the most recent control input will be pushed to
comment41=parameter group DataProviders: pointer to external variable/register the most recent control error will be pushed to
comment42=parameter group DataProviders: pointer to external variable/register the most recent control output will be pushed to
comment43=parameter group CascadeTrigger: pointer to external, cascaded function which will be called by this controller
comment44=parameter group CascadeTrigger: 16-bit wide function parameter or pointer to a parameter data structure of cascaded function
comment45=parameter group GainControl: bit-shift scaler of Adaptive Gain Control Modulation factor
comment46=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation factor
comment47=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation norminal operating point
comment48=parameter group Advanced: generic 16-bit wide, user-defined parameter #1 for advanced control options
comment49=parameter group Advanced: generic 16-bit wide, user-defined parameter #2 for advanced control options
comment50=parameter group Advanced: generic 16-bit wide, user-defined parameter #3 for advanced control options
comment51=parameter group Advanced: generic 16-bit wide, user-defined parameter #4 for advanced control options
code0=.equ Status,                    0
code1=.equ ptrSourceRegister,         2
code2=.equ SourceNormShift,           4
code3=.equ SourceNormFactor,          6
code4=.equ SourceOffset,              8
code5=.equ ptrAltSourceRegister,      10
code6=.equ AltSourceNormShift,        12
code7=.equ AltSourceNormFactor,       14
code8=.equ AltSourceOffset,           16
code9=.equ ptrTargetRegister,         18
code10=.equ TargetNormShift,           20
code11=.equ TargetNormFactor,          22
code12=.equ TargetOffset,              24
code13=.equ ptrAltTargetRegister,      26
code14=.equ AltTargetNormShift,        28
code15=.equ AltTargetNormFactor,       30
code16=.equ AltTargetOffset,           32
code17=.equ ptrCtrlReference,          34
code18=.equ ptrACoefficients,          36
code19=.equ ptrBCoefficients,          38
code20=.equ ptrControlHistory,         40
code21=.equ ptrErrorHistory,           42
code22=.equ ACoeffArraySize,           44
code23=.equ BCoeffArraySize,           46
code24=.equ CtrlHistArraySize,         48
code25=.equ ErrHistArraySize,          50
code26=.equ PreShift,                  52
code27=.equ PostShiftA,                54
code28=.equ reserved_1,                56
code29=.equ reserved_2,                58
code30=.equ pterm_scaler,              60
code31=.equ pterm_factor,              62
code32=.equ MinOutput,                 64
code33=.equ MaxOutput,                 66
code34=.equ AltMinOutput,              68
code35=.equ AltMaxOutput,              70
code36=.equ ptrADCTriggerARegister,    72
code37=.equ ADCTriggerAOffset,         74
code38=.equ ptrADCTriggerBRegister,    76
code39=.equ ADCTriggerBOffset,         78
code40=.equ ptrDProvControlInput,      80
code41=.equ ptrDProvControlError,      82
code42=.equ ptrDProvControlOutput,     84
code43=.equ ptrCascadedFunction,       86
code44=.equ CascadedFunParam,          88
code45=.equ agcGainModScaler,          90
code46=.equ agcGainModFactor,          92
code47=.equ agcGainModMedian,          94
code48=.equ AdvParam1,                 96
code49=.equ AdvParam2,                 98
code50=.equ AdvParam3,                 100
code51=.equ AdvParam4,                 102


[blockset_sbsft_0]
;Instruction blockset for controllers using 16-bit fixed point coefficients scaled with one common single bit-shift scaler
;linear execution of compensation filter
wreg_usage=4,6,8,10,12
accu_usage=a
count=164
0=disclaimer
1=lists
2=section_header
3=add_global_flags
4=add_data_structure_sbsft
5=section_code
6=exec_function_head
7=%{(1100)}%context_save
8=%{(1100)&&(1101)}%context_save_shadow
9=%{(1100)}%context_save_status_word_wreg
10=%{(1200)&&(1203)}%enable_disable_start
11=%{(1100)}%context_save
12=%{(1100)&&(1102)}%context_save_mac_registers
13=%{(1100)&&(1103)&&(1104)}%context_save_accumulator_a
14=%{(1100)&&(1103)&&(1105)}%context_save_accumulator_b
15=%{(1100)&&(1106)}%context_save_core_config
16=%{(1100)&&(1107)}%context_save_core_status
17=%{(1200)&&(1202)}%core_config
18=load_a_coeff_array_ptr
19=load_control_history_array_ptr
20=comp_mac_start_acca_clear_prefetch
21=comp_mac_loop_a_term_acca
22=comp_mac_end_acca
23=load_error_history_array_ptr
24=comp_error_history_update
25=comp_read_input
26=%{(1400)&&(1401)}%shadow_copy_control_input
27=comp_get_error
28=%{(1600)&&(1601)}%comp_zero_input
29=%{(1600)&&(1602)}%comp_invert_input
30=%{(1200)&&(1205)}%comp_norm_error
31=%{(1400)&&(1402)}%shadow_copy_error_input
32=load_b_coeff_array_ptr
33=comp_error_add_most_recent_to_history
34=comp_mac_start_accb_clear_prefetch
35=comp_mac_loop_b_term_accb
36=comp_mac_end_accb
37=%{(1800)}%agc_factor_multiply_start
38=%{(1800)&&(1801)}%agc_factor_multiply_enable_start
39=%{(1800)&&(1802)}%agc_factor_multiply_get_factor_call
40=%{(1800)}%agc_factor_multiply_scaled
41=%{(1800)&&(1801)}%agc_factor_multiply_enable_end
42=comp_add_accb_to_acca
43=comp_backward_norm_a_acca
44=comp_mac_store_acca
45=%{(1500)}%anti_windup
46=%{(1500)&&(1501)}%anti_windup_max_start
47=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start
48=%{(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
49=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass
50=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start
51=%{(1500)&&(1501)}%anti_windup_max_override
52=%{(1500)&&(1501)&&(1505)}%anti_windup_soft_desaturation
53=%{(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag
54=%{(1500)&&(1501)}%anti_windup_max_options_end
55=%{(1500)&&(1503)}%anti_windup_min_start
56=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start
57=%{(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
58=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass
59=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start
60=%{(1500)&&(1503)}%anti_windup_min_override
61=%{(1500)&&(1503)&&(1505)}%anti_windup_soft_desaturation
62=%{(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag
63=%{(1500)&&(1503)}%anti_windup_min_options_end
64=comp_writeback
65=%{(1400)&&(1403)}%shadow_copy_control_output
66=%{(1200)&&(1206)}%adc_trigger_a_placement
67=%{(1200)&&(1207)}%adc_trigger_b_placement
68=load_control_history_array_ptr
69=comp_control_history_update
70=comp_control_add_most_recent_to_history
71=update_status_bitfield
72=%{(1100)}%context_restore
73=%{(1100)&&(1102)}%context_restore_mac_registers
74=%{(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
75=%{(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
76=%{(1100)&&(1106)}%context_restore_core_config
77=%{(1100)&&(1107)}%context_restore_core_status
78=%{(1200)&&(1203)&&(!1204)}%enable_disable_end
79=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read
80=%{(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input
81=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end
82=%{(1208)}%cascaded_function_call
83=%{(1100)}%context_restore
84=%{(1100)&&(1101)}%context_restore_shadow
85=%{(1100)}%context_restore_status_word_wreg
86=return
87=reset_function_head
88=clear_control_history_start
89=clear_control_history_loop
90=clear_control_history_end
91=clear_error_history_start
92=clear_error_history_loop
93=clear_error_history_end
94=return
95=charge_function_head
96=charge_error_history_start
97=charge_error_history_loop
98=charge_error_history_end
99=charge_control_history_start
100=charge_control_history_loop
101=charge_control_history_end
102=return
103=%{(1209)}%pterm_function_head
104=%{(1209)&&(1100)}%context_save
105=%{(1209)&&(1100)&&(1101)}%context_save_shadow
106=%{(1209)&&(1100)}%context_save_status_word_wreg
107=%{(1209)&&(1200)&&(1203)}%enable_disable_start_pterm
108=%{(1209)&&(1100)}%context_save
109=%{(1209)&&(1100)&&(1102)}%context_save_mac_registers
110=%{(1209)&&(1100)&&(1103)&&(1104)}%context_save_accumulator_a
111=%{(1209)&&(1100)&&(1103)&&(1105)}%context_save_accumulator_b
112=%{(1209)&&(1100)&&(1106)}%context_save_core_config
113=%{(1209)&&(1100)&&(1107)}%context_save_core_status
114=%{(1209)&&(1200)&&(1202)}%core_config
115=%{(1209)}%comp_read_input
116=%{(1209)&&(1400)&&(1401)}%shadow_copy_control_input
117=%{(1209)}%comp_get_error
118=%{(1209)&&(1600)&&(1601)}%comp_zero_input
119=%{(1209)&&(1600)&&(1602)}%comp_invert_input
120=%{(1209)&&(1200)&&(1205)}%comp_norm_error
121=%{(1209)&&(1400)&&(1402)}%shadow_copy_error_input
122=%{(1209)}%pterm_comp_load_gain_factor
123=%{(1209)}%pterm_comp_exec_pterm
124=%{(1209)&&(1500)}%anti_windup
125=%{(1209)&&(1500)&&(1501)}%anti_windup_max_start
126=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start_pterm
127=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
128=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass_pterm
129=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start_pterm
130=%{(1209)&&(1500)&&(1501)}%anti_windup_max_override
131=%{(1209)&&(1500)&&(1501)&&(1505)}%anti_windup_soft_desaturation
132=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag
133=%{(1209)&&(1500)&&(1501)}%anti_windup_max_options_end_pterm
134=%{(1209)&&(1500)&&(1503)}%anti_windup_min_start
135=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start_pterm
136=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
137=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass_pterm
138=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start_pterm
139=%{(1209)&&(1500)&&(1503)}%anti_windup_min_override
140=%{(1209)&&(1500)&&(1503)&&(1505)}%anti_windup_soft_desaturation
141=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag
142=%{(1209)&&(1500)&&(1503)}%anti_windup_min_options_end_pterm
143=%{(1209)}%comp_writeback
144=%{(1209)&&(1400)&&(1403)}%shadow_copy_control_output
145=%{(1209)&&(1200)&&(1206)}%adc_trigger_a_placement
146=%{(1209)&&(1200)&&(1207)}%adc_trigger_b_placement
147=%{(1209)}%update_status_bitfield
148=%{(1209)&&(1100)}%context_restore
149=%{(1209)&&(1100)&&(1102)}%context_restore_mac_registers
150=%{(1209)&&(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
151=%{(1209)&&(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
152=%{(1209)&&(1100)&&(1106)}%context_restore_core_config
153=%{(1209)&&(1100)&&(1107)}%context_restore_core_status
154=%{(1209)&&(1200)&&(1203)&&(!1204)}%enable_disable_end_pterm
155=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_pterm
156=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input
157=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end_pterm
158=%{(1209)&&(1208)}%cascaded_function_call
159=%{(1209)&&(1100)}%context_restore
160=%{(1209)&&(1100)&&(1101)}%context_restore_shadow
161=%{(1209)&&(1100)}%context_restore_status_word_wreg
162=%{(1209)}%return
163=end


[add_data_structure_scscl]
head_comment=%SEPARATOR%; Address offset declarations for data structure addressing (single bit-shift with output factor scaling)
cycles=0
lines=52
comment0=controller object status word at address-offset = 0
comment1=parameter group Ports.Source: pointer to source memory address
comment2=parameter group Ports.Source: bit-shift scaler of normalization factor
comment3=parameter group Ports.Source: Q15 normalization factor
comment4=parameter group Ports.Source: value of source input signal/value offset
comment5=parameter group Ports.AltSource: pointer to alternate source memory address
comment6=parameter group Ports.AltSource: bit-shift scaler of normalization factor
comment7=parameter group Ports.AltSource: Q15 normalization factor
comment8=parameter group Ports.AltSource: value of alternate source input signal/value offset
comment9=parameter group Ports.Target: pointer to target memory address
comment10=parameter group Ports.Target: bit-shift scaler of normalization factor
comment11=parameter group Ports.Target: Q15 normalization factor
comment12=parameter group Ports.Target: value of target output signal/value offset
comment13=parameter group Ports.AltTarget: pointer to alternate target memory address
comment14=parameter group Ports.AltTarget: bit-shift scaler of normalization factor
comment15=parameter group Ports.AltTarget: Q15 normalization factor
comment16=parameter group Ports.AltTarget: value of alternate target output sigal/value offset
comment17=parameter group Ports.ConrolReference: pointer to control reference variable/register memory address
comment18=parameter group Filter: pointer to A-coefficients array start address
comment19=parameter group Filter: pointer to B-coefficients array start address
comment20=parameter group Filter: pointer to control history array start address
comment21=parameter group Filter: pointer to error history array start address
comment22=parameter group Filter: size of the A-coefficients array
comment23=parameter group Filter: size of the B-coefficients array
comment24=parameter group Filter: size of the control history array
comment25=parameter group Filter: size of the error history array
comment26=parameter group Filter: value of input value normalization bit-shift scaler
comment27=parameter group Filter: value of A-term normalization bit-shift scaler
comment28=parameter group Filter: (reserved)
comment29=parameter group Filter: control loop output normalization factor
comment30=parameter group Filter: P-Term coefficient scaler
comment31=parameter group Filter: P-Term coefficient fractional factor
comment32=parameter group Limits: minimum clamping value of primary control output 
comment33=parameter group Limits: maximum clamping value of primary control output 
comment34=parameter group Limits: minimum clamping value of alternate control output 
comment35=parameter group Limits: maximum clamping value of alternate control output 
comment36=parameter group ADCTriggerControl: pointer to ADC trigger A register memory address
comment37=parameter group ADCTriggerControl: value of ADC trigger A offset
comment38=parameter group ADCTriggerControl: pointer to ADC trigger B register memory address
comment39=parameter group ADCTriggerControl: value of ADC trigger B offset
comment40=parameter group DataProviders: pointer to external variable/register the most recent control input will be pushed to
comment41=parameter group DataProviders: pointer to external variable/register the most recent control error will be pushed to
comment42=parameter group DataProviders: pointer to external variable/register the most recent control output will be pushed to
comment43=parameter group CascadeTrigger: pointer to external, cascaded function which will be called by this controller
comment44=parameter group CascadeTrigger: 16-bit wide function parameter or pointer to a parameter data structure of cascaded function
comment45=parameter group GainControl: bit-shift scaler of Adaptive Gain Control Modulation factor
comment46=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation factor
comment47=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation norminal operating point
comment48=parameter group Advanced: generic 16-bit wide, user-defined parameter #1 for advanced control options
comment49=parameter group Advanced: generic 16-bit wide, user-defined parameter #2 for advanced control options
comment50=parameter group Advanced: generic 16-bit wide, user-defined parameter #3 for advanced control options
comment51=parameter group Advanced: generic 16-bit wide, user-defined parameter #4 for advanced control options
code0=.equ Status,                    0
code1=.equ ptrSourceRegister,         2
code2=.equ SourceNormShift,           4
code3=.equ SourceNormFactor,          6
code4=.equ SourceOffset,              8
code5=.equ ptrAltSourceRegister,      10
code6=.equ AltSourceNormShift,        12
code7=.equ AltSourceNormFactor,       14
code8=.equ AltSourceOffset,           16
code9=.equ ptrTargetRegister,         18
code10=.equ TargetNormShift,           20
code11=.equ TargetNormFactor,          22
code12=.equ TargetOffset,              24
code13=.equ ptrAltTargetRegister,      26
code14=.equ AltTargetNormShift,        28
code15=.equ AltTargetNormFactor,       30
code16=.equ AltTargetOffset,           32
code17=.equ ptrCtrlReference,          34
code18=.equ ptrACoefficients,          36
code19=.equ ptrBCoefficients,          38
code20=.equ ptrControlHistory,         40
code21=.equ ptrErrorHistory,           42
code22=.equ ACoeffArraySize,           44
code23=.equ BCoeffArraySize,           46
code24=.equ CtrlHistArraySize,         48
code25=.equ ErrHistArraySize,          50
code26=.equ PreShift,                  52
code27=.equ PostShiftA,                54
code28=.equ reserved_1,                56
code29=.equ PostScaler,                58
code30=.equ pterm_scaler,              60
code31=.equ pterm_factor,              62
code32=.equ MinOutput,                 64
code33=.equ MaxOutput,                 66
code34=.equ AltMinOutput,              68
code35=.equ AltMaxOutput,              70
code36=.equ ptrADCTriggerARegister,    72
code37=.equ ADCTriggerAOffset,         74
code38=.equ ptrADCTriggerBRegister,    76
code39=.equ ADCTriggerBOffset,         78
code40=.equ ptrDProvControlInput,      80
code41=.equ ptrDProvControlError,      82
code42=.equ ptrDProvControlOutput,     84
code43=.equ ptrCascadedFunction,       86
code44=.equ CascadedFunParam,          88
code45=.equ agcGainModScaler,          90
code46=.equ agcGainModFactor,          92
code47=.equ agcGainModMedian,          94
code48=.equ AdvParam1,                 96
code49=.equ AdvParam2,                 98
code50=.equ AdvParam3,                 100
code51=.equ AdvParam4,                 102


[blockset_scscl_0]
;Instruction blockset for output factor modulated, single bit-shifted 16-bit fixed point controllers with output factor scaling
;linear execution of compensation filter
wreg_usage=4,6,8,10,12
accu_usage=a
count=166
0=disclaimer
1=lists
2=section_header
3=add_global_flags
4=add_data_structure_scscl
5=section_code
6=exec_function_head
7=%{(1100)}%context_save
8=%{(1100)&&(1101)}%context_save_shadow
9=%{(1100)}%context_save_status_word_wreg
10=%{(1200)&&(1203)}%enable_disable_start
11=%{(1100)}%context_save
12=%{(1100)&&(1102)}%context_save_mac_registers
13=%{(1100)&&(1103)&&(1104)}%context_save_accumulator_a
14=%{(1100)&&(1103)&&(1105)}%context_save_accumulator_b
15=%{(1100)&&(1106)}%context_save_core_config
16=%{(1100)&&(1107)}%context_save_core_status
17=%{(1200)&&(1202)}%core_config
18=load_a_coeff_array_ptr
19=load_control_history_array_ptr
20=comp_mac_start_acca_clear_prefetch
21=comp_mac_loop_a_term_acca
22=comp_mac_end_acca
23=load_error_history_array_ptr
24=comp_error_history_update
25=comp_read_input
26=%{(1400)&&(1401)}%shadow_copy_control_input
27=comp_get_error
28=%{(1600)&&(1601)}%comp_zero_input
29=%{(1600)&&(1602)}%comp_invert_input
30=%{(1200)&&(1205)}%comp_norm_error
31=%{(1400)&&(1402)}%shadow_copy_error_input
32=load_b_coeff_array_ptr
33=comp_error_add_most_recent_to_history
34=comp_mac_start_accb_clear_prefetch
35=comp_mac_loop_b_term_accb
36=comp_mac_end_accb
37=%{(1800)}%agc_factor_multiply_start
38=%{(1800)&&(1801)}%agc_factor_multiply_enable_start
39=%{(1800)&&(1802)}%agc_factor_multiply_get_factor_call
40=%{(1800)}%agc_factor_multiply_scaled
41=%{(1800)&&(1801)}%agc_factor_multiply_enable_end
42=comp_add_accb_to_acca
43=comp_backward_norm_a_acca
44=comp_mac_store_acca
45=comp_backward_norm_coeff_scaler_acca
46=comp_mac_store_acca
47=%{(1500)}%anti_windup
48=%{(1500)&&(1501)}%anti_windup_max_start
49=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start
50=%{(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
51=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass
52=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start
53=%{(1500)&&(1501)}%anti_windup_max_override
54=%{(1500)&&(1501)&&(1505)}%anti_windup_soft_desaturation
55=%{(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag
56=%{(1500)&&(1501)}%anti_windup_max_options_end
57=%{(1500)&&(1503)}%anti_windup_min_start
58=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start
59=%{(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
60=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass
61=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start
62=%{(1500)&&(1503)}%anti_windup_min_override
63=%{(1500)&&(1503)&&(1505)}%anti_windup_soft_desaturation
64=%{(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag
65=%{(1500)&&(1503)}%anti_windup_min_options_end
66=comp_writeback
67=%{(1400)&&(1403)}%shadow_copy_control_output
68=%{(1200)&&(1206)}%adc_trigger_a_placement
69=%{(1200)&&(1207)}%adc_trigger_b_placement
70=load_control_history_array_ptr
71=comp_control_history_update
72=comp_control_add_most_recent_to_history
73=update_status_bitfield
74=%{(1100)}%context_restore
75=%{(1100)&&(1102)}%context_restore_mac_registers
76=%{(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
77=%{(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
78=%{(1100)&&(1106)}%context_restore_core_config
79=%{(1100)&&(1107)}%context_restore_core_status
80=%{(1200)&&(1203)&&(!1204)}%enable_disable_end
81=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read
82=%{(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input
83=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end
84=%{(1208)}%cascaded_function_call
85=%{(1100)}%context_restore
86=%{(1100)&&(1101)}%context_restore_shadow
87=%{(1100)}%context_restore_status_word_wreg
88=return
89=reset_function_head
90=clear_control_history_start
91=clear_control_history_loop
92=clear_control_history_end
93=clear_error_history_start
94=clear_error_history_loop
95=clear_error_history_end
96=return
97=charge_function_head
98=charge_error_history_start
99=charge_error_history_loop
100=charge_error_history_end
101=charge_control_history_start
102=charge_control_history_loop
103=charge_control_history_end
104=return
105=%{(1209)}%pterm_function_head
106=%{(1209)&&(1100)}%context_save
107=%{(1209)&&(1100)&&(1101)}%context_save_shadow
108=%{(1209)&&(1100)}%context_save_status_word_wreg
109=%{(1209)&&(1200)&&(1203)}%enable_disable_start_pterm
110=%{(1209)&&(1100)}%context_save
111=%{(1209)&&(1100)&&(1102)}%context_save_mac_registers
112=%{(1209)&&(1100)&&(1103)&&(1104)}%context_save_accumulator_a
113=%{(1209)&&(1100)&&(1103)&&(1105)}%context_save_accumulator_b
114=%{(1209)&&(1100)&&(1106)}%context_save_core_config
115=%{(1209)&&(1100)&&(1107)}%context_save_core_status
116=%{(1209)&&(1200)&&(1202)}%core_config
117=%{(1209)}%comp_read_input
118=%{(1209)&&(1400)&&(1401)}%shadow_copy_control_input
119=%{(1209)}%comp_get_error
120=%{(1209)&&(1600)&&(1601)}%comp_zero_input
121=%{(1209)&&(1600)&&(1602)}%comp_invert_input
122=%{(1209)&&(1200)&&(1205)}%comp_norm_error
123=%{(1209)&&(1400)&&(1402)}%shadow_copy_error_input
124=%{(1209)}%pterm_comp_load_gain_factor
125=%{(1209)}%pterm_comp_exec_pterm
126=%{(1209)&&(1500)}%anti_windup
127=%{(1209)&&(1500)&&(1501)}%anti_windup_max_start
128=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start_pterm
129=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
130=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass_pterm
131=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start_pterm
132=%{(1209)&&(1500)&&(1501)}%anti_windup_max_override
133=%{(1209)&&(1500)&&(1501)&&(1505)}%anti_windup_soft_desaturation
134=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag
135=%{(1209)&&(1500)&&(1501)}%anti_windup_max_options_end_pterm
136=%{(1209)&&(1500)&&(1503)}%anti_windup_min_start
137=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start_pterm
138=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
139=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass_pterm
140=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start_pterm
141=%{(1209)&&(1500)&&(1503)}%anti_windup_min_override
142=%{(1209)&&(1500)&&(1503)&&(1505)}%anti_windup_soft_desaturation
143=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag
144=%{(1209)&&(1500)&&(1503)}%anti_windup_min_options_end_pterm
145=%{(1209)}%comp_writeback
146=%{(1209)&&(1400)&&(1403)}%shadow_copy_control_output
147=%{(1209)&&(1200)&&(1206)}%adc_trigger_a_placement
148=%{(1209)&&(1200)&&(1207)}%adc_trigger_b_placement
149=%{(1209)}%update_status_bitfield
150=%{(1209)&&(1100)}%context_restore
151=%{(1209)&&(1100)&&(1102)}%context_restore_mac_registers
152=%{(1209)&&(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
153=%{(1209)&&(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
154=%{(1209)&&(1100)&&(1106)}%context_restore_core_config
155=%{(1209)&&(1100)&&(1107)}%context_restore_core_status
156=%{(1209)&&(1200)&&(1203)&&(!1204)}%enable_disable_end_pterm
157=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_pterm
158=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input
159=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end_pterm
160=%{(1209)&&(1208)}%cascaded_function_call
161=%{(1209)&&(1100)}%context_restore
162=%{(1209)&&(1100)&&(1101)}%context_restore_shadow
163=%{(1209)&&(1100)}%context_restore_status_word_wreg
164=%{(1209)}%return
165=end


[add_data_structure_dbsft]
head_comment=%SEPARATOR%; Address offset declarations for data structure addressing (double bit-shift scaling)
cycles=0
lines=52
comment0=controller object status word at address-offset = 0
comment1=parameter group Ports.Source: pointer to source memory address
comment2=parameter group Ports.Source: bit-shift scaler of normalization factor
comment3=parameter group Ports.Source: Q15 normalization factor
comment4=parameter group Ports.Source: value of source input signal/value offset
comment5=parameter group Ports.AltSource: pointer to alternate source memory address
comment6=parameter group Ports.AltSource: bit-shift scaler of normalization factor
comment7=parameter group Ports.AltSource: Q15 normalization factor
comment8=parameter group Ports.AltSource: value of alternate source input signal/value offset
comment9=parameter group Ports.Target: pointer to target memory address
comment10=parameter group Ports.Target: bit-shift scaler of normalization factor
comment11=parameter group Ports.Target: Q15 normalization factor
comment12=parameter group Ports.Target: value of target output signal/value offset
comment13=parameter group Ports.AltTarget: pointer to alternate target memory address
comment14=parameter group Ports.AltTarget: bit-shift scaler of normalization factor
comment15=parameter group Ports.AltTarget: Q15 normalization factor
comment16=parameter group Ports.AltTarget: value of alternate target output sigal/value offset
comment17=parameter group Ports.ConrolReference: pointer to control reference variable/register memory address
comment18=parameter group Filter: pointer to A-coefficients array start address
comment19=parameter group Filter: pointer to B-coefficients array start address
comment20=parameter group Filter: pointer to control history array start address
comment21=parameter group Filter: pointer to error history array start address
comment22=parameter group Filter: size of the A-coefficients array
comment23=parameter group Filter: size of the B-coefficients array
comment24=parameter group Filter: size of the control history array
comment25=parameter group Filter: size of the error history array
comment26=parameter group Filter: value of input value normalization bit-shift scaler
comment27=parameter group Filter: value of A-term normalization bit-shift scaler
comment28=parameter group Filter: value of B-term normalization bit-shift scaler
comment29=parameter group Filter: (reserved)
comment30=parameter group Filter: P-Term coefficient scaler
comment31=parameter group Filter: P-Term coefficient fractional factor
comment32=parameter group Limits: minimum clamping value of primary control output 
comment33=parameter group Limits: maximum clamping value of primary control output 
comment34=parameter group Limits: minimum clamping value of alternate control output 
comment35=parameter group Limits: maximum clamping value of alternate control output 
comment36=parameter group ADCTriggerControl: pointer to ADC trigger A register memory address
comment37=parameter group ADCTriggerControl: value of ADC trigger A offset
comment38=parameter group ADCTriggerControl: pointer to ADC trigger B register memory address
comment39=parameter group ADCTriggerControl: value of ADC trigger B offset
comment40=parameter group DataProviders: pointer to external variable/register the most recent control input will be pushed to
comment41=parameter group DataProviders: pointer to external variable/register the most recent control error will be pushed to
comment42=parameter group DataProviders: pointer to external variable/register the most recent control output will be pushed to
comment43=parameter group CascadeTrigger: pointer to external, cascaded function which will be called by this controller
comment44=parameter group CascadeTrigger: 16-bit wide function parameter or pointer to a parameter data structure of cascaded function
comment45=parameter group GainControl: bit-shift scaler of Adaptive Gain Control Modulation factor
comment46=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation factor
comment47=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation norminal operating point
comment48=parameter group Advanced: generic 16-bit wide, user-defined parameter #1 for advanced control options
comment49=parameter group Advanced: generic 16-bit wide, user-defined parameter #2 for advanced control options
comment50=parameter group Advanced: generic 16-bit wide, user-defined parameter #3 for advanced control options
comment51=parameter group Advanced: generic 16-bit wide, user-defined parameter #4 for advanced control options
code0=.equ Status,                    0
code1=.equ ptrSourceRegister,         2
code2=.equ SourceNormShift,           4
code3=.equ SourceNormFactor,          6
code4=.equ SourceOffset,              8
code5=.equ ptrAltSourceRegister,      10
code6=.equ AltSourceNormShift,        12
code7=.equ AltSourceNormFactor,       14
code8=.equ AltSourceOffset,           16
code9=.equ ptrTargetRegister,         18
code10=.equ TargetNormShift,           20
code11=.equ TargetNormFactor,          22
code12=.equ TargetOffset,              24
code13=.equ ptrAltTargetRegister,      26
code14=.equ AltTargetNormShift,        28
code15=.equ AltTargetNormFactor,       30
code16=.equ AltTargetOffset,           32
code17=.equ ptrCtrlReference,          34
code18=.equ ptrACoefficients,          36
code19=.equ ptrBCoefficients,          38
code20=.equ ptrControlHistory,         40
code21=.equ ptrErrorHistory,           42
code22=.equ ACoeffArraySize,           44
code23=.equ BCoeffArraySize,           46
code24=.equ CtrlHistArraySize,         48
code25=.equ ErrHistArraySize,          50
code26=.equ PreShift,                  52
code27=.equ PostShiftA,                54
code28=.equ PostShiftB,                56
code29=.equ reserved_2,                58
code30=.equ pterm_scaler,              60
code31=.equ pterm_factor,              62
code32=.equ MinOutput,                 64
code33=.equ MaxOutput,                 66
code34=.equ AltMinOutput,              68
code35=.equ AltMaxOutput,              70
code36=.equ ptrADCTriggerARegister,    72
code37=.equ ADCTriggerAOffset,         74
code38=.equ ptrADCTriggerBRegister,    76
code39=.equ ADCTriggerBOffset,         78
code40=.equ ptrDProvControlInput,      80
code41=.equ ptrDProvControlError,      82
code42=.equ ptrDProvControlOutput,     84
code43=.equ ptrCascadedFunction,       86
code44=.equ CascadedFunParam,          88
code45=.equ agcGainModScaler,          90
code46=.equ agcGainModFactor,          92
code47=.equ agcGainModMedian,          94
code48=.equ AdvParam1,                 96
code49=.equ AdvParam2,                 98
code50=.equ AdvParam3,                 100
code51=.equ AdvParam4,                 102


[blockset_dbsft_0]
;Instruction blockset for double-bit shifted 16-bit fixed point controllers
;linear execution of compensation filter
wreg_usage=4,6,8,10,12
accu_usage=ab
count=165
0=disclaimer
1=lists
2=section_header
3=add_global_flags
4=add_data_structure_dbsft
5=section_code
6=exec_function_head
7=%{(1100)}%context_save
8=%{(1100)&&(1101)}%context_save_shadow
9=%{(1100)}%context_save_status_word_wreg
10=%{(1200)&&(1203)}%enable_disable_start
11=%{(1100)}%context_save
12=%{(1100)&&(1102)}%context_save_mac_registers
13=%{(1100)&&(1103)&&(1104)}%context_save_accumulator_a
14=%{(1100)&&(1103)&&(1105)}%context_save_accumulator_b
15=%{(1100)&&(1106)}%context_save_core_config
16=%{(1100)&&(1107)}%context_save_core_status
17=%{(1200)&&(1202)}%core_config
18=load_a_coeff_array_ptr
19=load_control_history_array_ptr
20=comp_mac_start_acca_clear_prefetch
21=comp_mac_loop_a_term_acca
22=comp_mac_end_acca
23=comp_backward_norm_a_acca
24=load_error_history_array_ptr
25=comp_error_history_update
26=comp_read_input
27=%{(1400)&&(1401)}%shadow_copy_control_input
28=comp_get_error
29=%{(1600)&&(1601)}%comp_zero_input
30=%{(1600)&&(1602)}%comp_invert_input
31=%{(1200)&&(1205)}%comp_norm_error
32=%{(1400)&&(1402)}%shadow_copy_error_input
33=load_b_coeff_array_ptr
34=comp_error_add_most_recent_to_history
35=comp_mac_start_accb_clear_prefetch
36=comp_mac_loop_b_term_accb
37=comp_mac_end_accb
38=%{(1800)}%agc_factor_multiply_start
39=%{(1800)&&(1801)}%agc_factor_multiply_enable_start
40=%{(1800)&&(1802)}%agc_factor_multiply_get_factor_call
41=%{(1800)}%agc_factor_multiply_scaled
42=%{(1800)&&(1801)}%agc_factor_multiply_enable_end
43=comp_backward_norm_b_accb
44=comp_add_accb_to_acca
45=comp_mac_store_acca
46=%{(1500)}%anti_windup
47=%{(1500)&&(1501)}%anti_windup_max_start
48=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start
49=%{(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
50=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass
51=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start
52=%{(1500)&&(1501)}%anti_windup_max_override
53=%{(1500)&&(1501)&&(1505)}%anti_windup_soft_desaturation
54=%{(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag
55=%{(1500)&&(1501)}%anti_windup_max_options_end
56=%{(1500)&&(1503)}%anti_windup_min_start
57=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start
58=%{(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
59=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass
60=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start
61=%{(1500)&&(1503)}%anti_windup_min_override
62=%{(1500)&&(1503)&&(1505)}%anti_windup_soft_desaturation
63=%{(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag
64=%{(1500)&&(1503)}%anti_windup_min_options_end
65=comp_writeback
66=%{(1400)&&(1403)}%shadow_copy_control_output
67=%{(1200)&&(1206)}%adc_trigger_a_placement
68=%{(1200)&&(1207)}%adc_trigger_b_placement
69=load_control_history_array_ptr
70=comp_control_history_update
71=comp_control_add_most_recent_to_history
72=update_status_bitfield
73=%{(1100)}%context_restore
74=%{(1100)&&(1102)}%context_restore_mac_registers
75=%{(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
76=%{(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
77=%{(1100)&&(1106)}%context_restore_core_config
78=%{(1100)&&(1107)}%context_restore_core_status
79=%{(1200)&&(1203)&&(!1204)}%enable_disable_end
80=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read
81=%{(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input
82=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end
83=%{(1208)}%cascaded_function_call
84=%{(1100)}%context_restore
85=%{(1100)&&(1101)}%context_restore_shadow
86=%{(1100)}%context_restore_status_word_wreg
87=return
88=reset_function_head
89=clear_control_history_start
90=clear_control_history_loop
91=clear_control_history_end
92=clear_error_history_start
93=clear_error_history_loop
94=clear_error_history_end
95=return
96=charge_function_head
97=charge_error_history_start
98=charge_error_history_loop
99=charge_error_history_end
100=charge_control_history_start
101=charge_control_history_loop
102=charge_control_history_end
103=return
104=%{(1209)}%pterm_function_head
105=%{(1209)&&(1100)}%context_save
106=%{(1209)&&(1100)&&(1101)}%context_save_shadow
107=%{(1209)&&(1100)}%context_save_status_word_wreg
108=%{(1209)&&(1200)&&(1203)}%enable_disable_start_pterm
109=%{(1209)&&(1100)}%context_save
110=%{(1209)&&(1100)&&(1102)}%context_save_mac_registers
111=%{(1209)&&(1100)&&(1103)&&(1104)}%context_save_accumulator_a
112=%{(1209)&&(1100)&&(1103)&&(1105)}%context_save_accumulator_b
113=%{(1209)&&(1100)&&(1106)}%context_save_core_config
114=%{(1209)&&(1100)&&(1107)}%context_save_core_status
115=%{(1209)&&(1200)&&(1202)}%core_config
116=%{(1209)}%comp_read_input
117=%{(1209)&&(1400)&&(1401)}%shadow_copy_control_input
118=%{(1209)}%comp_get_error
119=%{(1209)&&(1600)&&(1601)}%comp_zero_input
120=%{(1209)&&(1600)&&(1602)}%comp_invert_input
121=%{(1209)&&(1200)&&(1205)}%comp_norm_error
122=%{(1209)&&(1400)&&(1402)}%shadow_copy_error_input
123=%{(1209)}%pterm_comp_load_gain_factor
124=%{(1209)}%pterm_comp_exec_pterm
125=%{(1209)&&(1500)}%anti_windup
126=%{(1209)&&(1500)&&(1501)}%anti_windup_max_start
127=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start_pterm
128=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
129=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass_pterm
130=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start_pterm
131=%{(1209)&&(1500)&&(1501)}%anti_windup_max_override
132=%{(1209)&&(1500)&&(1501)&&(1505)}%anti_windup_soft_desaturation
133=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag
134=%{(1209)&&(1500)&&(1501)}%anti_windup_max_options_end_pterm
135=%{(1209)&&(1500)&&(1503)}%anti_windup_min_start
136=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start_pterm
137=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
138=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass_pterm
139=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start_pterm
140=%{(1209)&&(1500)&&(1503)}%anti_windup_min_override
141=%{(1209)&&(1500)&&(1503)&&(1505)}%anti_windup_soft_desaturation
142=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag
143=%{(1209)&&(1500)&&(1503)}%anti_windup_min_options_end_pterm
144=%{(1209)}%comp_writeback
145=%{(1209)&&(1400)&&(1403)}%shadow_copy_control_output
146=%{(1209)&&(1200)&&(1206)}%adc_trigger_a_placement
147=%{(1209)&&(1200)&&(1207)}%adc_trigger_b_placement
148=%{(1209)}%update_status_bitfield
149=%{(1209)&&(1100)}%context_restore
150=%{(1209)&&(1100)&&(1102)}%context_restore_mac_registers
151=%{(1209)&&(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
152=%{(1209)&&(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
153=%{(1209)&&(1100)&&(1106)}%context_restore_core_config
154=%{(1209)&&(1100)&&(1107)}%context_restore_core_status
155=%{(1209)&&(1200)&&(1203)&&(!1204)}%enable_disable_end_pterm
156=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_pterm
157=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input
158=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end_pterm
159=%{(1209)&&(1208)}%cascaded_function_call
160=%{(1209)&&(1100)}%context_restore
161=%{(1209)&&(1100)&&(1101)}%context_restore_shadow
162=%{(1209)&&(1100)}%context_restore_status_word_wreg
163=%{(1209)}%return
164=end


[add_data_structure_fscl]
head_comment=%SEPARATOR%; Address offset declarations for data structure addressing
cycles=0
lines=52
comment0=controller object status word at address-offset = 0
comment1=parameter group Ports.Source: pointer to source memory address
comment2=parameter group Ports.Source: bit-shift scaler of normalization factor
comment3=parameter group Ports.Source: Q15 normalization factor
comment4=parameter group Ports.Source: value of source input signal/value offset
comment5=parameter group Ports.AltSource: pointer to alternate source memory address
comment6=parameter group Ports.AltSource: bit-shift scaler of normalization factor
comment7=parameter group Ports.AltSource: Q15 normalization factor
comment8=parameter group Ports.AltSource: value of alternate source input signal/value offset
comment9=parameter group Ports.Target: pointer to target memory address
comment10=parameter group Ports.Target: bit-shift scaler of normalization factor
comment11=parameter group Ports.Target: Q15 normalization factor
comment12=parameter group Ports.Target: value of target output signal/value offset
comment13=parameter group Ports.AltTarget: pointer to alternate target memory address
comment14=parameter group Ports.AltTarget: bit-shift scaler of normalization factor
comment15=parameter group Ports.AltTarget: Q15 normalization factor
comment16=parameter group Ports.AltTarget: value of alternate target output sigal/value offset
comment17=parameter group Ports.ConrolReference: pointer to control reference variable/register memory address
comment18=parameter group Filter: pointer to A-coefficients array start address
comment19=parameter group Filter: pointer to B-coefficients array start address
comment20=parameter group Filter: pointer to control history array start address
comment21=parameter group Filter: pointer to error history array start address
comment22=parameter group Filter: size of the A-coefficients array
comment23=parameter group Filter: size of the B-coefficients array
comment24=parameter group Filter: size of the control history array
comment25=parameter group Filter: size of the error history array
comment26=parameter group Filter: value of input value normalization bit-shift scaler
comment27=parameter group Filter: (reserved)
comment28=parameter group Filter: (reserved)
comment29=parameter group Filter: (reserved)
comment30=parameter group Filter: P-Term coefficient scaler
comment31=parameter group Filter: P-Term coefficient fractional factor
comment32=parameter group Limits: minimum clamping value of primary control output 
comment33=parameter group Limits: maximum clamping value of primary control output 
comment34=parameter group Limits: minimum clamping value of alternate control output 
comment35=parameter group Limits: maximum clamping value of alternate control output 
comment36=parameter group ADCTriggerControl: pointer to ADC trigger A register memory address
comment37=parameter group ADCTriggerControl: value of ADC trigger A offset
comment38=parameter group ADCTriggerControl: pointer to ADC trigger B register memory address
comment39=parameter group ADCTriggerControl: value of ADC trigger B offset
comment40=parameter group DataProviders: pointer to external variable/register the most recent control input will be pushed to
comment41=parameter group DataProviders: pointer to external variable/register the most recent control error will be pushed to
comment42=parameter group DataProviders: pointer to external variable/register the most recent control output will be pushed to
comment43=parameter group CascadeTrigger: pointer to external, cascaded function which will be called by this controller
comment44=parameter group CascadeTrigger: 16-bit wide function parameter or pointer to a parameter data structure of cascaded function
comment45=parameter group GainControl: bit-shift scaler of Adaptive Gain Control Modulation factor
comment46=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation factor
comment47=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation norminal operating point
comment48=parameter group Advanced: generic 16-bit wide, user-defined parameter #1 for advanced control options
comment49=parameter group Advanced: generic 16-bit wide, user-defined parameter #2 for advanced control options
comment50=parameter group Advanced: generic 16-bit wide, user-defined parameter #3 for advanced control options
comment51=parameter group Advanced: generic 16-bit wide, user-defined parameter #4 for advanced control options
code0=.equ Status,                    0
code1=.equ ptrSourceRegister,         2
code2=.equ SourceNormShift,           4
code3=.equ SourceNormFactor,          6
code4=.equ SourceOffset,              8
code5=.equ ptrAltSourceRegister,      10
code6=.equ AltSourceNormShift,        12
code7=.equ AltSourceNormFactor,       14
code8=.equ AltSourceOffset,           16
code9=.equ ptrTargetRegister,         18
code10=.equ TargetNormShift,           20
code11=.equ TargetNormFactor,          22
code12=.equ TargetOffset,              24
code13=.equ ptrAltTargetRegister,      26
code14=.equ AltTargetNormShift,        28
code15=.equ AltTargetNormFactor,       30
code16=.equ AltTargetOffset,           32
code17=.equ ptrCtrlReference,          34
code18=.equ ptrACoefficients,          36
code19=.equ ptrBCoefficients,          38
code20=.equ ptrControlHistory,         40
code21=.equ ptrErrorHistory,           42
code22=.equ ACoeffArraySize,           44
code23=.equ BCoeffArraySize,           46
code24=.equ CtrlHistArraySize,         48
code25=.equ ErrHistArraySize,          50
code26=.equ PreShift,                  52
code27=.equ reserved_0,                54
code28=.equ reserved_1,                56
code29=.equ reserved_2,                58
code30=.equ pterm_scaler,              60
code31=.equ pterm_factor,              62
code32=.equ MinOutput,                 64
code33=.equ MaxOutput,                 66
code34=.equ AltMinOutput,              68
code35=.equ AltMaxOutput,              70
code36=.equ ptrADCTriggerARegister,    72
code37=.equ ADCTriggerAOffset,         74
code38=.equ ptrADCTriggerBRegister,    76
code39=.equ ADCTriggerBOffset,         78
code40=.equ ptrDProvControlInput,      80
code41=.equ ptrDProvControlError,      82
code42=.equ ptrDProvControlOutput,     84
code43=.equ ptrCascadedFunction,       86
code44=.equ CascadedFunParam,          88
code45=.equ agcGainModScaler,          90
code46=.equ agcGainModFactor,          92
code47=.equ agcGainModMedian,          94
code48=.equ AdvParam1,                 96
code49=.equ AdvParam2,                 98
code50=.equ AdvParam3,                 100
code51=.equ AdvParam4,                 102


[blockset_fscl_0]
;Instruction blockset for compensation filter computation using fast-floating point scaled coefficients
;linear execution of compensation filter
wreg_usage=4,5,6,8,10,12
accu_usage=ab
count=164
0=disclaimer
1=lists
2=section_header
3=add_global_flags
4=add_data_structure_fscl
5=section_code
6=exec_function_head
7=%{(1100)}%context_save
8=%{(1100)&&(1101)}%context_save_shadow
9=%{(1100)}%context_save_status_word_wreg
10=%{(1200)&&(1203)}%enable_disable_start
11=%{(1100)}%context_save
12=%{(1100)&&(1102)}%fscl_context_save_mac_registers
13=%{(1100)&&(1103)&&(1104)}%context_save_accumulator_a
14=%{(1100)&&(1103)&&(1105)}%context_save_accumulator_b
15=%{(1100)&&(1106)}%context_save_core_config
16=%{(1100)&&(1107)}%context_save_core_status
17=%{(1200)&&(1202)}%core_config
18=load_a_coeff_array_ptr
19=load_control_history_array_ptr
20=fscl_comp_mac_start_clear
21=fscl_comp_mac_first
22=fscl_comp_mac_a_loop
23=fscl_comp_mac_end
24=load_error_history_array_ptr
25=comp_error_history_update
26=comp_read_input
27=%{(1400)&&(1401)}%shadow_copy_control_input
28=comp_get_error
29=%{(1600)&&(1601)}%comp_zero_input
30=%{(1600)&&(1602)}%comp_invert_input
31=%{(1200)&&(1205)}%comp_norm_error
32=%{(1400)&&(1402)}%shadow_copy_error_input
33=load_b_coeff_array_ptr
34=comp_error_add_most_recent_to_history
35=fscl_comp_mac_start_resume
36=fscl_comp_mac_first
37=fscl_comp_mac_b_loop
38=fscl_comp_mac_end
39=%{(1800)}%agc_factor_multiply_start
40=%{(1800)&&(1801)}%agc_factor_multiply_enable_start
41=%{(1800)&&(1802)}%agc_factor_multiply_get_factor_call
42=%{(1800)}%agc_factor_multiply_scaled
43=%{(1800)&&(1801)}%agc_factor_multiply_enable_end
44=comp_mac_store_accb
45=%{(1500)}%anti_windup
46=%{(1500)&&(1501)}%anti_windup_max_start
47=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start
48=%{(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
49=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass
50=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start
51=%{(1500)&&(1501)}%anti_windup_max_override
52=%{(1500)&&(1501)&&(1505)}%anti_windup_soft_desaturation
53=%{(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag
54=%{(1500)&&(1501)}%anti_windup_max_options_end
55=%{(1500)&&(1503)}%anti_windup_min_start
56=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start
57=%{(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
58=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass
59=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start
60=%{(1500)&&(1503)}%anti_windup_min_override
61=%{(1500)&&(1503)&&(1505)}%anti_windup_soft_desaturation
62=%{(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag
63=%{(1500)&&(1503)}%anti_windup_min_options_end
64=comp_writeback
65=%{(1400)&&(1403)}%shadow_copy_control_output
66=%{(1200)&&(1206)}%adc_trigger_a_placement
67=%{(1200)&&(1207)}%adc_trigger_b_placement
68=load_control_history_array_ptr
69=comp_control_history_update
70=comp_control_add_most_recent_to_history
71=update_status_bitfield
72=%{(1100)}%context_restore
73=%{(1100)&&(1102)}%context_restore_mac_registers
74=%{(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
75=%{(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
76=%{(1100)&&(1106)}%context_restore_core_config
77=%{(1100)&&(1107)}%context_restore_core_status
78=%{(1200)&&(1203)&&(!1204)}%enable_disable_end
79=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read
80=%{(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input
81=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end
82=%{(1208)}%cascaded_function_call
83=%{(1100)}%context_restore
84=%{(1100)&&(1101)}%context_restore_shadow
85=%{(1100)}%context_restore_status_word_wreg
86=return
87=reset_function_head
88=clear_control_history_start
89=clear_control_history_loop
90=clear_control_history_end
91=clear_error_history_start
92=clear_error_history_loop
93=clear_error_history_end
94=return
95=charge_function_head
96=charge_error_history_start
97=charge_error_history_loop
98=charge_error_history_end
99=charge_control_history_start
100=charge_control_history_loop
101=charge_control_history_end
102=return
103=%{(1209)}%pterm_function_head
104=%{(1209)&&(1100)}%context_save
105=%{(1209)&&(1100)&&(1101)}%context_save_shadow
106=%{(1209)&&(1100)}%context_save_status_word_wreg
107=%{(1209)&&(1200)&&(1203)}%enable_disable_start_pterm
108=%{(1209)&&(1100)}%context_save
109=%{(1209)&&(1100)&&(1102)}%context_save_mac_registers
110=%{(1209)&&(1100)&&(1103)&&(1104)}%context_save_accumulator_a
111=%{(1209)&&(1100)&&(1103)&&(1105)}%context_save_accumulator_b
112=%{(1209)&&(1100)&&(1106)}%context_save_core_config
113=%{(1209)&&(1100)&&(1107)}%context_save_core_status
114=%{(1209)&&(1200)&&(1202)}%core_config
115=%{(1209)}%comp_read_input
116=%{(1209)&&(1400)&&(1401)}%shadow_copy_control_input
117=%{(1209)}%comp_get_error
118=%{(1209)&&(1600)&&(1601)}%comp_zero_input
119=%{(1209)&&(1600)&&(1602)}%comp_invert_input
120=%{(1209)&&(1200)&&(1205)}%comp_norm_error
121=%{(1209)&&(1400)&&(1402)}%shadow_copy_error_input
122=%{(1209)}%pterm_comp_load_gain_factor
123=%{(1209)}%pterm_comp_exec_pterm
124=%{(1209)&&(1500)}%anti_windup
125=%{(1209)&&(1500)&&(1501)}%anti_windup_max_start
126=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start_pterm
127=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
128=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass_pterm
129=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start_pterm
130=%{(1209)&&(1500)&&(1501)}%anti_windup_max_override
131=%{(1209)&&(1500)&&(1501)&&(1505)}%anti_windup_soft_desaturation
132=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag
133=%{(1209)&&(1500)&&(1501)}%anti_windup_max_options_end_pterm
134=%{(1209)&&(1500)&&(1503)}%anti_windup_min_start
135=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start_pterm
136=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
137=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass_pterm
138=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start_pterm
139=%{(1209)&&(1500)&&(1503)}%anti_windup_min_override
140=%{(1209)&&(1500)&&(1503)&&(1505)}%anti_windup_soft_desaturation
141=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag
142=%{(1209)&&(1500)&&(1503)}%anti_windup_min_options_end_pterm
143=%{(1209)}%comp_writeback
144=%{(1209)&&(1400)&&(1403)}%shadow_copy_control_output
145=%{(1209)&&(1200)&&(1206)}%adc_trigger_a_placement
146=%{(1209)&&(1200)&&(1207)}%adc_trigger_b_placement
147=%{(1209)}%update_status_bitfield
148=%{(1209)&&(1100)}%context_restore
149=%{(1209)&&(1100)&&(1102)}%context_restore_mac_registers
150=%{(1209)&&(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
151=%{(1209)&&(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
152=%{(1209)&&(1100)&&(1106)}%context_restore_core_config
153=%{(1209)&&(1100)&&(1107)}%context_restore_core_status
154=%{(1209)&&(1200)&&(1203)&&(!1204)}%enable_disable_end_pterm
155=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_pterm
156=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input
157=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end_pterm
158=%{(1209)&&(1208)}%cascaded_function_call
159=%{(1209)&&(1100)}%context_restore
160=%{(1209)&&(1100)&&(1101)}%context_restore_shadow
161=%{(1209)&&(1100)}%context_restore_status_word_wreg
162=%{(1209)}%return
163=end


[disclaimer]
;head_comment=;LICENSE / DISCLAIMER ************************************************************\n;  Microchip Technology Inc. and its subsidiaries.  You may use this software \n;  and any derivatives exclusively with Microchip products. \n;  \n;  THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER \n;  EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED \n;  WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A \n;  PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION \n;  WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION. \n;  \n;  IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, \n;  INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND \n;  WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS \n;  BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.  TO THE \n;  FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS \n;  IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF \n;  ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE. \n;  \n;  MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE \n;  TERMS. \n; **********************************************************************************
head_comment=;LICENSE / DISCLAIMER
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%

[lists]
head_comment=%SEPARATOR%;file start
cycles=0
lines=2
comment0=%EMPTY%
code0=.nolist
code1=.list

[section_header]
head_comment=%SEPARATOR%;local inclusions.
cycles=0
lines=1
comment0=place constant data in the data section
code0=.section .data

[section_code]
head_comment=%SEPARATOR%;local inclusions.
cycles=0
lines=1
comment0=place code in the code section
;code0=;.section .libdsp, code
code0=.section .text

[add_global_flags]
head_comment=%SEPARATOR%; Define status flags bit positions
cycles=0
lines=7
comment0=bit position of the ENABLE control bit
comment1=bit position of the INVERT_INPUT control bit
comment2=bit position of the SWAP_SOURCE control bit
comment3=bit position of the SWAP_TARGET control bit
comment4=bit position of the AGC_ENABLED control bit
comment5=bit position of the UPPER_SATURATION_FLAG status bit
comment6=bit position of the LOWER_SATURATION_FLAG status bit
code0=.equ NPNZ16_STATUS_ENABLED,      15
code1=.equ NPNZ16_STATUS_INVERT_INPUT, 14
code2=.equ NPNZ16_STATUS_SWAP_SOURCE,  13
code3=.equ NPNZ16_STATUS_SWAP_TARGET,  12
code4=.equ NPNZ16_STATUS_AGC_ENABLED,  11
code5=.equ NPNZ16_STATUS_USAT,         1
code6=.equ NPNZ16_STATUS_LSAT,         0

[exec_function_head]
head_comment=%SEPARATOR%; Global function declaration\n; This function calls the z-domain controller processing the latest data point input%SEPARATOR%
cycles=0
lines=2
comment0=%EMPTY%
comment1=provide global scope to routine
comment2=start of routine
code0=.global %PREFIXG%_Update
code1=%PREFIXG%_Update:\n

[reset_function_head]
head_comment=%SEPARATOR%; Global function declaration %PREFIXG%_Reset\n; This function clears control and error histories enforcing a reset%SEPARATOR%
cycles=0
lines=2
comment0=%EMPTY%
comment1=%EMPTY%
code0=.global %PREFIXG%_Reset
code1=%PREFIXG%_Reset:

[charge_function_head]
head_comment=%SEPARATOR%; Global function declaration %PREFIXG%_Precharge\n; This function loads user-defined default values into control and error histories%SEPARATOR%
cycles=0
lines=2
comment0=%EMPTY%
comment1=%EMPTY%
code0=.global %PREFIXG%_Precharge
code1=%PREFIXG%_Precharge:

[pterm_function_head]
head_comment=%SEPARATOR%; Global function declaration %PREFIXG%_PTermUpdate\n; This function executes a P-term based control loop used for plant measurements only.\n; THIS LOOP IS NOT SUITED FOR STABLE OPERATION%SEPARATOR%
cycles=0
lines=2
comment0=%EMPTY%
comment1=%EMPTY%
code0=.global %PREFIXG%_PTermUpdate
code1=%PREFIXG%_PTermUpdate:

[clear_control_history_start]
head_comment=%SEPARATOR%; Clear control history array
cycles=0
lines=2
comment0=save contents of working register WREG0
comment1=set pointer to the base address of control history array
code0=push w0
code1=mov  [w0 + #ptrControlHistory], w0

[clear_control_history_loop]
filter_order_loop=a
head_comment=%EMPTY%
cycles=0
lines=1
comment0=clear next address of control history array
code0=clr [w0++]

[clear_control_history_end]
head_comment=%EMPTY%
cycles=0
lines=2
comment0=clear last address of control history array
comment1=restore contents of working register WREG0
code0=clr [w0]
code1=pop w0

[clear_error_history_start]
head_comment=%SEPARATOR%; Clear error history array
cycles=0
lines=2
comment0=save contents of working register WREG0
comment1=set pointer to the base address of error history array
code0=push w0
code1=mov [w0 + #ptrErrorHistory], w0

[clear_error_history_loop]
filter_order_loop=b
head_comment=%EMPTY%
cycles=0
lines=1
comment0=Clear next address of error history array
code0=clr [w0++]

[clear_error_history_end]
head_comment=%EMPTY%
cycles=0
lines=2
comment0=clear last address of error history array
comment1=restore contents of working register WREG0
code0=clr [w0]
code1=pop w0

[charge_control_history_start]
head_comment=%SEPARATOR%; Charge control history array with defined value
cycles=0
lines=3
comment0=save contents of working register WREG0
comment1=save contents of working register WREG2
comment2=set pointer to the base address of control history array
code0=push w0
code1=push w2
code2=mov  [w0 + #ptrControlHistory], w0

[charge_control_history_loop]
filter_order_loop=a
head_comment=%EMPTY%
cycles=0
lines=1
comment0=Load user value into next address of control history array
code0=mov w2, [w0++]

[charge_control_history_end]
head_comment=%EMPTY%
cycles=0
lines=3
comment0=Load user value into last address of control history array
comment1=restore contents of working register WREG2
comment2=restore contents of working register WREG0
code0=mov w2, [w0]
code1=pop w2
code2=pop w0

[charge_error_history_start]
head_comment=%SEPARATOR%; Charge error history array with defined value
cycles=0
lines=3
comment0=save contents of working register WREG0
comment1=save contents of working register WREG1
comment2=set pointer to the base address of error history array
code0=push w0
code1=push w1
code2=mov  [w0 + #ptrErrorHistory], w0

[charge_error_history_loop]
filter_order_loop=b
head_comment=%EMPTY%
cycles=0
lines=1
comment0=Load user value into next address of error history array
code0=mov w1, [w0++]

[charge_error_history_end]
head_comment=%EMPTY%
cycles=0
lines=3
comment0=load user value into last address of error history array
comment1=restore contents of working register WREG1
comment2=restore contents of working register WREG0
code0=mov w1, [w0]
code1=pop w1
code2=pop w0

[context_save]
head_comment=%SEPARATOR%; Save working registers
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%		

[context_restore]
head_comment=%SEPARATOR%; Restore working registers
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%		

[context_save_shadow]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=save shadowed working registers (w0...w3)
code0=push.s		

[context_save_mac_registers]
item_loop=wreg_usage
head_comment=%EMPTY%
cycles=4
lines=4
comment0=save working registers used for MAC operations (w4, w6, w8, w10)
code0=push w4
code1=push w6
code2=push w8
code3=push w10

[context_save_status_word_wreg]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=save working register used for status flag tracking
code0=push w12

[context_save_accumulator_a]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=save accumulator A registers
code0=push ACCAL
code1=push ACCAH
code2=push ACCAU

[context_save_accumulator_b]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=save accumulator B registers
code0=push ACCBL
code1=push ACCBH
code2=push ACCBU

[context_save_core_config]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=save CPU configuration register
code0=push CORCON

[context_save_core_status]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=save CPU status register
code0=push SR

[context_restore_shadow]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=restore shadowed working registers (w0...w3)
code0=pop.s		

[context_restore_mac_registers]
head_comment=%EMPTY%
cycles=4
lines=4
comment0=restore working registers used for MAC operations w4, w6, w8, w10)
code0=pop w4
code1=pop w6
code2=pop w8
code3=pop w10

[context_restore_status_word_wreg]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=restore working register used for status flag tracking
code0=pop w12

[context_restore_accumulator_a]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=restore accumulator A registers
code0=pop ACCAL
code1=pop ACCAH
code2=pop ACCAU

[context_restore_accumulator_b]
head_comment=%EMPTY%
cycles=3
lines=3
comment=restore accumulator B registers
code0=pop ACCBL
code1=pop ACCBH
code2=pop ACCBU

[context_restore_core_config]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=restore CPU configuration registers
code0=pop CORCON

[context_restore_core_status]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=restore CPU status registers
code0=pop SR

[enable_disable_start]
declaration=.equ NPNZ16_STATUS_ENABLED, 15
data_structure=.equ	Status, 0
head_comment=%SEPARATOR%; Check status word for Enable/Disable flag and bypass computation, if disabled
cycles=4
lines=3
comment0=load value of status word into working register
comment1=check ENABLED bit state, skip (do not execute) next instruction if set
comment2=if ENABLED bit is cleared, jump to end of control code
code0=mov [w0 + #Status], w12
code1=btss w12, #NPNZ16_STATUS_ENABLED
code2=bra %PREFIXU%_LOOP_BYPASS

[enable_disable_start_pterm]
declaration=.equ NPNZ16_STATUS_ENABLED, 15
data_structure=.equ	Status, 0
head_comment=%SEPARATOR%; Check status word for Enable/Disable flag and bypass computation when disabled
cycles=4
lines=3
comment0=load value of status word into working register
comment1=check ENABLED bit state, skip (do not execute) next instruction if set
comment2=if ENABLED bit is cleared, jump to end of control code
code0=mov [w0 + #Status], w12
code1=btss w12, #NPNZ16_STATUS_ENABLED
code2=bra %PREFIXU%_PTERM_LOOP_BYPASS

[enable_disable_end_dummy_read]
head_comment=%SEPARATOR%; Enable/Disable bypass branch target with dummy read of source buffer
cycles=2
lines=4
comment0=when enabled, step over dummy read and go straight to EXIT
comment1=Enable/Disable bypass branch target to perform dummy read of source to clear the source buffer
comment2=load pointer to input source register
comment3=move value from input source into working register
code0=goto %PREFIXU%_LOOP_EXIT
code1=%PREFIXU%_LOOP_BYPASS:
code2=mov [w0 + #ptrSourceRegister], w2
code3=mov [w2], w1 

[enable_disable_end_dummy_read_pterm]
head_comment=%SEPARATOR%; Enable/Disable bypass branch target with dummy read of source buffer
cycles=2
lines=4
comment0=when enabled, step over dummy read and go straight to EXIT
comment1=Enable/Disable bypass branch target to perform dummy read of source to clear the source buffer
comment2=load pointer to input source register
comment3=move value from input source into working register
code0=goto %PREFIXU%_PTERM_LOOP_EXIT
code1=%PREFIXU%_PTERM_LOOP_BYPASS:
code2=mov [w0 + #ptrSourceRegister], w2
code3=mov [w2], w1 

[enable_disable_end_dummy_read_end]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=Exit control loop branch target 
code0=%PREFIXU%_LOOP_EXIT:

[enable_disable_end_dummy_read_end_pterm]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=Exit P-Term control loop branch target 
code0=%PREFIXU%_PTERM_LOOP_EXIT:

[enable_disable_end]
head_comment=%SEPARATOR%; Enable/Disable bypass branch target
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_LOOP_BYPASS:

[enable_disable_end_pterm]
head_comment=%SEPARATOR%; Enable/Disable bypass branch target
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_PTERM_LOOP_BYPASS:

[core_config]
head_comment=%SEPARATOR%; Configure DSP for fractional operation with normal saturation (Q1.31 format)
cycles=2
lines=2
comment0=load default value of DSP core configuration enabling saturation and signed fractional multiply
comment1=load default configuration into CORCON register
code0=mov #0x00E4, w4
code1=mov w4, _CORCON

[cascaded_function_call]
head_comment=%SEPARATOR%; Call next function of cascade
cycles=3
lines=3
comment0=load functoin pointer
comment1=load single parameter or pointer to parameter data structure
comment2=call function
code0=mov [w0 + #ptrCascadedFunction], w1
code1=mov [w0 + #CascadedFunParam], w0
code2=call w1

[update_status_bitfield]
head_comment=%SEPARATOR%; Update status flag bitfield
cycles=1
lines=1
comment0=update value of the status word in data structure
code0=mov w12, [w0 + #Status]

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[anti_windup]
head_comment=%SEPARATOR%; Controller Anti-Windup (control output value clamping)
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%

[anti_windup_soft_desaturation]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load address of most recent item in error history
comment1=clear most recent error
code0=mov [w0 + #ptrErrorHistory], w6
code1=clr [w6]

[anti_windup_max_start]
head_comment=\n; Check for upper limit violation
cycles=3
lines=2
comment0=load upper limit value
comment1=compare values and skip next instruction if control output is within operating range (control output < upper limit)
code0=mov [w0 + #MaxOutput], w6
code1=cpslt w4, w6

[anti_windup_max_options_start]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=jump to override label if control output > upper limit
code0=bra %PREFIXU%_CLAMP_MAX_OVERRIDE

[anti_windup_max_options_start_pterm]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=jump to override label if control output > upper limit
code0=bra %PREFIXU%_PTERM_CLAMP_MAX_OVERRIDE

[anti_windup_max_options_override_bypass]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=jump to exit
code0=bra %PREFIXU%_CLAMP_MAX_EXIT

[anti_windup_max_options_override_bypass_pterm]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=jump to exit
code0=bra %PREFIXU%_PTERM_CLAMP_MAX_EXIT

[anti_windup_max_options_override_start]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_CLAMP_MAX_OVERRIDE:

[anti_windup_max_options_override_start_pterm]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_PTERM_CLAMP_MAX_OVERRIDE:

[anti_windup_max_set_status_flag]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=set upper limit saturation flag bit
code0=bset w12, #NPNZ16_STATUS_USAT

[anti_windup_max_clear_status_flag]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=clear upper limit saturation flag bit
code0=bclr w12, #NPNZ16_STATUS_USAT

[anti_windup_max_override]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=override controller output
code0=mov w6, w4

[anti_windup_max_options_end]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_CLAMP_MAX_EXIT:

[anti_windup_max_options_end_pterm]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_PTERM_CLAMP_MAX_EXIT:

[anti_windup_min_start]
head_comment=\n; Check for lower limit violation
cycles=3
lines=2
comment0=load lower limit value
comment1=compare values and skip next instruction if control output is within operating range (control output > lower limit)
code0=mov [w0 + #MinOutput], w6
code1=cpsgt w4, w6

[anti_windup_min_options_start]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=jump to override label if control output < lower limit
code0=bra %PREFIXU%_CLAMP_MIN_OVERRIDE

[anti_windup_min_options_start_pterm]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=jump to override label if control output < lower limit
code0=bra %PREFIXU%_PTERM_CLAMP_MIN_OVERRIDE

[anti_windup_min_options_override_bypass]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=jump to exit
code0=bra %PREFIXU%_CLAMP_MIN_EXIT

[anti_windup_min_options_override_bypass_pterm]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=jump to exit
code0=bra %PREFIXU%_PTERM_CLAMP_MIN_EXIT

[anti_windup_min_options_override_start]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_CLAMP_MIN_OVERRIDE:

[anti_windup_min_options_override_start_pterm]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_PTERM_CLAMP_MIN_OVERRIDE:

[anti_windup_min_set_status_flag]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=set lower limit saturation flag bit
code0=bset w12, #NPNZ16_STATUS_LSAT

[anti_windup_min_clear_status_flag]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=clear lower limit saturation flag bit
code0=bclr w12, #NPNZ16_STATUS_LSAT

[anti_windup_min_override]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=override controller output
code0=mov w6, w4

[anti_windup_min_options_end]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_CLAMP_MIN_EXIT:

[anti_windup_min_options_end_pterm]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_PTERM_CLAMP_MIN_EXIT:

[comp_read_input]
head_comment=%SEPARATOR%; Read data from input source and calculate error input to transfer function
cycles=2
lines=2
comment0=load pointer to input source register
comment1=move value from input source into working register
code0=mov [w0 + #ptrSourceRegister], w2
code1=mov [w2], w1

[comp_read_input_with_alt_source_switch]
head_comment=%SEPARATOR%; Read data from primary or alternate input source and calculate error input to transfer function
cycles=4
lines=4
comment0=load pointer to alternate input source register
comment1=test SWAP_SOURCE status bit in status word and skip following instruction if cleared
comment2=load pointer to primary input source register
comment3=move value from primary or alternate input source into working register
code0=mov [w0 + #ptrSourceRegister], w2
code1=btsc w12, #NPNZ16_STATUS_SWAP_SOURCE
code2=mov [w0 + #ptrAltSourceRegister], w2
code3=mov [w2], w1

[comp_zero_input]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load input offset value into working register
comment1=add offset to error value
code0=mov [w0 + #SourceOffset], w2
code1=add w1, w2, w1

[comp_invert_input]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=Test control bit if value should be inverted
comment1=invert value
code0=btsc w12, #NPNZ16_STATUS_INVERT_INPUT
code1=neg w1, w1

[shadow_copy_control_input]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load pointer address of target buffer of most recent controller input from data structure
comment1=copy most recent controller input value to given data buffer target
code0=mov [w0 + #ptrDProvControlInput], w2
code1=mov w1, [w2]

[comp_get_error]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=move pointer to control reference into working register
comment1=calculate error (=reference - input)
code0=mov [w0 + #ptrCtrlReference], w2
code1=subr w1, [w2], w1

[comp_norm_error]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=move error input scaler into working register
comment1=normalize error result to fractional number format
code0=mov [w0 + #PreShift], w2
code1=sl w1, w2, w1

[shadow_copy_error_input]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load pointer address of target buffer of most recent error value from data structure
comment1=copy most recent error value to given data buffer target
code0=mov [w0 + #ptrDProvControlError], w2
code1=mov w1, [w2]

[shadow_copy_control_output]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load pointer address of target buffer of most recent controller output value from data structure
comment1=copy most recent controller output value to given data buffer target
code0=mov [w0 + #ptrDProvControlOutput], w2
code1=mov w1, [w2]

[comp_error_history_update]
address_loop=b
head_comment=%SEPARATOR%; Update error history (move error one tick along the delay line)
cycles=2
lines=2
comment0=move entry (n-%INDEX%) into buffer 
comment1=move buffered value one tick down the delay line
code0=mov [w10 + #%INDEX*ADDR_DATA-ADDR_DATA%], w6
code1=mov w6, [w10 + #%INDEX*ADDR_DATA%]

[comp_error_history_update_reverse]
filter_order_loop=b
head_comment=%SEPARATOR%; Update error history in reverse order (move error one tick along the delay line)
cycles=2
lines=2
comment0=move entry (n-%FO-INDEX%) one tick down the delay line
code0=mov [w10 + #%FO*ADDR_DATA% - #%INDEX*ADDR_DATA+ADDR_DATA%], w6
code1=mov w6, [w10 + #%FO*ADDR_DATA% - #%INDEX*ADDR_DATA%]

[comp_error_add_most_recent_to_mac]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=load most recent error input into MAC wreg
code0=mov w1, w6

[comp_error_add_most_recent_to_history]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent error input to history array
code0=mov w1, [w10]

[comp_error_add_most_recent_to_history_reverse]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent error input to history array
code0=mov w1, [w10 + #%FO*ADDR_DATA% - %FO*ADDR_DATA%]

[comp_control_history_update]
address_loop=a
head_comment=%SEPARATOR%; Update control output history
cycles=2
lines=2
comment0=move entry (n-%INDEX%) one tick down the delay line
code0=mov [w10 + #%INDEX*ADDR_DATA-ADDR_DATA%], w6
code1=mov w6, [w10 + #%INDEX*ADDR_DATA%]

[comp_control_history_update_reverse]
filter_order_loop=a
head_comment=%SEPARATOR%; Update control history in reverse order (move error one tick along the delay line)
cycles=2
lines=2
comment0=move entry (n-%FO-INDEX%) one tick down the delay line
code0=mov [w10 + #%FO*ADDR_DATA% - #%INDEX*ADDR_DATA+ADDR_DATA%], w6
code1=mov w6, [w10 + #%FO*ADDR_DATA% - #%INDEX*ADDR_DATA%]

[comp_control_add_most_recent_to_history]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent control output to history
code0=mov w4, [w10]

[comp_control_add_most_recent_to_history_reverse]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent control output to history
code0=mov w4, [w10 - %FO*ADDR_DATA%]

[comp_control_add_most_recent_to_history_indirect]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent control output to history
code0=mov w4, [w0 + #ptrControlHistory]

[load_a_coeff_array_ptr]
head_comment=%SEPARATOR%; Setup pointers to A-Term data arrays
cycles=1
lines=1
comment0=load pointer to first index of A coefficients array
code0=mov [w0 + #ptrACoefficients], w8

[load_a_coeff_array_ptr_reverse]
head_comment=%SEPARATOR%; Setup pointers to end of A-Term data arrays
cycles=2
lines=2
comment0=load pointer to end of A coefficients array
code0=mov [w0 + #ptrBCoefficients], w8
code1=add w8, #%FO*ADDR_COEF%, w8

[load_b_coeff_array_ptr]
head_comment=%SEPARATOR%; Setup pointers to B-Term data arrays
cycles=1
lines=1
comment0=load pointer to first index of B coefficients array
code0=mov [w0 + #ptrBCoefficients], w8

[load_b_coeff_array_ptr_reverse]
head_comment=%SEPARATOR%; Setup pointers to end of B-Term data arrays
cycles=2
lines=2
comment0=load pointer to end of B coefficients array
code0=mov [w0 + #ptrBCoefficients], w8
code1=add w8, #%FO*ADDR_COEF%, w8

[load_b0_coeff_to_wreg]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=Load coefficient B0 into wreg
code0=mov [w8], w6

[load_error_history_array_ptr]
head_comment=%SEPARATOR%; Setup pointer to first element of error history array
cycles=1
lines=1
comment0=load pointer address into wreg
code0=mov [w0 + #ptrErrorHistory], w10

[load_error_history_array_ptr_reverse]
head_comment=%SEPARATOR%; Setup pointer to first element of error history array
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #ptrErrorHistory], w10
code1=add w10, #%FO*ADDR_DATA%, w10

[load_error_history_before_update_array_ptr]
head_comment=%SEPARATOR%; Setup pointer to second element of error history array
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #ptrErrorHistory], w10
code1=add w10, #%ADDR_DATA%, w10

[load_error_history_before_update_array_ptr_reverse]
head_comment=%SEPARATOR%; Setup pointer to penultimate element of error history array
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #ptrErrorHistory], w10
code1=add w10, #%FO*ADDR_DATA-ADDR_DATA%, w10

[load_control_history_array_ptr]
head_comment=%SEPARATOR%; Load pointer to first element of control history array
cycles=1
lines=1
comment0=load pointer address into wreg
code0=mov [w0 + #ptrControlHistory], w10

[load_control_history_array_ptr_reverse]
head_comment=%SEPARATOR%; Load pointer to last element of control history array (reverse addressing)
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #ptrControlHistory], w10
code1=add w10, #%FO*ADDR_DATA%, w10

[load_control_history_before_update_array_ptr]
head_comment=%SEPARATOR%; Load pointer to second element of control history array
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #ptrControlHistory], w10
code1=add w10, #%ADDR_DATA%, w10

[load_control_history_array_before_update_ptr_reverse]
head_comment=%SEPARATOR%; Load pointer to penultimate element of control history array (reverse addressing)
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #ptrControlHistory + %FO*ADDR_DATA-ADDR_DATA%], w10

[comp_mac_start_acca_clear_no_prefetch]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=clear accumulator A without prefetch of operands
code0=clr a

[comp_mac_start_acca_clear_prefetch]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=clear accumulator A and prefetch first operands
code0=clr a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_start_acca_reverse_clear]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=clear accumulator A and prefetch last operands
code0=clr a, [w8]-=%ADDR_COEF%, w4, [w10 + #%FO*ADDR_DATA%]-=%ADDR_DATA%, w6

[comp_mac_start_acca_resume]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=leave contents accumulator A untouched and prefetch first operands
code0=movsac a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_start_acca_reverse_resume]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=leave contents accumulator A untouched and prefetch last operands
code0=movsac a, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_start_accb_clear_no_prefetch]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=clear accumulator B without prefetch of operands
code0=clr b

[comp_mac_start_accb_clear_prefetch]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=clear accumulator B and prefetch first operands
code0=clr b, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_start_accb_reverse_clear]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=clear accumulator B and prefetch last operands
code0=clr b, [w8]-=%ADDR_COEF%, w4, [w10 + #%FO*ADDR_DATA%]-=%ADDR_DATA%, w6

[comp_mac_start_accb_resume]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=leave contents of accumulator B untouched and prefetch first operands
code0=movsac b, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_start_accb_reverse_resume]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=leave contents of accumulator B untouched and prefetch last operands
code0=movsac b, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_loop_a_term_acca]
filter_order_loop=a
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply control output (n-%INDEX%) from the delay line with coefficient A%INDEX%
code0=mac w4*w6, a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_loop_a_term_reverse_acca]
filter_order_loop=a
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply control output (n-%FO-INDEX%) from the delay line with coefficient A%FO-INDEX%
code0=mac w4*w6, a, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_loop_a_term_accb]
filter_order_loop=a
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply control output (n-%INDEX%) from the delay line with coefficient A%INDEX%
code0=mac w4*w6, b, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_loop_a_term_reverse_accb]
filter_order_loop=a
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply control output (n-%FO-INDEX%) from the delay line with coefficient A%FO-INDEX%
code0=mac w4*w6, b, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_loop_b_term_acca]
filter_order_loop=b
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate error input (n-%INDEX%) from the delay line with coefficient B%INDEX% and prefetch next operands
code0=mac w4*w6, a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_loop_b_term_reverse_acca]
filter_order_loop=b
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate error input (n-%FO-INDEX%) from the delay line with coefficient B%FO-INDEX% and prefetch next operands
code0=mac w4*w6, a, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_loop_b_term_accb]
filter_order_loop=b
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate error input (n-%INDEX%) from the delay line with coefficient B%INDEX% and prefetch next operands
code0=mac w4*w6, b, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_loop_b_term_reverse_accb]
filter_order_loop=b
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate error input (n-%FO-INDEX%) from the delay line with coefficient B%FO-INDEX% and prefetch next operands
code0=mac w4*w6, b, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_end_acca]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate last control output with coefficient of the delay line (no more prefetch)
code0=mac w4*w6, a

[comp_mac_end_accb]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate last error input with coefficient of the delay line (no more prefetch)
code0=mac w4*w6, b

[comp_backward_norm_a_acca]
head_comment=%SEPARATOR%; Backward normalization of recent result
cycles=2
lines=2
comment0=load A-coefficients post bit-shift scaler value into working register
comment1=shift accumulator A by number of bits loaded in working register
code0=mov [w0 + #PostShiftA], w6
code1=sftac a, w6

[comp_backward_norm_a_accb]
head_comment=%SEPARATOR%; Backward normalization of recent result
cycles=2
lines=2
comment0=load A-coefficients post bit-shift scaler value into working register
comment1=shift accumulator A by number of bits loaded in working register
code0=mov [w0 + #PostShiftA], w6
code1=sftac b, w6

[comp_backward_norm_b_acca]
head_comment=%SEPARATOR%; Backward normalization of recent result
cycles=2
lines=2
comment0=load B-coefficients post bit-shift scaler value into working register
comment1=shift accumulator B by number of bits loaded in working register
code0=mov [w0 + #PostShiftB], w6
code1=sftac a, w6

[comp_backward_norm_b_accb]
head_comment=%SEPARATOR%; Backward normalization of recent result
cycles=2
lines=2
comment0=load B-coefficients post bit-shift scaler value into working register
comment1=shift accumulator B by number of bits loaded in working register
code0=mov [w0 + #PostShiftB], w6
code1=sftac b, w6

[comp_backward_norm_coeff_scaler_acca]
head_comment=%SEPARATOR%; Initialize Scale-factor and multiply
cycles=2
lines=2
comment0=load post scaler fractional value into working register
comment1=multiply control output by scaler value loaded into working register
code0=mov [w0 + #PostScaler],  w6
code1=mpy w4*w6, a

[comp_mac_store_acca]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=store most recent accumulator result in working register
code0=sac.r a, w4

[comp_mac_store_accb]
head_comment=\n; Backwards normalization of the controller output
cycles=1
lines=1
comment0=store most recent accumulator result in working register
code0=sac.r b, w4

[comp_mac_load32b_a]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=load value of saved accumulator upper word into accumulator A
comment1=load value of saved accumulator high word into accumulator A
comment2=load value of saved accumulator low word into accumulator A
code0=mov [w0 + #ACCxU], accau
code1=mov [w0 + #ACCxH], accah
code2=mov [w0 + #ACCxL], accal

[comp_mac_load32b_accb]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=load value of saved accumulator upper word into accumulator B
comment1=load value of saved accumulator high word into accumulator B
comment2=load value of saved accumulator low word into accumulator B
code0=mov [w0 + #ACCxU], accbu
code1=mov [w0 + #ACCxH], accbh
code2=mov [w0 + #ACCxL], accbl

[comp_mac_store32b_a]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=store value of accumulator A upper word into data structure
comment1=store value of accumulator A high word into data structure
comment2=store value of accumulator A low word into data structure
code0=mov accau, [w0 + #ACCxU]
code1=mov accah, [w0 + #ACCxH]
code2=mov accal, [w0 + #ACCxL]

[comp_mac_store32b_accb]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=store value of accumulator B upper word into data structure
comment1=store value of accumulator B high word into data structure
comment2=store value of accumulator B low word into data structure
code0=mov accbu, [w0 + #ACCxU]
code1=mov accbh, [w0 + #ACCxH]
code2=mov accbl, [w0 + #ACCxL]

[comp_add_acca_to_accb]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add accumulator a to accumulator b
code0=add b

[comp_add_accb_to_acca]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add accumulator b to accumulator a
code0=add a

[comp_writeback]
head_comment=%SEPARATOR%; Write control output value to target
cycles=2
lines=2
comment0=move pointer to target in to working register
comment1=move control output into target address
code0=mov [w0 + #ptrTargetRegister], w8
code1=mov w4, [w8]

[comp_writeback_with_alt_target_switch]
head_comment=%SEPARATOR%; Write control output value to target
cycles=4
lines=4
comment0=move pointer to target to working register
comment1=if SWAP TARGET option is enabled, execute next instruction
comment2=move pointer to alternate target to working register
comment3=move control output into target address
code0=mov [w0 + #ptrTargetRegister], w8
code1=btsc w12, #NPNZ16_STATUS_SWAP_TARGET
code2=mov [w0 + #ptrAltTargetRegister], w8
code3=mov w4, [w8]

[comp_writeback_ssm]
head_comment=%SEPARATOR%; Add spread specturm modulator
cycles=3
lines=3
comment0=%EMPTY%
code0=mov [w0 + #ptrTargetRegister], w8
code1=mov [w0 + #ssmFactor], w6
code2=mpy w4*w6, [w8]

[adc_trigger_a_placement]
head_comment=%SEPARATOR%; Update ADC trigger A position
cycles=5
lines=5
comment0=half control output by shifting value one bit to the right
comment1=load user-defined ADC trigger A offset value into working register
comment2=add user-defined ADC trigger A offset to half of control output
comment3=load pointer to ADC trigger A register into working register
comment4=push new ADC trigger value to ADC trigger A register
code0=asr w4, #1, w6
code1=mov [w0 + #ADCTriggerAOffset], w8
code2=add w6, w8, w10
code3=mov [w0 + #ptrADCTriggerARegister], w8
code4=mov w10, [w8]

[adc_trigger_b_placement]
head_comment=%SEPARATOR%; Update ADC trigger B position
cycles=4
lines=4
comment0=half control output by shifting value one bit to the right
comment1=load user-defined ADC trigger B offset value into working register
comment2=add user-defined ADC trigger B offset to half of control output
comment3=load pointer to ADC trigger B register into working register
comment4=push new ADC trigger value to ADC trigger B register
code0=mov [w0 + #ADCTriggerBOffset], w8
code1=add w6, w8, w10
code2=mov [w0 + #ptrADCTriggerBRegister], w8
code3=mov w10, [w8]

[return]
head_comment=%SEPARATOR%; End of routine
cycles=1
lines=2
comment0=%EMPTY%
code0=return
code1=%SEPARATOR%

[end]
head_comment=%SEPARATOR%; End of file
cycles=1
lines=2
comment0=%EMPTY%
code0=.end
code1=%SEPARATOR%

;
; Specific projected floating point instruction blocks
;

[fscl_context_save_mac_registers]
item_loop=wreg_usage
head_comment=%EMPTY%
cycles=5
lines=5
comment0=save working registers used for MAC operations (w4, w5, w6, w8, w10)
code0=push w4
code1=push w5
code2=push w6
code3=push w8
code4=push w10

[fscl_context_restore_mac_registers]
item_loop=wreg_usage
head_comment=%EMPTY%
cycles=5
lines=5
comment0=restore working registers used for MAC operations (w4, w5, w6, w8, w10)
code0=pop w4
code1=pop w5
code2=pop w6
code3=pop w8
code4=pop w10

[fscl_comp_mac_start_clear]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=2
lines=2
comment0=clear both accumulators and prefetch first operands
code0=clr b, [w8]+=%ADDR_DATA%, w5
code1=clr a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[fscl_comp_mac_start_resume]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=2
lines=2
comment0=leave contents of accumulator B unchanged
comment1=clear accumulator A and prefetch first operands
code0=movsac b, [w8]+=%ADDR_DATA%, w5
code1=clr a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[fscl_comp_mac_first]
head_comment=%EMPTY%
cycles=4
lines=4
comment0=multiply control output (n-%INDEX%) from the delay line with coefficient X%INDEX%
comment1=shift accumulator to post-scale floating number
comment2=adding accumulator b to a
code0=mpy w4*w6, a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6
code1=sftac a, w5
code2=add b

[fscl_comp_mac_a_loop]
filter_order_loop=as
head_comment=%EMPTY%
cycles=4
lines=4
comment0=load scaler into wreg
comment1=multiply control output (n-%INDEX%) from the delay line with coefficient X%INDEX%
comment2=shift accumulator to post-scale floating number
comment3=adding accumulator b to a
code0=mov [w8 - #%ADDR_DATA*3%], w5
code1=mpy w4*w6, a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6
code2=sftac a, w5
code3=add b

[fscl_comp_mac_b_loop]
filter_order_loop=bs
head_comment=%EMPTY%
cycles=4
lines=4
comment0=load scaler into wreg
comment1=multiply control output (n-%INDEX%) from the delay line with coefficient X%INDEX%
comment2=shift accumulator to post-scale floating number
comment3=adding accumulator b to a
code0=mov [w8 - #%ADDR_DATA*3%], w5
code1=mpy w4*w6, a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6
code2=sftac a, w5
code3=add b

[fscl_comp_mac_end]
head_comment=%EMPTY%
cycles=4
lines=4
comment0=load scaler into wreg
comment1=multiply & accumulate last control output with coefficient of the delay line (no more prefetch)
comment2=shift accumulator to post-scale floating number
comment3=adding accumulator b to a
code0=mov [w8 - #%ADDR_DATA*3%], w5
code1=mpy w4*w6, a
code2=sftac a, w5
code3=add b

[pterm_comp_load_gain_factor]
head_comment=%SEPARATOR%; Load P-gain factor from data structure
cycles=3
lines=3
comment0=move P-coefficient fractional into working register
comment1=move P-coefficient scaler into working register
comment2=move error to MPY working register 
code0=mov [w0 + #pterm_factor], w6
code1=mov [w0 + #pterm_scaler], w5 
code2=mov w1, w4

[pterm_comp_exec_pterm]
head_comment=; calculate P-control result
cycles=3
lines=3
comment0=multiply most recent error with P-coefficient
comment1=shift accumulator to post-scale floating number
comment2=store accumulator result to working register
code0=mpy w4*w6, a
code1=sftac a, w5
code2=sac.r a, w4

[agc_factor_multiply_start]
head_comment=%SEPARATOR%; Adaptive Loop Gain Modulation
cycles=0
lines=0

[agc_factor_multiply_enable_start]
head_comment=%EMPTY%
cycles=3
lines=2
comment0=check status bit if Adaptive Gain Control is enabled
comment1=branch to end of AGC calculation if not
code0=btss w12, #NPMZ16_STATUS_AGC_ENABLED
code1=bra %PREFIXU%_BYPASS_AGC

[agc_factor_multiply_enable_end]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=branch target for AGC enable-/disable-switch
code0=%PREFIXU%_BYPASS_AGC:

[agc_factor_multiply_get_factor_call]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=call function determining most recent modulation factor
code0=call %PREFIXG%_GetGainFactor

[agc_factor_multiply_scaled]
head_comment=%EMPTY%
cycles=5
lines=5
comment0=load AGC modulation factor into working register
comment1=load AGC modulation factor scaler into working register
comment2=store result of accumulator B in working register
comment3=multiply accumulator B result with AGC modulation factor
comment4=shift result by AGC scaler
code0=mov [w0 + #agcGainModFactor], w4  
code1=mov [w0 + #agcGainModScaler], w2
code2=sac.r b, w6
code3=mpy w4*w6, b
code4=sftac b, w2

[agc_factor_get_factor]
head_comment=%SEPARATOR%; Global function declaration %PREFIXG%_GetGainFactor\n; This function calculates a the gain modulation factor \n; by deviding Alternate Source by Source%SEPARATOR%
cycles=9
lines=21
comment0=%EMPTY%
comment1=%EMPTY%
comment2=load pointer to most recent input voltage register
comment3=load value into w1
comment4=load most recent input voltage normalization scaler
comment5=normalize input voltage value
comment6=load pointer to most recent output voltage register
comment7=load value into w2
comment8=load most recent output voltage normalization scaler
comment9=normalize output voltage value
comment10=calculate most recent VL, place result in w6
comment11=load pointer to nominal VL
comment12=Save working register WREG0 (holds data structure start address)
comment13=clear divider target register #0
comment14=clear divider target register #1
comment15=repeat divide instructions n-times
comment16=divide nominal VL by instantaneous VL
comment17=normalize result to Q15 number
comment18=move result outo f WREG0
comment19=restore WREG0 to get access to data structure back
comment20=move gain factor result back into data structure
code0=.global %PREFIXG%_GetGainFactor
code1=%PREFIXG%_GetGainFactor:\n
code2=mov [w0 + #ptrAltSourceRegister], w1
code3=mov [w1], w1 
code4=mov [w0 + AltSourceNormShift], w3
code5=sl  w1, w3, w1
code6=mov [w0 + #ptrSourceRegister], w2
code7=mov [w2], w2
code8=mov [w0 + SourceNormShift], w3
code9=sl  w2, w2, w2
code10=sub w1, w2, w6
code11=mov [w0 + #agcGainModMedian], w4
code12=push w0
code13=clr  w0
code14=clr  w1
code15=repeat #[%P33C%$5][%P33E%$17][%P33F%$17]
code16=divf w4, w6
code17=sl w0, #1, w0
code18=mov w0, w2
code19=pop w0
code20=mov w2, [w0 + #agcGainModFactor]


___________________________________________________
(C)2020, Microchipt Technology Inc.
