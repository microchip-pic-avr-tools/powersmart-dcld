[generic]
Name=Assembly Generator Script
Description=This script defines DSP assembly code generation templates used to generate user-tailored SMPS control loops using the DCLD SDK
Author=Andreas Reiter - M91406
Version=2.0.6
Date=04/03/2020

[history]
count=21
0=04/03/19;1.1.1;Added input offset compensation applied to input source
1=10/18/19;1.2.0;Changed existing input offset compensation to full bi-directional feedback implementation
2=10/19/19;1.2.1;Added code option for feedback signal rectification
3=10/22/19;1.2.2;Fixed typos in comments of data structure
4=11/07/19;1.2.3;Added 'Dummy Read of Source Buffer' when control loop is disabled\r\nAdded second ADC trigger placement target and offset
5=11/08/19;1.2.4;Added 'Changed data provider items from local copies in cNPNZ16b_t data structure to poinbter to external data buffers
6=01/10/19;1.3.0;Added support for cascaded functions. This allows a controller to call another controller or user-defined function extension code module
7=01/13/2020;1.3.1;Reordered cascaded function call to execute full cascade even if controller is disabled.
8=03/02/2020;1.3.2;Added comments to assembly building blocks
9=03/04/2020;1.3.3;Fixed bug in single bit-shift scaler data structure declaration
10=03/04/2020;1.3.4;Fixed bug with corrupted character in floating point scaling data structure
11=03/24/2020;1.3.5;Added Adaptive Gain Control Modulation factors to cNPNZ_t data structure
12=03/24/2020;1.3.8;Renamed data structure prefix NPMZ16_ to NPNZ16_
13=03/25/2020;1.3.9;Added Adaptive Gain Control Modulation to single.bit shifted, dual bit shifted and output factor scaling modes
14=03/26/2020;2.0.0;Introduction of unified 32-bit wide coefficient number format
15=03/27/2020;2.0.1;Separated controller input and output port definitions in individual data structures with normalization parameters
16=03/30/2020;2.0.2;Polished comments
17=03/31/2020;2.0.3;Added P-Term control loop  for plant measurement support
18=04/03/2020;2.0.4;option_token_test
19=04/03/2020;2.0.5;Added Token IDs for enahanced code generator option support
20=04/03/2020;2.0.6;Added Token IDs for enhanced code generator option support

[filter_block_scaling_modes]
count=6
0=%EMPTY%
1=sbsft
2=scscl
3=dbsft
4=fscl
5=ffloat

[filter_block_scaling_modes_descritpion]
sbsft=Single Bitshift-Scaling Mode
scscl=Single Coefficient Factor Scaling Mode
dbsft=Dual Bitshift-Scaling Mode
fscl=Fast Floating Point Coefficient Scaling Mode
ffloat=Fast Floating Point Mode

[filter_block_array_addressing_coeff]
addr_offset_sbft=4
addr_offset_scscl=4
addr_offset_dbsft=4
addr_offset_fscl=4
addr_offset_ffloat=4

[filter_block_array_addressing_data]
addr_offset_sbft=2
addr_offset_scscl=2
addr_offset_dbsft=2
addr_offset_fscl=2
addr_offset_ffloat=2

[MSExcelExport]
PoleAtOrigin=IMDIV(wp0 ,COMPLEX(0,[<SHEET.CELL.RADIANDS>]))
LeadLagBlock=IMDIV(IMSUM(IMDIV(COMPLEX(0,[<SHEET.CELL.RADIANDS>]),wz%FO%,1),IMSUM(IMDIV(COMPLEX(0,[<SHEET.CELL.RADIANDS>]),wp%FO%),1))
FORMULA=IMPRODUCT(%PoleAtOrigin%, %LeadLagBlock%)


[tokens]
count=18
0=%EMPTY%
1=%SPACE%
2=%IDENT%
3=%DATA_TYPE_FRACTIONAL%
4=%DATA_TYPE_INT32%
5=%FILE_NAME_PATTERN%
6=%PREFIX%
7=%FILTER_ORDER%
8=%FILTER_ORDER+1%
9=%STRUCTURE_LABEL%
10=%CGS_VERSION%
11=%CGS_VERSION_DATE%
12=%APP_PRODUCT_NAME%
13=%APP_PRODUCT_VERSION%
14=%SUPPORT_URL%
15=%VENDOR_URL%
16=%TOOL_HOME_URL%

[option_ids]
count=37
0=%{(1100)}%;context_management
1=%{(1101)}%;context_shadow
2=%{(1102)}%;context_mac_wreg
3=%{(1103)}%;context_acc
4=%{(1104)}%;context_acc_a
5=%{(1105)}%;context_acc_b
6=%{(1106)}%;context_core_config
7=%{(1107)}%;context_core_status
8=%{(1200)}%;option_enable
9=%{(1201)}%;option_store_reload_acc
10=%{(1202)}%;option_core_config
11=%{(1203)}%;option_enable_switch
12=%{(1204)}%;option_enable_switch_always_read
13=%{(1205)}%;option_error_normalization
14=%{(1206)}%;option_adc_trigger_a_placement
15=%{(1207)}%;option_adc_trigger_b_placement
16=%{(1208)}%;option_cascade_call
17=%{(1209)}%;option_add_p-term
18=%{(1300)}%;data_interface_enable
19=%{(1301)}%;data_interface_alt_input
20=%{(1302)}%;data_interface_alt_output
21=%{(1400)}%;data_provider_enable
22=%{(1401)}%;data_provider_control_input
23=%{(1402)}%;data_provider_control_error
24=%{(1403)}%;data_provider_control_output
25=%{(1500)}%;anti_windup_enable
26=%{(1501)}%;anti_windup_max
27=%{(1502)}%;anti_windup_max_status_flag
28=%{(1503)}%;anti_windup_min
29=%{(1504)}%;anti_windup_min_status_flag
30=%{(1505)}%;anti_windup_soft_desat_flag
31=%{(1600)}%;feedback_conditioning_enable
32=%{(1601)}%;feedback_offset_compensation
33=%{(1602)}%;bi_directional_feedback_flag
34=%{(1800)}%;agc_enable
35=%{(1802)}%;agc_enable_switch
36=%{(1803)}%;agc_get_factor_function_call


[add_data_structure_sbsft]
head_comment=%SEPARATOR%; Address offset declarations for data structure addressing
cycles=0
lines=50
comment0=controller object status word at address-offset = 0
comment1=parameter group Ports.Source: pointer to source memory address
comment2=parameter group Ports.Source: bit-shift scaler of normalization factor
comment3=parameter group Ports.Source: Q15 normalization factor
comment4=parameter group Ports.Source: value of source input signal/value offset
comment5=parameter group Ports.AltSource: pointer to alternate source memory address
comment6=parameter group Ports.AltSource: bit-shift scaler of normalization factor
comment7=parameter group Ports.AltSource: Q15 normalization factor
comment8=parameter group Ports.AltSource: value of alternate source input signal/value offset
comment9=parameter group Ports.Target: pointer to target memory address
comment10=parameter group Ports.Target: bit-shift scaler of normalization factor
comment11=parameter group Ports.Target: Q15 normalization factor
comment12=parameter group Ports.Target: value of target output signal/value offset
comment13=parameter group Ports.AltTarget: pointer to alternate target memory address
comment14=parameter group Ports.AltTarget: bit-shift scaler of normalization factor
comment15=parameter group Ports.AltTarget: Q15 normalization factor
comment16=parameter group Ports.AltTarget: value of alternate target output sigal/value offset
comment17=parameter group Ports.ConrolReference: pointer to control reference variable/register memory address
comment18=parameter group Filter: pointer to A-coefficients array start address
comment19=parameter group Filter: pointer to B-coefficients array start address
comment20=parameter group Filter: pointer to control history array start address
comment21=parameter group Filter: pointer to error history array start address
comment22=parameter group Filter: size of the A-coefficients array
comment23=parameter group Filter: size of the B-coefficients array
comment24=parameter group Filter: size of the control history array
comment25=parameter group Filter: size of the error history array
comment26=parameter group Filter: value of input value normalization bit-shift scaler
comment27=parameter group Filter: value of A-term normalization bit-shift scaler
comment28=parameter group Filter: (reserved)
comment29=parameter group Filter: (reserved)
comment30=parameter group Limits: minimum clamping value of primary control output 
comment31=parameter group Limits: maximum clamping value of primary control output 
comment32=parameter group Limits: minimum clamping value of alternate control output 
comment33=parameter group Limits: maximum clamping value of alternate control output 
comment34=parameter group ADCTriggerControl: pointer to ADC trigger A register memory address
comment35=parameter group ADCTriggerControl: value of ADC trigger A offset
comment36=parameter group ADCTriggerControl: pointer to ADC trigger B register memory address
comment37=parameter group ADCTriggerControl: value of ADC trigger B offset
comment38=parameter group DataProviders: pointer to external variable/register the most recent control input will be pushed to
comment39=parameter group DataProviders: pointer to external variable/register the most recent control error will be pushed to
comment40=parameter group DataProviders: pointer to external variable/register the most recent control output will be pushed to
comment41=parameter group CascadeTrigger: pointer to external, cascaded function which will be called by this controller
comment42=parameter group CascadeTrigger: 16-bit wide function parameter or pointer to a parameter data structure of cascaded function
comment43=parameter group GainControl: bit-shift scaler of Adaptive Gain Control Modulation factor
comment44=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation factor
comment45=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation norminal operating point
comment46=parameter group Advanced: generic 16-bit wide, user-defined parameter #1 for advanced control options
comment47=parameter group Advanced: generic 16-bit wide, user-defined parameter #2 for advanced control options
comment48=parameter group Advanced: generic 16-bit wide, user-defined parameter #3 for advanced control options
comment49=parameter group Advanced: generic 16-bit wide, user-defined parameter #4 for advanced control options
code0=.equ Status,                    0
code1=.equ ptrSourceRegister,         2
code2=.equ SourceNormShift,           4
code3=.equ SourceNormFactor,          6
code4=.equ SourceOffset,              8
code5=.equ ptrAltSourceRegister,      10
code6=.equ AltSourceNormShift,        12
code7=.equ AltSourceNormFactor,       14
code8=.equ AltSourceOffset,           16
code9=.equ ptrTargetRegister,         18
code10=.equ TargetNormShift,           20
code11=.equ TargetNormFactor,          22
code12=.equ TargetOffset,              24
code13=.equ ptrAltTargetRegister,      26
code14=.equ AltTargetNormShift,        28
code15=.equ AltTargetNormFactor,       30
code16=.equ AltTargetOffset,           32
code17=.equ ptrCtrlReference,          34
code18=.equ ptrACoefficients,          36
code19=.equ ptrBCoefficients,          38
code20=.equ ptrControlHistory,         40
code21=.equ ptrErrorHistory,           42
code22=.equ ACoeffArraySize,           44
code23=.equ BCoeffArraySize,           46
code24=.equ CtrlHistArraySize,         48
code25=.equ ErrHistArraySize,          50
code26=.equ PreShift,                  52
code27=.equ PostShiftA,                54
code28=.equ reserved_1,                56
code29=.equ reserved_2,                58
code30=.equ MinOutput,                 60
code31=.equ MaxOutput,                 62
code32=.equ AltMinOutput,              64
code33=.equ AltMaxOutput,              66
code34=.equ ptrADCTriggerARegister,    68
code35=.equ ADCTriggerAOffset,         70
code36=.equ ptrADCTriggerBRegister,    72
code37=.equ ADCTriggerBOffset,         74
code38=.equ ptrDProvControlInput,      76
code39=.equ ptrDProvControlError,      78
code40=.equ ptrDProvControlOutput,     80
code41=.equ ptrCascadedFunction,       82
code42=.equ CascadedFunParam,          84
code43=.equ agcGainModScaler,          86
code44=.equ agcGainModFactor,          88
code45=.equ agcGainModMedian,          90
code46=.equ AdvParam1,                 92
code47=.equ AdvParam2,                 94
code48=.equ AdvParam3,                 96
code49=.equ AdvParam4,                 98


[blockset_sbsft_0]
;Instruction blockset for controllers using 16-bit fixed point coefficients scaled with one common single bit-shift scaler
;linear execution of compensation filter
wreg_usage=4,6,8,10,12
accu_usage=a
count=141
0=disclaimer
1=lists
2=section_header
3=add_global_flags
4=add_data_structure_sbsft
5=section_code
6=exec_function_head
7=%{(1100)}%context_save
8=%{(1100)&&(1101)}%context_save_shadow
9=%{(1100)}%context_save_status_word_wreg
10=%{(1200)&&(1203)}%enable_disable_start
11=%{(1100)}%context_save
12=%{(1100)&&(1102)}%context_save_mac_registers
13=%{(1100)&&(1103)&&(1104)}%context_save_accumulator_a
14=%{(1100)&&(1103)&&(1105)}%context_save_accumulator_b
15=%{(1100)&&(1106)}%context_save_core_config
16=%{(1100)&&(1107)}%context_save_core_status
17=%{(1200)&&(1202)}%core_config
18=load_a_coeff_array_ptr
19=load_control_history_array_ptr
20=comp_mac_start_acca_clear_prefetch
21=comp_mac_loop_a_term_acca
22=comp_mac_end_acca
23=load_error_history_array_ptr
24=comp_error_history_update
25=comp_read_input
26=%{(1400)&&(1401)}%shadow_copy_control_input
27=comp_get_error
28=%{(1600)&&(1601)}%comp_zero_input
29=%{(1600)&&(1602)}%comp_invert_input
30=%{(1200)&&(1205)}%comp_norm_error
31=%{(1400)&&(1402)}%shadow_copy_error_input
32=load_b_coeff_array_ptr
33=comp_error_add_most_recent_to_history
34=comp_mac_start_acca_resume
35=comp_mac_loop_b_term_acca
36=comp_mac_end_acca
37=comp_backward_norm_acca
38=comp_mac_store_acca
39=%{(1500)}%anti_windup
40=%{(1500)&&(1501)}%anti_windup_max_start
41=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start
42=%{(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
43=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass
44=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start
45=%{(1500)&&(1501)}%anti_windup_max_override
46=%{(1500)&&(1501)&&(1505)}%anti_windup_soft_desaturation
47=%{(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag
48=%{(1500)&&(1501)}%anti_windup_max_options_end
49=%{(1500)&&(1503)}%anti_windup_min_start
50=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start
51=%{(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
52=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass
53=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start
54=%{(1500)&&(1503)}%anti_windup_min_override
55=%{(1500)&&(1503)&&(1505)}%anti_windup_soft_desaturation
56=%{(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag
57=%{(1500)&&(1503)}%anti_windup_min_options_end
58=comp_writeback
59=%{(1400)&&(1403)}%shadow_copy_control_output
60=%{(1200)&&(1206)}%adc_trigger_a_placement
61=%{(1200)&&(1207)}%adc_trigger_b_placement
62=load_control_history_array_ptr
63=comp_control_history_update
64=comp_control_add_most_recent_to_history
65=update_status_bitfield
66=%{(1100)}%context_restore
67=%{(1100)&&(1102)}%context_restore_mac_registers
68=%{(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
69=%{(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
70=%{(1100)&&(1106)}%context_restore_core_config
71=%{(1100)&&(1107)}%context_restore_core_status
72=%{(1200)&&(1203)&&(!1204)}%enable_disable_end
73=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read
74=%{(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input
75=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end
76=%{(1208)}%cascaded_function_call
77=%{(1100)}%context_restore
78=%{(1100)&&(1101)}%context_restore_shadow
79=%{(1100)}%context_restore_status_word_wreg
80=return
81=reset_function_head
82=clear_control_history_start
83=clear_control_history_loop
84=clear_control_history_end
85=clear_error_history_start
86=clear_error_history_loop
87=clear_error_history_end
88=return
89=charge_function_head
90=charge_error_history_start
91=charge_error_history_loop
92=charge_error_history_end
93=charge_control_history_start
94=charge_control_history_loop
95=charge_control_history_end
96=return
97=%{(1209)}%pterm_function_head
98=%{(1209)&&(1100)}%context_save
99=%{(1209)&&(1100)&&(1101)}%context_save_shadow
100=%{(1209)&&(1100)}%context_save_status_word_wreg
101=%{(1209)&&(1200)&&(1203)}%enable_disable_start_pterm
102=%{(1209)&&(1100)}%context_save
103=%{(1209)&&(1100)&&(1102)}%context_save_mac_registers
104=%{(1209)&&(1100)&&(1103)&&(1104)}%context_save_accumulator_a
105=%{(1209)&&(1100)&&(1103)&&(1105)}%context_save_accumulator_b
106=%{(1209)&&(1100)&&(1106)}%context_save_core_config
107=%{(1209)&&(1100)&&(1107)}%context_save_core_status
108=%{(1209)&&(1200)&&(1202)}%core_config
109=%{(1209)}%comp_read_input
110=%{(1209)&&(1400)&&(1401)}%shadow_copy_control_input
111=%{(1209)}%comp_get_error
112=%{(1209)&&(1600)&&(1601)}%comp_zero_input
113=%{(1209)&&(1600)&&(1602)}%comp_invert_input
114=%{(1209)&&(1200)&&(1205)}%comp_norm_error
115=%{(1209)&&(1400)&&(1402)}%shadow_copy_error_input
116=%{(1209)}%pterm_comp_load_gain_factor
117=%{(1209)}%pterm_comp_exec_pterm
118=%{(1209)&&(1500)}%anti_windup
119=%{(1209)&&(1500)&&(1501)}%anti_windup_max_start
120=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start_pterm
121=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
122=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass_pterm
123=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start_pterm
124=%{(1209)&&(1500)&&(1501)}%anti_windup_max_override
125=%{(1209)&&(1500)&&(1501)&&(1505)}%anti_windup_soft_desaturation
126=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag
127=%{(1209)&&(1500)&&(1501)}%anti_windup_max_options_end_pterm
128=%{(1209)&&(1500)&&(1503)}%anti_windup_min_start
129=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start_pterm
130=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
131=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass_pterm
132=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start_pterm
133=%{(1209)&&(1500)&&(1503)}%anti_windup_min_override
134=%{(1209)&&(1500)&&(1503)&&(1505)}%anti_windup_soft_desaturation
135=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag
136=%{(1209)&&(1500)&&(1503)}%anti_windup_min_options_end_pterm
137=%{(1209)}%comp_writeback
138=%{(1209)&&(1400)&&(1403)}%shadow_copy_control_output
139=%{(1209)&&(1200)&&(1206)}%adc_trigger_a_placement
140=%{(1209)&&(1200)&&(1207)}%adc_trigger_b_placement
141=%{(1209)}%update_status_bitfield
142=%{(1209)&&(1100)}%context_restore
143=%{(1209)&&(1100)&&(1102)}%context_restore_mac_registers
144=%{(1209)&&(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
145=%{(1209)&&(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
146=%{(1209)&&(1100)&&(1106)}%context_restore_core_config
147=%{(1209)&&(1100)&&(1107)}%context_restore_core_status
148=%{(1209)&&(1200)&&(1203)&&(!1204)}%enable_disable_end_pterm
149=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_pterm
150=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input
151=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end_pterm
152=%{(1209)&&(1208)}%cascaded_function_call
153=%{(1209)&&(1100)}%context_restore
154=%{(1209)&&(1100)&&(1101)}%context_restore_shadow
155=%{(1209)&&(1100)}%context_restore_status_word_wreg
156=%{(1209)}%return
157=end


[blockset_sbsft_1]
;Instruction blockset for signle-bitshed 16-bit fixed point controllers
;linear execution of compensation filter (READ - MAC_B0 - CLAMP - WRITE - ATRIG - UPDATE_A - MAC_A - UPDATE_B - MAC_B)
wreg_usage=4,6,8,10,12
accu_usage=a
count=85
0=disclaimer
1=lists
2=section_header
3=add_global_flags
4=add_data_structure_fscl
5=section_code
6=exec_function_head
7=context_save
8=context_save_shadow
9=context_save_status_word_wreg
10=enable_disable_start
11=context_save
12=context_save_mac_registers
13=context_save_accumulator_a
14=context_save_accumulator_b
15=context_save_core_config
16=context_save_core_status
17=core_config
18=comp_read_input
19=shadow_copy_control_input
20=comp_get_error
21=comp_zero_input
22=comp_invert_input
23=comp_norm_error
24=shadow_copy_error_input
25=load_b_coeff_array_ptr
26=load_error_history_array_ptr
27=comp_error_add_most_recent_to_history
28=comp_mac_load32b_a
29=comp_mac_start_acca_resume
30=comp_mac_end_acca
31=comp_backward_norm_acca
32=comp_mac_store_acca
33=anti_windup
34=anti_windup_max
35=anti_windup_min
36=comp_writeback
37=comp_control_add_most_recent_to_history_indirect
38=adc_trigger_a_placement
39=adc_trigger_b_placement
40=shadow_copy_control_output
41=comp_error_history_update
42=load_b_coeff_array_ptr_reverse
43=load_error_history_array_ptr
44=comp_mac_start_acca_reverse_clear
45=comp_mac_loop_b_term_reverse_acca
46=load_a_coeff_array_ptr
47=load_control_history_array_ptr
48=comp_mac_start_acca_resume
49=comp_mac_loop_a_term_acca
50=comp_mac_end_acca
51=comp_control_history_update
52=comp_mac_store32b_a
53=update_status_bitfield
54=cascaded_function_call
55=context_restore
56=context_restore_mac_registers
57=context_restore_accumulator_a
58=context_restore_accumulator_b
59=context_restore_core_config
60=context_restore_core_status
61=enable_disable_end
62=enable_disable_end_dummy_read
63=enable_disable_end_dummy_read_end
64=context_restore
65=context_restore_shadow
66=context_restore_status_word_wreg
67=return
68=reset_function_head
69=clear_control_history_start
70=clear_control_history_loop
71=clear_control_history_end
72=clear_error_history_start
73=clear_error_history_loop
74=clear_error_history_end
75=return
76=charge_function_head
77=charge_error_history_start
78=charge_error_history_loop
79=charge_error_history_end
80=charge_control_history_start
81=charge_control_history_loop
82=charge_control_history_end
83=return
84=end


[add_data_structure_scscl]
head_comment=%SEPARATOR%; Address offset declarations for data structure addressing
cycles=0
lines=50
comment0=controller object status word at address-offset = 0
comment1=parameter group Ports.Source: pointer to source memory address
comment2=parameter group Ports.Source: bit-shift scaler of normalization factor
comment3=parameter group Ports.Source: Q15 normalization factor
comment4=parameter group Ports.Source: value of source input signal/value offset
comment5=parameter group Ports.AltSource: pointer to alternate source memory address
comment6=parameter group Ports.AltSource: bit-shift scaler of normalization factor
comment7=parameter group Ports.AltSource: Q15 normalization factor
comment8=parameter group Ports.AltSource: value of alternate source input signal/value offset
comment9=parameter group Ports.Target: pointer to target memory address
comment10=parameter group Ports.Target: bit-shift scaler of normalization factor
comment11=parameter group Ports.Target: Q15 normalization factor
comment12=parameter group Ports.Target: value of target output signal/value offset
comment13=parameter group Ports.AltTarget: pointer to alternate target memory address
comment14=parameter group Ports.AltTarget: bit-shift scaler of normalization factor
comment15=parameter group Ports.AltTarget: Q15 normalization factor
comment16=parameter group Ports.AltTarget: value of alternate target output sigal/value offset
comment17=parameter group Ports.ConrolReference: pointer to control reference variable/register memory address
comment18=parameter group Filter: pointer to A-coefficients array start address
comment19=parameter group Filter: pointer to B-coefficients array start address
comment20=parameter group Filter: pointer to control history array start address
comment21=parameter group Filter: pointer to error history array start address
comment22=parameter group Filter: size of the A-coefficients array
comment23=parameter group Filter: size of the B-coefficients array
comment24=parameter group Filter: size of the control history array
comment25=parameter group Filter: size of the error history array
comment26=parameter group Filter: value of input value normalization bit-shift scaler
comment27=parameter group Filter: value of A-term normalization bit-shift scaler
comment28=parameter group Filter: (reserved)
comment29=parameter group Filter: control loop output normalization factor
comment30=parameter group Limits: minimum clamping value of primary control output 
comment31=parameter group Limits: maximum clamping value of primary control output 
comment32=parameter group Limits: minimum clamping value of alternate control output 
comment33=parameter group Limits: maximum clamping value of alternate control output 
comment34=parameter group ADCTriggerControl: pointer to ADC trigger A register memory address
comment35=parameter group ADCTriggerControl: value of ADC trigger A offset
comment36=parameter group ADCTriggerControl: pointer to ADC trigger B register memory address
comment37=parameter group ADCTriggerControl: value of ADC trigger B offset
comment38=parameter group DataProviders: pointer to external variable/register the most recent control input will be pushed to
comment39=parameter group DataProviders: pointer to external variable/register the most recent control error will be pushed to
comment40=parameter group DataProviders: pointer to external variable/register the most recent control output will be pushed to
comment41=parameter group CascadeTrigger: pointer to external, cascaded function which will be called by this controller
comment42=parameter group CascadeTrigger: 16-bit wide function parameter or pointer to a parameter data structure of cascaded function
comment43=parameter group GainControl: bit-shift scaler of Adaptive Gain Control Modulation factor
comment44=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation factor
comment45=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation norminal operating point
comment46=parameter group Advanced: generic 16-bit wide, user-defined parameter #1 for advanced control options
comment47=parameter group Advanced: generic 16-bit wide, user-defined parameter #2 for advanced control options
comment48=parameter group Advanced: generic 16-bit wide, user-defined parameter #3 for advanced control options
comment49=parameter group Advanced: generic 16-bit wide, user-defined parameter #4 for advanced control options
code0=.equ Status,                    0
code1=.equ ptrSourceRegister,         2
code2=.equ SourceNormShift,           4
code3=.equ SourceNormFactor,          6
code4=.equ SourceOffset,              8
code5=.equ ptrAltSourceRegister,      10
code6=.equ AltSourceNormShift,        12
code7=.equ AltSourceNormFactor,       14
code8=.equ AltSourceOffset,           16
code9=.equ ptrTargetRegister,         18
code10=.equ TargetNormShift,           20
code11=.equ TargetNormFactor,          22
code12=.equ TargetOffset,              24
code13=.equ ptrAltTargetRegister,      26
code14=.equ AltTargetNormShift,        28
code15=.equ AltTargetNormFactor,       30
code16=.equ AltTargetOffset,           32
code17=.equ ptrCtrlReference,          34
code18=.equ ptrACoefficients,          36
code19=.equ ptrBCoefficients,          38
code20=.equ ptrControlHistory,         40
code21=.equ ptrErrorHistory,           42
code22=.equ ACoeffArraySize,           44
code23=.equ BCoeffArraySize,           46
code24=.equ CtrlHistArraySize,         48
code25=.equ ErrHistArraySize,          50
code26=.equ PreShift,                  52
code27=.equ PostShiftA,                54
code28=.equ reserved_1,                56
code29=.equ PostScaler,                58
code30=.equ MinOutput,                 60
code31=.equ MaxOutput,                 62
code32=.equ AltMinOutput,              64
code33=.equ AltMaxOutput,              66
code34=.equ ptrADCTriggerARegister,    68
code35=.equ ADCTriggerAOffset,         70
code36=.equ ptrADCTriggerBRegister,    72
code37=.equ ADCTriggerBOffset,         74
code38=.equ ptrDProvControlInput,      76
code39=.equ ptrDProvControlError,      78
code40=.equ ptrDProvControlOutput,     80
code41=.equ ptrCascadedFunction,       82
code42=.equ CascadedFunParam,          84
code43=.equ agcGainModScaler,          86
code44=.equ agcGainModFactor,          88
code45=.equ agcGainModMedian,          90
code46=.equ AdvParam1,                 92
code47=.equ AdvParam2,                 94
code48=.equ AdvParam3,                 96
code49=.equ AdvParam4,                 98


[blockset_scscl_0]
;Instruction blockset for output factor modulated, signle-bitshed 16-bit fixed point controllers
;linear execution of compensation filter
wreg_usage=4,6,8,10,12
accu_usage=a
count=126
0=disclaimer
1=lists
2=section_header
3=add_global_flags
4=add_data_structure_scscl
5=section_code
6=exec_function_head
7=context_save
8=context_save_shadow
9=context_save_status_word_wreg
10=enable_disable_start
11=context_save
12=context_save_mac_registers
13=context_save_accumulator_a
14=context_save_accumulator_b
15=context_save_core_config
16=context_save_core_status
17=core_config
18=load_a_coeff_array_ptr
19=load_control_history_array_ptr
20=comp_mac_start_acca_clear_prefetch
21=comp_mac_loop_a_term_acca
22=comp_mac_end_acca
23=load_b_coeff_array_ptr
24=load_error_history_array_ptr
25=comp_read_input
26=shadow_copy_control_input
27=comp_get_error
28=comp_zero_input
29=comp_invert_input
30=comp_norm_error
31=shadow_copy_error_input
32=comp_error_history_update
33=comp_error_add_most_recent_to_history
34=comp_mac_start_acca_resume
35=comp_mac_loop_b_term_acca
36=comp_mac_end_acca
37=comp_backward_norm_acca
38=comp_mac_store_acca
39=comp_backward_norm_coeff_scaler_acca
40=comp_mac_store_acca
41=anti_windup
42=anti_windup_max
43=anti_windup_min
44=comp_writeback
45=shadow_copy_control_output
46=adc_trigger_a_placement
47=adc_trigger_b_placement
48=load_control_history_array_ptr
49=comp_control_history_update
50=comp_control_add_most_recent_to_history
51=update_status_bitfield
52=context_restore
53=context_restore_mac_registers
54=context_restore_accumulator_a
55=context_restore_accumulator_b
56=context_restore_core_config
57=context_restore_core_status
58=enable_disable_end
59=enable_disable_end_dummy_read
60=enable_disable_end_dummy_read_end
61=cascaded_function_call
62=context_restore
63=context_restore_shadow
64=context_restore_status_word_wreg
65=return
66=reset_function_head
67=clear_control_history_start
68=clear_control_history_loop
69=clear_control_history_end
70=clear_error_history_start
71=clear_error_history_loop
72=clear_error_history_end
73=return
74=charge_function_head
75=charge_error_history_start
76=charge_error_history_loop
77=charge_error_history_end
78=charge_control_history_start
79=charge_control_history_loop
80=charge_control_history_end
81=return
82=pterm_function_head
83=context_save
84=context_save_shadow
85=context_save_status_word_wreg
86=enable_disable_start_pterm
87=context_save
88=context_save_mac_registers
89=context_save_accumulator_a
90=context_save_accumulator_b
91=context_save_core_config
92=context_save_core_status
93=core_config
94=comp_read_input
95=shadow_copy_control_input
96=comp_get_error
97=comp_zero_input
98=comp_invert_input
99=comp_norm_error
100=shadow_copy_error_input
101=pterm_comp_load_gain_factor
102=pterm_comp_exec_pterm
103=anti_windup
104=anti_windup_max
105=anti_windup_min
106=comp_writeback
107=shadow_copy_control_output
108=adc_trigger_a_placement
109=adc_trigger_b_placement
110=update_status_bitfield
111=context_restore
112=context_restore_mac_registers
113=context_restore_accumulator_a
114=context_restore_accumulator_b
115=context_restore_core_config
116=context_restore_core_status
117=enable_disable_end_pterm
118=enable_disable_end_dummy_read_pterm
119=enable_disable_end_dummy_read_end_pterm
120=cascaded_function_call
121=context_restore
122=context_restore_shadow
123=context_restore_status_word_wreg
124=return
125=end


[add_data_structure_dbsft]
head_comment=%SEPARATOR%; Address offset declarations for data structure addressing
cycles=0
lines=50
comment0=controller object status word at address-offset = 0
comment1=parameter group Ports.Source: pointer to source memory address
comment2=parameter group Ports.Source: bit-shift scaler of normalization factor
comment3=parameter group Ports.Source: Q15 normalization factor
comment4=parameter group Ports.Source: value of source input signal/value offset
comment5=parameter group Ports.AltSource: pointer to alternate source memory address
comment6=parameter group Ports.AltSource: bit-shift scaler of normalization factor
comment7=parameter group Ports.AltSource: Q15 normalization factor
comment8=parameter group Ports.AltSource: value of alternate source input signal/value offset
comment9=parameter group Ports.Target: pointer to target memory address
comment10=parameter group Ports.Target: bit-shift scaler of normalization factor
comment11=parameter group Ports.Target: Q15 normalization factor
comment12=parameter group Ports.Target: value of target output signal/value offset
comment13=parameter group Ports.AltTarget: pointer to alternate target memory address
comment14=parameter group Ports.AltTarget: bit-shift scaler of normalization factor
comment15=parameter group Ports.AltTarget: Q15 normalization factor
comment16=parameter group Ports.AltTarget: value of alternate target output sigal/value offset
comment17=parameter group Ports.ConrolReference: pointer to control reference variable/register memory address
comment18=parameter group Filter: pointer to A-coefficients array start address
comment19=parameter group Filter: pointer to B-coefficients array start address
comment20=parameter group Filter: pointer to control history array start address
comment21=parameter group Filter: pointer to error history array start address
comment22=parameter group Filter: size of the A-coefficients array
comment23=parameter group Filter: size of the B-coefficients array
comment24=parameter group Filter: size of the control history array
comment25=parameter group Filter: size of the error history array
comment26=parameter group Filter: value of input value normalization bit-shift scaler
comment27=parameter group Filter: value of A-term normalization bit-shift scaler
comment28=parameter group Filter: value of B-term normalization bit-shift scaler
comment29=parameter group Filter: (reserved)
comment30=parameter group Limits: minimum clamping value of primary control output 
comment31=parameter group Limits: maximum clamping value of primary control output 
comment32=parameter group Limits: minimum clamping value of alternate control output 
comment33=parameter group Limits: maximum clamping value of alternate control output 
comment34=parameter group ADCTriggerControl: pointer to ADC trigger A register memory address
comment35=parameter group ADCTriggerControl: value of ADC trigger A offset
comment36=parameter group ADCTriggerControl: pointer to ADC trigger B register memory address
comment37=parameter group ADCTriggerControl: value of ADC trigger B offset
comment38=parameter group DataProviders: pointer to external variable/register the most recent control input will be pushed to
comment39=parameter group DataProviders: pointer to external variable/register the most recent control error will be pushed to
comment40=parameter group DataProviders: pointer to external variable/register the most recent control output will be pushed to
comment41=parameter group CascadeTrigger: pointer to external, cascaded function which will be called by this controller
comment42=parameter group CascadeTrigger: 16-bit wide function parameter or pointer to a parameter data structure of cascaded function
comment43=parameter group GainControl: bit-shift scaler of Adaptive Gain Control Modulation factor
comment44=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation factor
comment45=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation norminal operating point
comment46=parameter group Advanced: generic 16-bit wide, user-defined parameter #1 for advanced control options
comment47=parameter group Advanced: generic 16-bit wide, user-defined parameter #2 for advanced control options
comment48=parameter group Advanced: generic 16-bit wide, user-defined parameter #3 for advanced control options
comment49=parameter group Advanced: generic 16-bit wide, user-defined parameter #4 for advanced control options
code0=.equ Status,                    0
code1=.equ ptrSourceRegister,         2
code2=.equ SourceNormShift,           4
code3=.equ SourceNormFactor,          6
code4=.equ SourceOffset,              8
code5=.equ ptrAltSourceRegister,      10
code6=.equ AltSourceNormShift,        12
code7=.equ AltSourceNormFactor,       14
code8=.equ AltSourceOffset,           16
code9=.equ ptrTargetRegister,         18
code10=.equ TargetNormShift,           20
code11=.equ TargetNormFactor,          22
code12=.equ TargetOffset,              24
code13=.equ ptrAltTargetRegister,      26
code14=.equ AltTargetNormShift,        28
code15=.equ AltTargetNormFactor,       30
code16=.equ AltTargetOffset,           32
code17=.equ ptrCtrlReference,          34
code18=.equ ptrACoefficients,          36
code19=.equ ptrBCoefficients,          38
code20=.equ ptrControlHistory,         40
code21=.equ ptrErrorHistory,           42
code22=.equ ACoeffArraySize,           44
code23=.equ BCoeffArraySize,           46
code24=.equ CtrlHistArraySize,         48
code25=.equ ErrHistArraySize,          50
code26=.equ PreShift,                  52
code27=.equ PostShiftA,                54
code28=.equ PostShiftB,                56
code29=.equ reserved_2,                58
code30=.equ MinOutput,                 60
code31=.equ MaxOutput,                 62
code32=.equ AltMinOutput,              64
code33=.equ AltMaxOutput,              66
code34=.equ ptrADCTriggerARegister,    68
code35=.equ ADCTriggerAOffset,         70
code36=.equ ptrADCTriggerBRegister,    72
code37=.equ ADCTriggerBOffset,         74
code38=.equ ptrDProvControlInput,      76
code39=.equ ptrDProvControlError,      78
code40=.equ ptrDProvControlOutput,     80
code41=.equ ptrCascadedFunction,       82
code42=.equ CascadedFunParam,          84
code43=.equ agcGainModScaler,          86
code44=.equ agcGainModFactor,          88
code45=.equ agcGainModMedian,          90
code46=.equ AdvParam1,                 92
code47=.equ AdvParam2,                 94
code48=.equ AdvParam3,                 96
code49=.equ AdvParam4,                 98


[blockset_dbsft_0]
;Instruction blockset for double-bitshed 16-bit fixed point controllers
;linear execution of compensation filter
wreg_usage=4,6,8,10,12
accu_usage=ab
count=131
0=disclaimer
1=lists
2=section_header
3=add_global_flags
4=add_data_structure_dbsft
5=section_code
6=exec_function_head
7=context_save
8=context_save_shadow
9=context_save_status_word_wreg
10=enable_disable_start
11=context_save
12=context_save_mac_registers
13=context_save_accumulator_a
14=context_save_accumulator_b
15=context_save_core_config
16=context_save_core_status
17=core_config
18=load_a_coeff_array_ptr
19=load_control_history_array_ptr
20=comp_mac_start_acca_clear_prefetch
21=comp_mac_loop_a_term_acca
22=comp_mac_end_acca
23=comp_backward_norm_acca
24=comp_read_input
25=shadow_copy_control_input
26=comp_get_error
27=comp_zero_input
28=comp_invert_input
29=comp_norm_error
30=shadow_copy_error_input
31=load_b_coeff_array_ptr
32=load_error_history_array_ptr
33=comp_error_history_update
34=comp_error_add_most_recent_to_history
35=comp_mac_start_accb_clear_prefetch
36=comp_mac_loop_b_term_accb
37=comp_mac_end_accb
38=agc_factor_multiply_start
39=agc_factor_multiply_enable_start
40=agc_factor_multiply_get_factor_call
41=agc_factor_multiply_scaled
42=agc_factor_multiply_enable_end
43=comp_backward_norm_accb
44=comp_add_accb_to_acca
45=comp_mac_store_acca
46=anti_windup
47=anti_windup_max
48=anti_windup_min
49=comp_writeback
50=shadow_copy_control_output
51=adc_trigger_a_placement
52=adc_trigger_b_placement
53=load_control_history_array_ptr
54=comp_control_history_update
55=comp_control_add_most_recent_to_history
56=update_status_bitfield
57=context_restore
58=context_restore_mac_registers
59=context_restore_accumulator_a
60=context_restore_accumulator_b
61=context_restore_core_config
62=context_restore_core_status
63=enable_disable_end
64=enable_disable_end_dummy_read
65=enable_disable_end_dummy_read_end
66=cascaded_function_call
67=context_restore
68=context_restore_shadow
69=context_restore_status_word_wreg
70=return
71=reset_function_head
72=clear_control_history_start
73=clear_control_history_loop
74=clear_control_history_end
75=clear_error_history_start
76=clear_error_history_loop
77=clear_error_history_end
78=return
79=charge_function_head
80=charge_error_history_start
81=charge_error_history_loop
82=charge_error_history_end
83=charge_control_history_start
84=charge_control_history_loop
85=charge_control_history_end
86=return
80=pterm_function_head
81=context_save
82=context_save_shadow
83=context_save_status_word_wreg
84=enable_disable_start_pterm
85=context_save
86=context_save_mac_registers
87=context_save_accumulator_a
88=context_save_accumulator_b
89=context_save_core_config
90=context_save_core_status
91=core_config
92=comp_read_input
93=shadow_copy_control_input
94=comp_get_error
95=comp_zero_input
96=comp_invert_input
97=comp_norm_error
98=shadow_copy_error_input
99=pterm_comp_load_gain_factor
100=pterm_comp_exec_pterm
101=anti_windup
102=anti_windup_max
103=anti_windup_min
104=comp_writeback
105=shadow_copy_control_output
106=adc_trigger_a_placement
107=adc_trigger_b_placement
108=update_status_bitfield
109=context_restore
110=context_restore_mac_registers
111=context_restore_accumulator_a
112=context_restore_accumulator_b
113=context_restore_core_config
114=context_restore_core_status
115=enable_disable_end_pterm
116=enable_disable_end_dummy_read_pterm
117=enable_disable_end_dummy_read_end_pterm
118=cascaded_function_call
119=context_restore
120=context_restore_shadow
121=context_restore_status_word_wreg
122=return
87=end


[add_data_structure_fscl]
head_comment=%SEPARATOR%; Address offset declarations for data structure addressing
cycles=0
lines=50
comment0=controller object status word at address-offset = 0
comment1=parameter group Ports.Source: pointer to source memory address
comment2=parameter group Ports.Source: bit-shift scaler of normalization factor
comment3=parameter group Ports.Source: Q15 normalization factor
comment4=parameter group Ports.Source: value of source input signal/value offset
comment5=parameter group Ports.AltSource: pointer to alternate source memory address
comment6=parameter group Ports.AltSource: bit-shift scaler of normalization factor
comment7=parameter group Ports.AltSource: Q15 normalization factor
comment8=parameter group Ports.AltSource: value of alternate source input signal/value offset
comment9=parameter group Ports.Target: pointer to target memory address
comment10=parameter group Ports.Target: bit-shift scaler of normalization factor
comment11=parameter group Ports.Target: Q15 normalization factor
comment12=parameter group Ports.Target: value of target output signal/value offset
comment13=parameter group Ports.AltTarget: pointer to alternate target memory address
comment14=parameter group Ports.AltTarget: bit-shift scaler of normalization factor
comment15=parameter group Ports.AltTarget: Q15 normalization factor
comment16=parameter group Ports.AltTarget: value of alternate target output sigal/value offset
comment17=parameter group Ports.ConrolReference: pointer to control reference variable/register memory address
comment18=parameter group Filter: pointer to A-coefficients array start address
comment19=parameter group Filter: pointer to B-coefficients array start address
comment20=parameter group Filter: pointer to control history array start address
comment21=parameter group Filter: pointer to error history array start address
comment22=parameter group Filter: size of the A-coefficients array
comment23=parameter group Filter: size of the B-coefficients array
comment24=parameter group Filter: size of the control history array
comment25=parameter group Filter: size of the error history array
comment26=parameter group Filter: value of input value normalization bit-shift scaler
comment27=parameter group Filter: (reserved)
comment28=parameter group Filter: (reserved)
comment29=parameter group Filter: (reserved)
comment30=parameter group Limits: minimum clamping value of primary control output 
comment31=parameter group Limits: maximum clamping value of primary control output 
comment32=parameter group Limits: minimum clamping value of alternate control output 
comment33=parameter group Limits: maximum clamping value of alternate control output 
comment34=parameter group ADCTriggerControl: pointer to ADC trigger A register memory address
comment35=parameter group ADCTriggerControl: value of ADC trigger A offset
comment36=parameter group ADCTriggerControl: pointer to ADC trigger B register memory address
comment37=parameter group ADCTriggerControl: value of ADC trigger B offset
comment38=parameter group DataProviders: pointer to external variable/register the most recent control input will be pushed to
comment39=parameter group DataProviders: pointer to external variable/register the most recent control error will be pushed to
comment40=parameter group DataProviders: pointer to external variable/register the most recent control output will be pushed to
comment41=parameter group CascadeTrigger: pointer to external, cascaded function which will be called by this controller
comment42=parameter group CascadeTrigger: 16-bit wide function parameter or pointer to a parameter data structure of cascaded function
comment43=parameter group GainControl: bit-shift scaler of Adaptive Gain Control Modulation factor
comment44=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation factor
comment45=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation norminal operating point
comment46=parameter group Advanced: generic 16-bit wide, user-defined parameter #1 for advanced control options
comment47=parameter group Advanced: generic 16-bit wide, user-defined parameter #2 for advanced control options
comment48=parameter group Advanced: generic 16-bit wide, user-defined parameter #3 for advanced control options
comment49=parameter group Advanced: generic 16-bit wide, user-defined parameter #4 for advanced control options
code0=.equ Status,                    0
code1=.equ ptrSourceRegister,         2
code2=.equ SourceNormShift,           4
code3=.equ SourceNormFactor,          6
code4=.equ SourceOffset,              8
code5=.equ ptrAltSourceRegister,      10
code6=.equ AltSourceNormShift,        12
code7=.equ AltSourceNormFactor,       14
code8=.equ AltSourceOffset,           16
code9=.equ ptrTargetRegister,         18
code10=.equ TargetNormShift,           20
code11=.equ TargetNormFactor,          22
code12=.equ TargetOffset,              24
code13=.equ ptrAltTargetRegister,      26
code14=.equ AltTargetNormShift,        28
code15=.equ AltTargetNormFactor,       30
code16=.equ AltTargetOffset,           32
code17=.equ ptrCtrlReference,          34
code18=.equ ptrACoefficients,          36
code19=.equ ptrBCoefficients,          38
code20=.equ ptrControlHistory,         40
code21=.equ ptrErrorHistory,           42
code22=.equ ACoeffArraySize,           44
code23=.equ BCoeffArraySize,           46
code24=.equ CtrlHistArraySize,         48
code25=.equ ErrHistArraySize,          50
code26=.equ PreShift,                  52
code27=.equ reserved_0,                54
code28=.equ reserved_1,                56
code29=.equ reserved_2,                58
code30=.equ MinOutput,                 60
code31=.equ MaxOutput,                 62
code32=.equ AltMinOutput,              64
code33=.equ AltMaxOutput,              66
code34=.equ ptrADCTriggerARegister,    68
code35=.equ ADCTriggerAOffset,         70
code36=.equ ptrADCTriggerBRegister,    72
code37=.equ ADCTriggerBOffset,         74
code38=.equ ptrDProvControlInput,      76
code39=.equ ptrDProvControlError,      78
code40=.equ ptrDProvControlOutput,     80
code41=.equ ptrCascadedFunction,       82
code42=.equ CascadedFunParam,          84
code43=.equ agcGainModScaler,          86
code44=.equ agcGainModFactor,          88
code45=.equ agcGainModMedian,          90
code46=.equ AdvParam1,                 92
code47=.equ AdvParam2,                 94
code48=.equ AdvParam3,                 96
code49=.equ AdvParam4,                 98


[blockset_fscl_0]
;Instruction blockset for double-bitshed 16-bit fixed point controllers
;linear execution of compensation filter
wreg_usage=4,5,6,8,10,12
accu_usage=ab
count=125
0=disclaimer
1=lists
2=section_header
3=add_global_flags
4=add_data_structure_fscl
5=section_code
6=exec_function_head
7=context_save
8=context_save_shadow
9=context_save_status_word_wreg
10=enable_disable_start
11=context_save
12=fscl_context_save_mac_registers
13=context_save_accumulator_a
14=context_save_accumulator_b
15=context_save_core_config
16=context_save_core_status
17=core_config
18=load_a_coeff_array_ptr
19=load_control_history_array_ptr
20=fscl_comp_mac_start_clear
21=fscl_comp_mac_first
22=fscl_comp_mac_a_loop
23=fscl_comp_mac_end
24=comp_read_input
25=shadow_copy_control_input
26=comp_get_error
27=comp_zero_input
28=comp_invert_input
29=comp_norm_error
30=shadow_copy_error_input
31=load_b_coeff_array_ptr
32=load_error_history_array_ptr
33=comp_error_history_update
34=comp_error_add_most_recent_to_history
35=fscl_comp_mac_start_resume
36=fscl_comp_mac_first
37=fscl_comp_mac_b_loop
38=fscl_comp_mac_end
39=comp_mac_store_accb
40=anti_windup
41=anti_windup_max
42=anti_windup_min
43=comp_writeback
44=shadow_copy_control_output
45=adc_trigger_a_placement
46=adc_trigger_b_placement
47=load_control_history_array_ptr
48=comp_control_history_update
49=comp_control_add_most_recent_to_history
50=update_status_bitfield
51=context_restore
52=fscl_context_restore_mac_registers
53=context_restore_accumulator_a
54=context_restore_accumulator_b
55=context_restore_core_config
56=context_restore_core_status
57=enable_disable_end
58=enable_disable_end_dummy_read
59=enable_disable_end_dummy_read_end
60=cascaded_function_call
61=context_restore
62=context_restore_shadow
63=context_restore_status_word_wreg
64=return
65=reset_function_head
66=clear_control_history_start
67=clear_control_history_loop
68=clear_control_history_end
69=clear_error_history_start
70=clear_error_history_loop
71=clear_error_history_end
72=return
73=charge_function_head
74=charge_error_history_start
75=charge_error_history_loop
76=charge_error_history_end
77=charge_control_history_start
78=charge_control_history_loop
79=charge_control_history_end
80=return
81=pterm_function_head
82=context_save
83=context_save_shadow
84=context_save_status_word_wreg
85=enable_disable_start_pterm
86=context_save
87=context_save_mac_registers
88=context_save_accumulator_a
89=context_save_accumulator_b
90=context_save_core_config
91=context_save_core_status
92=core_config
93=comp_read_input
94=shadow_copy_control_input
95=comp_get_error
96=comp_zero_input
97=comp_invert_input
98=comp_norm_error
99=shadow_copy_error_input
100=pterm_comp_load_gain_factor
101=pterm_comp_exec_pterm
102=anti_windup
103=anti_windup_max
104=anti_windup_min
105=comp_writeback
106=shadow_copy_control_output
107=adc_trigger_a_placement
108=adc_trigger_b_placement
109=update_status_bitfield
110=context_restore
111=context_restore_mac_registers
112=context_restore_accumulator_a
113=context_restore_accumulator_b
114=context_restore_core_config
115=context_restore_core_status
116=enable_disable_end_pterm
117=enable_disable_end_dummy_read_pterm
118=enable_disable_end_dummy_read_end_pterm
119=cascaded_function_call
120=context_restore
121=context_restore_shadow
122=context_restore_status_word_wreg
123=return
124=end


[disclaimer]
;head_comment=;LICENSE / DISCLAIMER ************************************************************\n;  Microchip Technology Inc. and its subsidiaries.  You may use this software \n;  and any derivatives exclusively with Microchip products. \n;  \n;  THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER \n;  EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED \n;  WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A \n;  PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION \n;  WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION. \n;  \n;  IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, \n;  INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND \n;  WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS \n;  BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.  TO THE \n;  FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS \n;  IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF \n;  ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE. \n;  \n;  MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE \n;  TERMS. \n; **********************************************************************************
head_comment=;LICENSE / DISCLAIMER
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%

[lists]
head_comment=%SEPARATOR%;file start
cycles=0
lines=2
comment0=%EMPTY%
code0=.nolist
code1=.list

[section_header]
head_comment=%SEPARATOR%;local inclusions.
cycles=0
lines=1
comment0=place constant data in the data section
code0=.section .data

[section_code]
head_comment=%SEPARATOR%;local inclusions.
cycles=0
lines=1
comment0=place code in the code section
;code0=;.section .libdsp, code
code0=.section .text

[add_global_flags]
head_comment=%SEPARATOR%; Define status flags bit positions
cycles=0
lines=7
comment0=bit position of the ENABLE control bit
comment1=bit position of the INVERT_INPUT control bit
comment2=bit position of the SWAP_SOURCE control bit
comment3=bit position of the SWAP_TARGET control bit
comment4=bit position of the AGC_ENABLED control bit
comment5=bit position of the UPPER_SATURATION_FLAG status bit
comment6=bit position of the LOWER_SATURATION_FLAG status bit
code0=.equ NPNZ16_STATUS_ENABLED,      15
code1=.equ NPNZ16_STATUS_INVERT_INPUT, 14
code2=.equ NPNZ16_STATUS_SWAP_SOURCE,  13
code3=.equ NPNZ16_STATUS_SWAP_TARGET,  12
code4=.equ NPNZ16_STATUS_AGC_ENABLED,  11
code5=.equ NPNZ16_STATUS_USAT,         1
code6=.equ NPNZ16_STATUS_LSAT,         0

[exec_function_head]
head_comment=%SEPARATOR%; Global function declaration\n; This function calls the z-domain controller processing the latest data point input%SEPARATOR%
cycles=0
lines=2
comment0=%EMPTY%
comment1=provide global scope to routine
comment2=start of routine
code0=.global %PREFIXG%_Update
code1=%PREFIXG%_Update:\n

[reset_function_head]
head_comment=%SEPARATOR%; Global function declaration %PREFIXG%_Reset\n; This function clears control and error histories enforcing a reset%SEPARATOR%
cycles=0
lines=2
comment0=%EMPTY%
comment1=%EMPTY%
code0=.global %PREFIXG%_Reset
code1=%PREFIXG%_Reset:

[charge_function_head]
head_comment=%SEPARATOR%; Global function declaration %PREFIXG%_Precharge\n; This function loads user-defined default values into control and error histories%SEPARATOR%
cycles=0
lines=2
comment0=%EMPTY%
comment1=%EMPTY%
code0=.global %PREFIXG%_Precharge
code1=%PREFIXG%_Precharge:

[pterm_function_head]
head_comment=%SEPARATOR%; Global function declaration %PREFIXG%_PTermUpdate\n; This function executes a P-term based control loop used for plant measurements only.\n; THIS LOOP IS NOT SUITED FOR STABLE OPERATION%SEPARATOR%
cycles=0
lines=2
comment0=%EMPTY%
comment1=%EMPTY%
code0=.global %PREFIXG%_PTermUpdate
code1=%PREFIXG%_PTermUpdate:

[clear_control_history_start]
head_comment=%SEPARATOR%; Clear control history array
cycles=0
lines=2
comment0=save contents of working register WREG0
comment1=set pointer to the base address of control history array
code0=push w0
code1=mov  [w0 + #ptrControlHistory], w0

[clear_control_history_loop]
filter_order_loop=a
head_comment=%EMPTY%
cycles=0
lines=1
comment0=clear next address of control history array
code0=clr [w0++]

[clear_control_history_end]
head_comment=%EMPTY%
cycles=0
lines=2
comment0=clear last address of control history array
comment1=restore contents of working register WREG0
code0=clr [w0]
code1=pop w0

[clear_error_history_start]
head_comment=%SEPARATOR%; Clear error history array
cycles=0
lines=2
comment0=save contents of working register WREG0
comment1=set pointer to the base address of error history array
code0=push w0
code1=mov [w0 + #ptrErrorHistory], w0

[clear_error_history_loop]
filter_order_loop=b
head_comment=%EMPTY%
cycles=0
lines=1
comment0=Clear next address of error history array
code0=clr [w0++]

[clear_error_history_end]
head_comment=%EMPTY%
cycles=0
lines=2
comment0=clear last address of error history array
comment1=restore contents of working register WREG0
code0=clr [w0]
code1=pop w0

[charge_control_history_start]
head_comment=%SEPARATOR%; Charge control history array with defined value
cycles=0
lines=3
comment0=save contents of working register WREG0
comment1=save contents of working register WREG2
comment2=set pointer to the base address of control history array
code0=push w0
code1=push w2
code2=mov  [w0 + #ptrControlHistory], w0

[charge_control_history_loop]
filter_order_loop=a
head_comment=%EMPTY%
cycles=0
lines=1
comment0=Load user value into next address of control history array
code0=mov w2, [w0++]

[charge_control_history_end]
head_comment=%EMPTY%
cycles=0
lines=3
comment0=Load user value into last address of control history array
comment1=restore contents of working register WREG2
comment2=restore contents of working register WREG0
code0=mov w2, [w0]
code1=pop w2
code2=pop w0

[charge_error_history_start]
head_comment=%SEPARATOR%; Charge error history array with defined value
cycles=0
lines=3
comment0=save contents of working register WREG0
comment1=save contents of working register WREG1
comment2=set pointer to the base address of error history array
code0=push w0
code1=push w1
code2=mov  [w0 + #ptrErrorHistory], w0

[charge_error_history_loop]
filter_order_loop=b
head_comment=%EMPTY%
cycles=0
lines=1
comment0=Load user value into next address of error history array
code0=mov w1, [w0++]

[charge_error_history_end]
head_comment=%EMPTY%
cycles=0
lines=3
comment0=load user value into last address of error history array
comment1=restore contents of working register WREG1
comment2=restore contents of working register WREG0
code0=mov w1, [w0]
code1=pop w1
code2=pop w0

[context_save]
head_comment=%SEPARATOR%; Save working registers
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%		

[context_restore]
head_comment=%SEPARATOR%; Restore working registers
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%		

[context_save_shadow]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=save shadowed working registers (w0...w3)
code0=push.s		

[context_save_mac_registers]
item_loop=wreg_usage
head_comment=%EMPTY%
cycles=4
lines=4
comment0=save working registers used for MAC operations (w4, w6, w8, w10)
code0=push w4
code1=push w6
code2=push w8
code3=push w10

[context_save_status_word_wreg]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=save working register used for status flag tracking
code0=push w12

[context_save_accumulator_a]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=save accumulator A registers
code0=push ACCAL
code1=push ACCAH
code2=push ACCAU

[context_save_accumulator_b]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=save accumulator B registers
code0=push ACCBL
code1=push ACCBH
code2=push ACCBU

[context_save_core_config]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=save CPU configuration register
code0=push CORCON

[context_save_core_status]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=save CPU status register
code0=push SR

[context_restore_shadow]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=restore shadowed working registers (w0...w3)
code0=pop.s		

[context_restore_mac_registers]
head_comment=%EMPTY%
cycles=4
lines=4
comment0=restore working registers used for MAC operations w4, w6, w8, w10)
code0=pop w4
code1=pop w6
code2=pop w8
code3=pop w10

[context_restore_status_word_wreg]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=restore working register used for status flag tracking
code0=pop w12

[context_restore_accumulator_a]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=restore accumulator A registers
code0=pop ACCAL
code1=pop ACCAH
code2=pop ACCAU

[context_restore_accumulator_b]
head_comment=%EMPTY%
cycles=3
lines=3
comment=restore accumulator B registers
code0=pop ACCBL
code1=pop ACCBH
code2=pop ACCBU

[context_restore_core_config]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=restore CPU configuration registers
code0=pop CORCON

[context_restore_core_status]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=restore CPU status registers
code0=pop SR

[enable_disable_start]
declaration=.equ NPNZ16_STATUS_ENABLED, 15
data_structure=.equ	Status, 0
head_comment=%SEPARATOR%; Check status word for Enable/Disable flag and bypass computation, if disabled
cycles=4
lines=3
comment0=load value of status word into working register
comment1=check ENABLED bit state, skip (do not execute) next instruction if set
comment2=if ENABLED bit is cleared, jump to end of control code
code0=mov [w0 + #Status], w12
code1=btss w12, #NPNZ16_STATUS_ENABLED
code2=bra %PREFIXU%_LOOP_BYPASS

[enable_disable_start_pterm]
declaration=.equ NPNZ16_STATUS_ENABLED, 15
data_structure=.equ	Status, 0
head_comment=%SEPARATOR%; Check status word for Enable/Disable flag and bypass computation when disabled
cycles=4
lines=3
comment0=load value of status word into working register
comment1=check ENABLED bit state, skip (do not execute) next instruction if set
comment2=if ENABLED bit is cleared, jump to end of control code
code0=mov [w0 + #Status], w12
code1=btss w12, #NPNZ16_STATUS_ENABLED
code2=bra %PREFIXU%_PTERM_LOOP_BYPASS

[enable_disable_end_dummy_read]
head_comment=%SEPARATOR%; Enable/Disable bypass branch target with dummy read of source buffer
cycles=2
lines=4
comment0=when enabled, step over dummy read and go straight to EXIT
comment1=Enable/Disable bypass branch target to perform dummy read of source to clear the source buffer
comment2=load pointer to input source register
comment3=move value from input source into working register
code0=goto %PREFIXU%_LOOP_EXIT
code1=%PREFIXU%_LOOP_BYPASS:
code2=mov [w0 + #ptrSourceRegister], w2
code3=mov [w2], w1 

[enable_disable_end_dummy_read_pterm]
head_comment=%SEPARATOR%; Enable/Disable bypass branch target with dummy read of source buffer
cycles=2
lines=4
comment0=when enabled, step over dummy read and go straight to EXIT
comment1=Enable/Disable bypass branch target to perform dummy read of source to clear the source buffer
comment2=load pointer to input source register
comment3=move value from input source into working register
code0=goto %PREFIXU%_PTERM_LOOP_EXIT
code1=%PREFIXU%_PTERM_LOOP_BYPASS:
code2=mov [w0 + #ptrSourceRegister], w2
code3=mov [w2], w1 

[enable_disable_end_dummy_read_end]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=Exit control loop branch target 
code0=%PREFIXU%_LOOP_EXIT:

[enable_disable_end_dummy_read_end_pterm]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=Exit P-Term control loop branch target 
code0=%PREFIXU%_PTERM_LOOP_EXIT:

[enable_disable_end]
head_comment=%SEPARATOR%; Enable/Disable bypass branch target
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_LOOP_BYPASS:

[enable_disable_end_pterm]
head_comment=%SEPARATOR%; Enable/Disable bypass branch target
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_PTERM_LOOP_BYPASS:

[core_config]
head_comment=%SEPARATOR%; Configure DSP for fractional operation with normal saturation (Q1.31 format)
cycles=2
lines=2
comment0=load default value of DSP core configuration enabling saturation and signed fractional multiply
comment1=load default configuration into CORCON register
code0=mov #0x00E4, w4
code1=mov w4, _CORCON

[cascaded_function_call]
head_comment=%SEPARATOR%; Call next function of cascade
cycles=3
lines=3
comment0=load functoin pointer
comment1=load single parameter or pointer to parameter data structure
comment2=call function
code0=mov [w0 + #ptrCascadedFunction], w1
code1=mov [w0 + #CascadedFunParam], w0
code2=call w1

[update_status_bitfield]
head_comment=%SEPARATOR%; Update status flag bitfield
cycles=1
lines=1
comment0=update value of the status word in data structure
code0=mov w12, [w0 + #Status]

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[anti_windup]
head_comment=%SEPARATOR%; Controller Anti-Windup (control output value clamping)
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%

[anti_windup_soft_desaturation]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load address of most recent item in error history
comment1=set most recent error to zero
code0=mov [w0 + #ptrErrorHistory], w6
code1=clr [w6]

[anti_windup_max_start]
head_comment=\n; Check for upper limit violation
cycles=3
lines=2
comment0=load upper limit value
comment1=compare values and skip next instruction if control output is within operating range (control output < upper limit)
code0=mov [w0 + #MaxOutput], w6
code1=cpslt w4, w6

[anti_windup_max_options_start]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=jump to override label if control output > upper limit
code0=bra %PREFIXU%_CLAMP_MAX_OVERRIDE

[anti_windup_max_options_start_pterm]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=jump to override label if control output > upper limit
code0=bra %PREFIXU%_PTERM_CLAMP_MAX_OVERRIDE

[anti_windup_max_options_override_bypass]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=jump to exit
code0=bra %PREFIXU%_CLAMP_MAX_EXIT

[anti_windup_max_options_override_bypass_pterm]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=jump to exit
code0=bra %PREFIXU%_PTERM_CLAMP_MAX_EXIT

[anti_windup_max_options_override_start]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_CLAMP_MAX_OVERRIDE:

[anti_windup_max_options_override_start_pterm]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_PTERM_CLAMP_MAX_OVERRIDE:

[anti_windup_max_set_status_flag]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=set upper limit saturation flag bit
code0=bset w12, #NPNZ16_STATUS_USAT

[anti_windup_max_clear_status_flag]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=clear upper limit saturation flag bit
code0=bclr w12, #NPNZ16_STATUS_USAT

[anti_windup_max_override]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=override controller output
code0=mov w6, w4

[anti_windup_max_options_end]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_CLAMP_MAX_EXIT:

[anti_windup_max_options_end_pterm]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_PTERM_CLAMP_MAX_EXIT:

[anti_windup_min_start]
head_comment=\n; Check for lower limit violation
cycles=3
lines=2
comment0=load lower limit value
comment1=compare values and skip next instruction if control output is within operating range (control output > lower limit)
code0=mov [w0 + #MinOutput], w6
code1=cpsgt w4, w6

[anti_windup_min_options_start]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=jump to override label if control output < lower limit
code0=bra %PREFIXU%_CLAMP_MIN_OVERRIDE

[anti_windup_min_options_start_pterm]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=jump to override label if control output < lower limit
code0=bra %PREFIXU%_PTERM_CLAMP_MIN_OVERRIDE

[anti_windup_min_options_override_bypass]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=jump to exit
code0=bra %PREFIXU%_CLAMP_MIN_EXIT

[anti_windup_min_options_override_bypass_pterm]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=jump to exit
code0=bra %PREFIXU%_PTERM_CLAMP_MIN_EXIT

[anti_windup_min_options_override_start]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_CLAMP_MIN_OVERRIDE:

[anti_windup_min_options_override_start_pterm]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_PTERM_CLAMP_MIN_OVERRIDE:

[anti_windup_min_set_status_flag]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=set lower limit saturation flag bit
code0=bset w12, #NPNZ16_STATUS_LSAT

[anti_windup_min_clear_status_flag]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=clear lower limit saturation flag bit
code0=bclr w12, #NPNZ16_STATUS_LSAT

[anti_windup_min_override]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=override controller output
code0=mov w6, w4

[anti_windup_min_options_end]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_CLAMP_MIN_EXIT:

[anti_windup_min_options_end_pterm]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_PTERM_CLAMP_MIN_EXIT:

[comp_read_input]
head_comment=%SEPARATOR%; Read data from input source and calculate error input to transfer function
cycles=2
lines=2
comment0=load pointer to input source register
comment1=move value from input source into working register
code0=mov [w0 + #ptrSourceRegister], w2
code1=mov [w2], w1

[comp_read_input_with_alt_source_switch]
head_comment=%SEPARATOR%; Read data from primary or alternate input source and calculate error input to transfer function
cycles=4
lines=4
comment0=load pointer to alternate input source register
comment1=test SWAP_SOURCE status bit in status word and skip following instruction if cleared
comment2=load pointer to primary input source register
comment3=move value from primary or alternate input source into working register
code0=mov [w0 + #ptrSourceRegister], w2
code1=btsc w12, #NPNZ16_STATUS_SWAP_SOURCE
code2=mov [w0 + #ptrAltSourceRegister], w2
code3=mov [w2], w1

[comp_zero_input]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load input offset value into working register
comment1=add offset to error value
code0=mov [w0 + #SourceOffset], w2
code1=add w1, w2, w1

[comp_invert_input]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=Test control bit if value should be inverted
comment1=invert value
code0=btsc w12, #NPNZ16_STATUS_INVERT_INPUT
code1=neg w1, w1

[shadow_copy_control_input]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load pointer address of target buffer of most recent controller input from data structure
comment1=copy most recent controller input value to given data buffer target
code0=mov [w0 + #ptrDProvControlInput], w2
code1=mov w1, [w2]

[comp_get_error]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=move pointer to control reference into working register
comment1=calculate error (=reference - input)
code0=mov [w0 + #ptrCtrlReference], w2
code1=subr w1, [w2], w1

[comp_norm_error]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=move error input scaler into working register
comment1=normalize error result to fractional number format
code0=mov [w0 + #PreShift], w2
code1=sl w1, w2, w1

[shadow_copy_error_input]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load pointer address of target buffer of most recent error value from data structure
comment1=copy most recent error value to given data buffer target
code0=mov [w0 + #ptrDProvControlError], w2
code1=mov w1, [w2]

[shadow_copy_control_output]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load pointer address of target buffer of most recent controller output value from data structure
comment1=copy most recent controller output value to given data buffer target
code0=mov [w0 + #ptrDProvControlOutput], w2
code1=mov w1, [w2]

[comp_error_history_update]
address_loop=b
head_comment=%SEPARATOR%; Update error history (move error one tick along the delay line)
cycles=2
lines=2
comment0=move entry (n-%INDEX%) into buffer 
comment1=move buffered value one tick down the delay line
code0=mov [w10 + #%INDEX*ADDR_DATA-ADDR_DATA%], w6
code1=mov w6, [w10 + #%INDEX*ADDR_DATA%]

[comp_error_history_update_reverse]
filter_order_loop=b
head_comment=%SEPARATOR%; Update error history in reverse order (move error one tick along the delay line)
cycles=2
lines=2
comment0=move entry (n-%FO-INDEX%) one tick down the delay line
code0=mov [w10 + #%FO*ADDR_DATA% - #%INDEX*ADDR_DATA+ADDR_DATA%], w6
code1=mov w6, [w10 + #%FO*ADDR_DATA% - #%INDEX*ADDR_DATA%]

[comp_error_add_most_recent_to_mac]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=load most recent error input into MAC wreg
code0=mov w1, w6

[comp_error_add_most_recent_to_history]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent error input to history array
code0=mov w1, [w10]

[comp_error_add_most_recent_to_history_reverse]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent error input to history array
code0=mov w1, [w10 + #%FO*ADDR_DATA% - %FO*ADDR_DATA%]

[comp_control_history_update]
address_loop=a
head_comment=%SEPARATOR%; Update control output history
cycles=2
lines=2
comment0=move entry (n-%INDEX%) one tick down the delay line
code0=mov [w10 + #%INDEX*ADDR_DATA-ADDR_DATA%], w6
code1=mov w6, [w10 + #%INDEX*ADDR_DATA%]

[comp_control_history_update_reverse]
filter_order_loop=a
head_comment=%SEPARATOR%; Update control history in reverse order (move error one tick along the delay line)
cycles=2
lines=2
comment0=move entry (n-%FO-INDEX%) one tick down the delay line
code0=mov [w10 + #%FO*ADDR_DATA% - #%INDEX*ADDR_DATA+ADDR_DATA%], w6
code1=mov w6, [w10 + #%FO*ADDR_DATA% - #%INDEX*ADDR_DATA%]

[comp_control_add_most_recent_to_history]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent control output to history
code0=mov w4, [w10]

[comp_control_add_most_recent_to_history_reverse]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent control output to history
code0=mov w4, [w10 - %FO*ADDR_DATA%]

[comp_control_add_most_recent_to_history_indirect]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent control output to history
code0=mov w4, [w0 + #ptrControlHistory]

[load_a_coeff_array_ptr]
head_comment=%SEPARATOR%; Setup pointers to A-Term data arrays
cycles=1
lines=1
comment0=load pointer to first index of A coefficients array
code0=mov [w0 + #ptrACoefficients], w8

[load_a_coeff_array_ptr_reverse]
head_comment=%SEPARATOR%; Setup pointers to end of A-Term data arrays
cycles=2
lines=2
comment0=load pointer to end of A coefficients array
code0=mov [w0 + #ptrBCoefficients], w8
code1=add w8, #%FO*ADDR_COEF%, w8

[load_b_coeff_array_ptr]
head_comment=%SEPARATOR%; Setup pointers to B-Term data arrays
cycles=1
lines=1
comment0=load pointer to first index of B coefficients array
code0=mov [w0 + #ptrBCoefficients], w8

[load_b_coeff_array_ptr_reverse]
head_comment=%SEPARATOR%; Setup pointers to end of B-Term data arrays
cycles=2
lines=2
comment0=load pointer to end of B coefficients array
code0=mov [w0 + #ptrBCoefficients], w8
code1=add w8, #%FO*ADDR_COEF%, w8

[load_b0_coeff_to_wreg]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=Load coefficient B0 into wreg
code0=mov [w8], w6

[load_error_history_array_ptr]
head_comment=%SEPARATOR%; Setup pointer to first element of error history array
cycles=1
lines=1
comment0=load pointer address into wreg
code0=mov [w0 + #ptrErrorHistory], w10

[load_error_history_array_ptr_reverse]
head_comment=%SEPARATOR%; Setup pointer to first element of error history array
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #ptrErrorHistory], w10
code1=add w10, #%FO*ADDR_DATA%, w10

[load_error_history_before_update_array_ptr]
head_comment=%SEPARATOR%; Setup pointer to second element of error history array
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #ptrErrorHistory], w10
code1=add w10, #%ADDR_DATA%, w10

[load_error_history_before_update_array_ptr_reverse]
head_comment=%SEPARATOR%; Setup pointer to penultimate element of error history array
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #ptrErrorHistory], w10
code1=add w10, #%FO*ADDR_DATA-ADDR_DATA%, w10

[load_control_history_array_ptr]
head_comment=%SEPARATOR%; Load pointer to first element of control history array
cycles=1
lines=1
comment0=load pointer address into wreg
code0=mov [w0 + #ptrControlHistory], w10

[load_control_history_array_ptr_reverse]
head_comment=%SEPARATOR%; Load pointer to last element of control history array (reverse addressing)
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #ptrControlHistory], w10
code1=add w10, #%FO*ADDR_DATA%, w10

[load_control_history_before_update_array_ptr]
head_comment=%SEPARATOR%; Load pointer to second element of control history array
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #ptrControlHistory], w10
code1=add w10, #%ADDR_DATA%, w10

[load_control_history_array_before_update_ptr_reverse]
head_comment=%SEPARATOR%; Load pointer to penultimate element of control history array (reverse addressing)
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #ptrControlHistory + %FO*ADDR_DATA-ADDR_DATA%], w10

[comp_mac_start_acca_clear_no_prefetch]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=clear accumulator A without prefetch of operands
code0=clr a

[comp_mac_start_acca_clear_prefetch]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=clear accumulator A and prefetch first operands
code0=clr a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_start_acca_reverse_clear]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=clear accumulator A and prefetch last operands
code0=clr a, [w8]-=%ADDR_COEF%, w4, [w10 + #%FO*ADDR_DATA%]-=%ADDR_DATA%, w6

[comp_mac_start_acca_resume]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=leave contents accumulator A untouched and prefetch first operands
code0=movsac a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_start_acca_reverse_resume]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=leave contents accumulator A untouched and prefetch last operands
code0=movsac a, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_start_accb_clear_no_prefetch]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=clear accumulator B without prefetch of operands
code0=clr b

[comp_mac_start_accb_clear_prefetch]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=clear accumulator B and prefetch first operands
code0=clr b, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_start_accb_reverse_clear]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=clear accumulator B and prefetch last operands
code0=clr b, [w8]-=%ADDR_COEF%, w4, [w10 + #%FO*ADDR_DATA%]-=%ADDR_DATA%, w6

[comp_mac_start_accb_resume]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=leave contents of accumulator B untouched and prefetch first operands
code0=movsac b, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_start_accb_reverse_resume]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=leave contents of accumulator B untouched and prefetch last operands
code0=movsac b, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_loop_a_term_acca]
filter_order_loop=a
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply control output (n-%INDEX%) from the delay line with coefficient A%INDEX%
code0=mac w4*w6, a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_loop_a_term_reverse_acca]
filter_order_loop=a
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply control output (n-%FO-INDEX%) from the delay line with coefficient A%FO-INDEX%
code0=mac w4*w6, a, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_loop_a_term_accb]
filter_order_loop=a
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply control output (n-%INDEX%) from the delay line with coefficient A%INDEX%
code0=mac w4*w6, b, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_loop_a_term_reverse_accb]
filter_order_loop=a
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply control output (n-%FO-INDEX%) from the delay line with coefficient A%FO-INDEX%
code0=mac w4*w6, b, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_loop_b_term_acca]
filter_order_loop=b
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate error input (n-%INDEX%) from the delay line with coefficient B%INDEX% and prefetch next operands
code0=mac w4*w6, a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_loop_b_term_reverse_acca]
filter_order_loop=b
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate error input (n-%FO-INDEX%) from the delay line with coefficient B%FO-INDEX% and prefetch next operands
code0=mac w4*w6, a, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_loop_b_term_accb]
filter_order_loop=b
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate error input (n-%INDEX%) from the delay line with coefficient B%INDEX% and prefetch next operands
code0=mac w4*w6, b, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_loop_b_term_reverse_accb]
filter_order_loop=b
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate error input (n-%FO-INDEX%) from the delay line with coefficient B%FO-INDEX% and prefetch next operands
code0=mac w4*w6, b, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_end_acca]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate last control output with coefficient of the delay line (no more prefetch)
code0=mac w4*w6, a

[comp_mac_end_accb]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate last error input with coefficient of the delay line (no more prefetch)
code0=mac w4*w6, b

[comp_backward_norm_acca]
head_comment=%SEPARATOR%; Backward normalization of recent result
cycles=2
lines=2
comment0=load A-coefficients post bit-shift scaler value into working register
comment1=shift accumulator A by number of bits loaded in working register
code0=mov [w0 + #PostShiftA], w6
code1=sftac a, w6

[comp_backward_norm_accb]
head_comment=%SEPARATOR%; Backward normalization of recent result
cycles=2
lines=2
comment0=load B-coefficients post bit-shift scaler value into working register
comment1=shift accumulator B by number of bits loaded in working register
code0=mov [w0 + #PostShiftB], w6
code1=sftac b, w6

[comp_backward_norm_coeff_scaler_acca]
head_comment=%SEPARATOR%; Initialize Scale-factor and multiply
cycles=2
lines=2
comment0=load post scaler fractional value into working register
comment1=multiply control output by scaler value loaded into working register
code0=mov [w0 + #PostScaler],  w6
code1=mpy w4*w6, a

[comp_mac_store_acca]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=store most recent accumulator result in working register
code0=sac.r a, w4

[comp_mac_store_accb]
head_comment=\n; Backwards normalization of the controller output
cycles=1
lines=1
comment0=store most recent accumulator result in working register
code0=sac.r b, w4

[comp_mac_load32b_a]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=load value of saved accumulator upper word into accumulator A
comment1=load value of saved accumulator high word into accumulator A
comment2=load value of saved accumulator low word into accumulator A
code0=mov [w0 + #ACCxU], accau
code1=mov [w0 + #ACCxH], accah
code2=mov [w0 + #ACCxL], accal

[comp_mac_load32b_accb]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=load value of saved accumulator upper word into accumulator B
comment1=load value of saved accumulator high word into accumulator B
comment2=load value of saved accumulator low word into accumulator B
code0=mov [w0 + #ACCxU], accbu
code1=mov [w0 + #ACCxH], accbh
code2=mov [w0 + #ACCxL], accbl

[comp_mac_store32b_a]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=store value of accumulator A upper word into data structure
comment1=store value of accumulator A high word into data structure
comment2=store value of accumulator A low word into data structure
code0=mov accau, [w0 + #ACCxU]
code1=mov accah, [w0 + #ACCxH]
code2=mov accal, [w0 + #ACCxL]

[comp_mac_store32b_accb]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=store value of accumulator B upper word into data structure
comment1=store value of accumulator B high word into data structure
comment2=store value of accumulator B low word into data structure
code0=mov accbu, [w0 + #ACCxU]
code1=mov accbh, [w0 + #ACCxH]
code2=mov accbl, [w0 + #ACCxL]

[comp_add_acca_to_accb]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add accumulator a to accumulator b
code0=add b

[comp_add_accb_to_acca]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add accumulator b to accumulator a
code0=add a

[comp_writeback]
head_comment=%SEPARATOR%; Write control output value to target
cycles=2
lines=2
comment0=move pointer to target in to working register
comment1=move control output into target address
code0=mov [w0 + #ptrTargetRegister], w8
code1=mov w4, [w8]

[comp_writeback_with_alt_target_switch]
head_comment=%SEPARATOR%; Write control output value to target
cycles=4
lines=4
comment0=move pointer to target to working register
comment1=if SWAP TARGET option is enabled, execute next instruction
comment2=move pointer to alternate target to working register
comment3=move control output into target address
code0=mov [w0 + #ptrTargetRegister], w8
code1=btsc w12, #NPNZ16_STATUS_SWAP_TARGET
code2=mov [w0 + #ptrAltTargetRegister], w8
code3=mov w4, [w8]

[comp_writeback_ssm]
head_comment=%SEPARATOR%; Add spread specturm modulator
cycles=3
lines=3
comment0=%EMPTY%
code0=mov [w0 + #ptrTargetRegister], w8
code1=mov [w0 + #ssmFactor], w6
code2=mpy w4*w6, [w8]

[adc_trigger_a_placement]
head_comment=%SEPARATOR%; Update ADC trigger A position
cycles=5
lines=5
comment0=half control output by shifting value one bit to the right
comment1=load user-defined ADC trigger A offset value into working register
comment2=add user-defined ADC trigger A offset to half of control output
comment3=load pointer to ADC trigger A register into working register
comment4=push new ADC trigger value to ADC trigger A register
code0=asr w4, #1, w6
code1=mov [w0 + #ADCTriggerAOffset], w8
code2=add w6, w8, w10
code3=mov [w0 + #ptrADCTriggerARegister], w8
code4=mov w10, [w8]

[adc_trigger_b_placement]
head_comment=%SEPARATOR%; Update ADC trigger B position
cycles=4
lines=4
comment0=half control output by shifting value one bit to the right
comment1=load user-defined ADC trigger B offset value into working register
comment2=add user-defined ADC trigger B offset to half of control output
comment3=load pointer to ADC trigger B register into working register
comment4=push new ADC trigger value to ADC trigger B register
code0=mov [w0 + #ADCTriggerBOffset], w8
code1=add w6, w8, w10
code2=mov [w0 + #ptrADCTriggerBRegister], w8
code3=mov w10, [w8]

[return]
head_comment=%SEPARATOR%; End of routine
cycles=1
lines=2
comment0=%EMPTY%
code0=return
code1=%SEPARATOR%

[end]
head_comment=%SEPARATOR%; End of file
cycles=1
lines=2
comment0=%EMPTY%
code0=.end
code1=%SEPARATOR%

;
; Specific projected floating point instruction blocks
;

[fscl_context_save_mac_registers]
item_loop=wreg_usage
head_comment=%EMPTY%
cycles=5
lines=5
comment0=save working registers used for MAC operations (w4, w5, w6, w8, w10)
code0=push w4
code1=push w5
code2=push w6
code3=push w8
code4=push w10

[fscl_context_restore_mac_registers]
item_loop=wreg_usage
head_comment=%EMPTY%
cycles=5
lines=5
comment0=restore working registers used for MAC operations (w4, w5, w6, w8, w10)
code0=pop w4
code1=pop w5
code2=pop w6
code3=pop w8
code4=pop w10

[fscl_comp_mac_start_clear]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=2
lines=2
comment0=clear both accumulators and prefetch first operands
code0=clr b, [w8]+=%ADDR_DATA%, w5
code1=clr a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[fscl_comp_mac_start_resume]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=2
lines=2
comment0=leave contents of accumulator B unchanged
comment1=clear accumulator A and prefetch first operands
code0=movsac b, [w8]+=%ADDR_DATA%, w5
code1=clr a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[fscl_comp_mac_first]
head_comment=%EMPTY%
cycles=4
lines=4
comment0=multiply control output (n-%INDEX%) from the delay line with coefficient X%INDEX%
comment1=shift accumulator to post-scale floating number
comment2=adding accumulator b to a
code0=mpy w4*w6, a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6
code1=sftac a, w5
code2=add b

[fscl_comp_mac_a_loop]
filter_order_loop=as
head_comment=%EMPTY%
cycles=4
lines=4
comment0=load scaler into wreg
comment1=multiply control output (n-%INDEX%) from the delay line with coefficient X%INDEX%
comment2=shift accumulator to post-scale floating number
comment3=adding accumulator b to a
code0=mov [w8 - #%ADDR_DATA*3%], w5
code1=mpy w4*w6, a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6
code2=sftac a, w5
code3=add b

[fscl_comp_mac_b_loop]
filter_order_loop=bs
head_comment=%EMPTY%
cycles=4
lines=4
comment0=load scaler into wreg
comment1=multiply control output (n-%INDEX%) from the delay line with coefficient X%INDEX%
comment2=shift accumulator to post-scale floating number
comment3=adding accumulator b to a
code0=mov [w8 - #%ADDR_DATA*3%], w5
code1=mpy w4*w6, a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6
code2=sftac a, w5
code3=add b

[fscl_comp_mac_end]
head_comment=%EMPTY%
cycles=4
lines=4
comment0=load scaler into wreg
comment1=multiply & accumulate last control output with coefficient of the delay line (no more prefetch)
comment2=shift accumulator to post-scale floating number
comment3=adding accumulator b to a
code0=mov [w8 - #%ADDR_DATA*3%], w5
code1=mpy w4*w6, a
code2=sftac a, w5
code3=add b

[pterm_comp_load_gain_factor]
head_comment=%SEPARATOR%; Load P-gain factor from data structure
cycles=3
lines=3
comment0=move P-coefficient fractional into working register
comment1=move P-coefficient scaler into working register
comment2=move error to MPY working register 
code0=mov [w0 + #AdvParam1], w6
code1=mov [w0 + #AdvParam2], w5 
code2=mov w1, w4

[pterm_comp_exec_pterm]
head_comment=; calculate P-control result
cycles=3
lines=3
comment0=multiply most recent error with P-coefficient
comment1=shift accumulator to post-scale floating number
comment2=store accumulator result to working register
code0=mpy w4*w6, a
code1=sftac a, w5
code2=sac.r a, w4

[agc_factor_multiply_start]
head_comment=%SEPARATOR%; Adaptive Loop Gain Modulation
cycles=0
lines=0

[agc_factor_multiply_enable_start]
head_comment=%EMPTY%
cycles=3
lines=2
comment0=check status bit if Adaptive Gain Control is enabled
comment1=branch to end of AGC calculation if not
code0=btss w12, #NPMZ16_STATUS_AGC_ENABLED
code1=bra %PREFIXU%_BYPASS_AGC

[agc_factor_multiply_enable_end]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=branch target for AGC enable-/disable-switch
code0=%PREFIXU%_BYPASS_AGC:

[agc_factor_multiply_get_factor_call]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=call function determining most recent modulation factor
code0=call %PREFIXG%_GetGainFactor

[agc_factor_multiply_scaled]
head_comment=%EMPTY%
cycles=5
lines=5
comment0=load AGC modulation factor into working register
comment1=load AGC modulation factor scaler into working register
comment2=store result of accumulator B in working register
comment3=multiply accumulator B result with AGC modulation factor
comment4=shift result by AGC scaler
code0=mov [w0 + #agcGainModFactor], w4  
code1=mov [w0 + #agcGainModScaler], w2
code2=sac.r b, w6
code3=mpy w4*w6, b
code4=sftac b, w2

[agc_factor_get_factor]
head_comment=%SEPARATOR%; Global function declaration %PREFIXG%_GetGainFactor\n; This function calculates a the gain modulation factor \n; by deviding Alternate Source by Source%SEPARATOR%
cycles=9
lines=21
comment0=%EMPTY%
comment1=%EMPTY%
comment2=load pointer to most recent input voltage register
comment3=load value into w1
comment4=load most recent input voltage normalization scaler
comment5=normalize input voltage value
comment6=load pointer to most recent output voltage register
comment7=load value into w2
comment8=load most recent output voltage normalization scaler
comment9=normalize output voltage value
comment10=calculate most recent VL, place result in w6
comment11=load pointer to nominal VL
comment12=Save working register WREG0 (holds data structure start address)
comment13=clear divider target register #0
comment14=clear divider target register #1
comment15=repeat divide instructions n-times
comment16=divide nominal VL by instantaneous VL
comment17=normalize result to Q15 number
comment18=move result outo f WREG0
comment19=restore WREG0 to get access to data structure back
comment20=move gain factor result back into data structure
code0=.global %PREFIXG%_GetGainFactor
code1=%PREFIXG%_GetGainFactor:\n
code2=mov [w0 + #ptrAltSourceRegister], w1
code3=mov [w1], w1 
code4=mov [w0 + AltSourceNormShift], w3
code5=sl  w1, w3, w1
code6=mov [w0 + #ptrSourceRegister], w2
code7=mov [w2], w2
code8=mov [w0 + SourceNormShift], w3
code9=sl  w2, w2, w2
code10=sub w1, w2, w6
code11=mov [w0 + #agcGainModMedian], w4
code12=push w0
code13=clr  w0
code14=clr  w1
code15=repeat #[%P33C%$5][%P33E%$17][%P33F%$17]
code16=divf w4, w6
code17=sl w0, #1, w0
code18=mov w0, w2
code19=pop w0
code20=mov w2, [w0 + #agcGainModFactor]


___________________________________________________
(C)2020, Microchipt Technology Inc.
