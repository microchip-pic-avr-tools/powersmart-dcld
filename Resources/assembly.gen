[generic]
Name=Assembly Generator Script
Description=this script defines DSP assembly code generation templates used to generate user-tailored SMPS control loops using the DCLD SDK
Author=Andreas Reiter - M91406
Version=1.3.1
Date=01/17/2020

[history]
count=8
0=04/03/19;1.1.1;Added input offset compensation applied to input source
1=10/18/19;1.2.0;Changed existing input offset compensation to full bi-directional feedback implementation
2=10/19/19;1.2.1;Added code option for feedback signal rectification
3=10/22/19;1.2.2;Fixed typos in comments of data structure
4=11/07/19;1.2.3;Added 'Dummy Read of Source Buffer' when control loop is disabled\r\nAdded second ADC trigger placement target and offset
5=11/08/19;1.2.4;Added 'Changed data provider items from local copies in cNPNZ16b_t data structure to poinbter to external data buffers
6=01/10/19;1.3.0;Added support for cascaded functions. This allows a controller to call another controller or user-defined function extension code module
7=01/13/2020;1.3.1;Reordered cascaded function call to execute full cascade even if controller is disabled.

[filter_block_scaling_modes]
count=6
0=%EMPTY%
1=sbsft
2=scscl
3=dbsft
4=fscl
5=ffloat

[filter_block_scaling_modes_descritpion]
sbsft=Single Bitshift-Scaling Mode
scscl=Single Coefficient Factor Scaling Mode
dbsft=Dual Bitshift-Scaling Mode
fscl=Fast Floating Point Coefficient Scaling Mode
ffloat=Fast Floating Point Mode

[filter_block_array_addressing]
addr_offset_sbft=2
addr_offset_scscl=2
addr_offset_dbsft=2
addr_offset_fscl=2
addr_offset_ffloat=4

[MSExcelExport]
PoleAtOrigin=IMDIV(wp0 ,COMPLEX(0,[<SHEET.CELL.RADIANDS>]))
LeadLagBlock=IMDIV(IMSUM(IMDIV(COMPLEX(0,[<SHEET.CELL.RADIANDS>]),wz%FO%,1),IMSUM(IMDIV(COMPLEX(0,[<SHEET.CELL.RADIANDS>]),wp%FO%),1))
FORMULA=IMPRODUCT(%PoleAtOrigin%, %LeadLagBlock%)


[add_data_structure_sbsft]
head_comment=%SEPARATOR%; Address offset declarations for data structure addressing
cycles=0
lines=30
comment0=status word at address-offset
comment1=pointer to source memory address
comment2=pointer to alternate source memory address
comment3=pointer to target memory address
comment4=pointer to alternate target memory address
comment5=pointer to control reference memory address
comment6=pointer to A-coefficients array start address
comment7=pointer to B-coefficients array start address
comment8=pointer to control history array start address
comment9=pointer to error history array start address
comment10=size of the A-coefficients array
comment11=size of the B-coefficients array
comment12=size of the control history array
comment13=size of the error history array
comment14=value of input value normalization bit-shift scaler
comment15=value of A-term normalization bit-shift scaler
comment16=(reserved)
comment17=(reserved)
comment18=input source offset value
comment19=minimum clamping value of control output 
comment20=maximum clamping value of control output 
comment21=pointer to ADC trigger #1 register memory address
comment22=value of ADC trigger #1 offset
comment23=pointer to ADC trigger #2 register memory address
comment24=value of ADC trigger #2 offset
comment25=pointer to external data buffer of most recent control input
comment26=pointer to external data buffer of most recent control error
comment27=pointer to external data buffer of most recent control output
comment28=pointer to external, cascaded function which will be called from controller
comment29=16-bit wide function parameter or pointer to a parameter data structure of cascaded function
code0=.equ offStatus,                 0
code1=.equ offSourceRegister,         2
code2=.equ offAltSourceRegister,      4
code3=.equ offTargetRegister,         6
code4=.equ offAltTargetRegister,      8
code5=.equ offControlReference,       10
code6=.equ offACoefficients,          12
code7=.equ offBCoefficients,          14
code8=.equ offControlHistory,         16
code9=.equ offErrorHistory,           18
code10=.equ offACoeffArraySize,        20
code11=.equ offBCoeffArraySize,        22
code12=.equ offCtrlHistArraySize,      24
code13=.equ offErrHistArraySize,       26
code14=.equ offPreShift,               28
code15=.equ offPostShiftA,             30
code16=.equ reserved_1,                32
code17=.equ reserved_2,                34
code18=.equ offInputOffset,            36
code19=.equ offMinOutput,              38
code20=.equ offMaxOutput,              40
code21=.equ offADCTriggerARegister,    42
code22=.equ offADCTriggerAOffset,      44
code23=.equ offADCTriggerBRegister,    46
code24=.equ offADCTriggerBOffset,      48
code25=.equ offPtrControlInput,        50
code26=.equ offPtrControlError,        52
code27=.equ offPtrControlOutput,       54
code28=.equ offPtrCascadedFunction,    56 
code29=.equ offPtrCascadedFunParam,    58


[blockset_sbsft_0]
;Instruction blockset for signle-bitshed 16-bit fixed point controllers
;linear execution of compensation filter (MAC_A - READ - UPDATE_B - MAC_B - CLAMP - WRITE - ATRIG - UPDATE_A)
wreg_usage=4,6,8,10,13
accu_usage=a
count=81
0=disclaimer
1=lists
2=section_header
3=add_global_flags
4=add_data_structure_sbsft
5=section_code
6=exec_function_head
7=context_save
8=context_save_shadow
9=context_save_status_word_wreg
10=enable_disable_start
11=context_save
12=context_save_mac_registers
13=context_save_accumulator_a
14=context_save_accumulator_b
15=context_save_core_config
16=context_save_core_status
17=core_config
18=load_a_coeff_array_ptr
19=load_control_history_array_ptr
20=comp_mac_start_acca_clear_prefetch
21=comp_mac_loop_a_term_acca
22=comp_mac_end_acca
23=load_error_history_array_ptr
24=comp_error_history_update
25=comp_read_input
26=shadow_copy_control_input
27=comp_get_error
28=comp_zero_input
29=comp_invert_input
30=comp_norm_error
31=shadow_copy_error_input
32=load_b_coeff_array_ptr
33=comp_error_add_most_recent_to_history
34=comp_mac_start_acca_resume
35=comp_mac_loop_b_term_acca
36=comp_mac_end_acca
37=comp_backward_norm_acca
38=comp_mac_store_acca
39=anti_windup
40=anti_windup_max
41=anti_windup_min
42=comp_writeback
43=shadow_copy_control_output
44=adc_trigger_a_placement
45=adc_trigger_b_placement
46=load_control_history_array_ptr
47=comp_control_history_update
48=comp_control_add_most_recent_to_history
49=update_status_bitfield
50=context_restore
51=context_restore_mac_registers
52=context_restore_accumulator_a
53=context_restore_accumulator_b
54=context_restore_core_config
55=context_restore_core_status
56=enable_disable_end
57=enable_disable_end_dummy_read
58=enable_disable_end_dummy_read_end
59=cascaded_function_call
60=context_restore
61=context_restore_shadow
62=context_restore_status_word_wreg
63=return
64=reset_function_head
65=clear_control_history_start
66=clear_control_history_loop
67=clear_control_history_end
68=clear_error_history_start
69=clear_error_history_loop
70=clear_error_history_end
71=return
72=charge_function_head
73=charge_error_history_start
74=charge_error_history_loop
75=charge_error_history_end
76=charge_control_history_start
77=charge_control_history_loop
78=charge_control_history_end
79=return
80=end


[blockset_sbsft_1]
;Instruction blockset for signle-bitshed 16-bit fixed point controllers
;linear execution of compensation filter (READ - MAC_B0 - CLAMP - WRITE - ATRIG - UPDATE_A - MAC_A - UPDATE_B - MAC_B)
wreg_usage=4,6,8,10,13
accu_usage=a
count=85
0=disclaimer
1=lists
2=section_header
3=add_global_flags
4=add_data_structure_fscl
5=section_code
6=exec_function_head
7=context_save
8=context_save_shadow
9=context_save_status_word_wreg
10=enable_disable_start
11=context_save
12=context_save_mac_registers
13=context_save_accumulator_a
14=context_save_accumulator_b
15=context_save_core_config
16=context_save_core_status
17=core_config
18=comp_read_input
19=shadow_copy_control_input
20=comp_get_error
21=comp_zero_input
22=comp_invert_input
23=comp_norm_error
24=shadow_copy_error_input
25=load_b_coeff_array_ptr
26=load_error_history_array_ptr
27=comp_error_add_most_recent_to_history
28=comp_mac_load32b_a
29=comp_mac_start_acca_resume
30=comp_mac_end_acca
31=comp_backward_norm_acca
32=comp_mac_store_acca
33=anti_windup
34=anti_windup_max
35=anti_windup_min
36=comp_writeback
37=comp_control_add_most_recent_to_history_indirect
38=adc_trigger_a_placement
39=adc_trigger_b_placement
40=shadow_copy_control_output
41=comp_error_history_update
42=load_b_coeff_array_ptr_reverse
43=load_error_history_array_ptr
44=comp_mac_start_acca_reverse_clear
45=comp_mac_loop_b_term_reverse_acca
46=load_a_coeff_array_ptr
47=load_control_history_array_ptr
48=comp_mac_start_acca_resume
49=comp_mac_loop_a_term_acca
50=comp_mac_end_acca
51=comp_control_history_update
52=comp_mac_store32b_a
53=update_status_bitfield
54=cascaded_function_call
55=context_restore
56=context_restore_mac_registers
57=context_restore_accumulator_a
58=context_restore_accumulator_b
59=context_restore_core_config
60=context_restore_core_status
61=enable_disable_end
62=enable_disable_end_dummy_read
63=enable_disable_end_dummy_read_end
64=context_restore
65=context_restore_shadow
66=context_restore_status_word_wreg
67=return
68=reset_function_head
69=clear_control_history_start
70=clear_control_history_loop
71=clear_control_history_end
72=clear_error_history_start
73=clear_error_history_loop
74=clear_error_history_end
75=return
76=charge_function_head
77=charge_error_history_start
78=charge_error_history_loop
79=charge_error_history_end
80=charge_control_history_start
81=charge_control_history_loop
82=charge_control_history_end
83=return
84=end


[add_data_structure_scscl]
head_comment=%SEPARATOR%; Address offset declarations for data structure addressing
cycles=0
lines=30
comment0=status word at address-offset = 0
comment1=pointer to source memory address
comment2=pointer to alternate source memory address
comment3=pointer to target memory address
comment4=pointer to alternate target memory address
comment5=pointer to control reference memory address
comment6=pointer to A-coefficients array start address
comment7=pointer to B-coefficients array start address
comment8=pointer to control history array start address
comment9=pointer to error history array start address
comment10=size of the A-coefficients array
comment11=size of the B-coefficients array
comment12=size of the control history array
comment13=size of the error history array
comment14=value of input value normalization bit-shift scaler
comment15=value of A-term normalization bit-shift scaler
comment16=(reserved)
comment17=control loop output normalization factor
comment18=input source offset value
comment19=minimum clamping value of control output 
comment20=maximum clamping value of control output 
comment21=pointer to ADC trigger #1 register memory address
comment22=value of ADC trigger #1 offset
comment23=pointer to ADC trigger #2 register memory address
comment24=value of ADC trigger #2 offset
comment25=pointer to external data buffer of most recent control input
comment26=pointer to external data buffer of most recent control error
comment27=pointer to external data buffer of most recent control output
comment28=pointer to external, cascaded function which will be called from controller
comment29=16-bit wide function parameter or pointer to a parameter data structure of cascaded function
code0=.equ offStatus,                 0
code1=.equ offSourceRegister,         2
code2=.equ offSourceRegister,         4
code3=.equ offTargetRegister,         6
code4=.equ offTargetRegister,         8
code5=.equ offControlReference,       10
code6=.equ offACoefficients,          12
code7=.equ offBCoefficients,          14
code8=.equ offControlHistory,         16
code9=.equ offErrorHistory,           18
code10=.equ offACoeffArraySize,        20
code11=.equ offBCoeffArraySize,        22
code12=.equ offCtrlHistArraySize,      24
code13=.equ offErrHistArraySize,       26
code14=.equ offPreShift,               28
code15=.equ offPostShiftA,             30
code16=.equ reserved_1,                32
code17=.equ offPostScaler,             34
code18=.equ offInputOffset,            36
code19=.equ offMinOutput,              38
code20=.equ offMaxOutput,              40
code21=.equ offADCTriggerARegister,    42
code22=.equ offADCTriggerAOffset,      44
code23=.equ offADCTriggerBRegister,    46
code24=.equ offADCTriggerBOffset,      48
code25=.equ offPtrControlInput,        50
code26=.equ offPtrControlError,        52
code27=.equ offPtrControlOutput,       54
code28=.equ offPtrCascadedFunction,    56 
code29=.equ offPtrCascadedFunParam,    58


[blockset_scscl_0]
;Instruction blockset for output factor modulated, signle-bitshed 16-bit fixed point controllers
;linear execution of compensation filter
wreg_usage=4,6,8,10,13
accu_usage=a
count=83
0=disclaimer
1=lists
2=section_header
3=add_global_flags
4=add_data_structure_scscl
5=section_code
6=exec_function_head
7=context_save
8=context_save_shadow
9=context_save_status_word_wreg
10=enable_disable_start
11=context_save
12=context_save_mac_registers
13=context_save_accumulator_a
14=context_save_accumulator_b
15=context_save_core_config
16=context_save_core_status
17=core_config
18=load_a_coeff_array_ptr
19=load_control_history_array_ptr
20=comp_mac_start_acca_clear_prefetch
21=comp_mac_loop_a_term_acca
22=comp_mac_end_acca
23=load_b_coeff_array_ptr
24=load_error_history_array_ptr
25=comp_read_input
26=shadow_copy_control_input
27=comp_get_error
28=comp_zero_input
29=comp_invert_input
30=comp_norm_error
31=shadow_copy_error_input
32=comp_error_history_update
33=comp_error_add_most_recent_to_history
34=comp_mac_start_acca_resume
35=comp_mac_loop_b_term_acca
36=comp_mac_end_acca
37=comp_backward_norm_acca
38=comp_mac_store_acca
39=comp_backward_norm_coeff_scaler_acca
40=comp_mac_store_acca
41=anti_windup
42=anti_windup_max
43=anti_windup_min
44=comp_writeback
45=shadow_copy_control_output
46=adc_trigger_a_placement
47=adc_trigger_b_placement
48=load_control_history_array_ptr
49=comp_control_history_update
50=comp_control_add_most_recent_to_history
51=update_status_bitfield
52=context_restore
53=context_restore_mac_registers
54=context_restore_accumulator_a
55=context_restore_accumulator_b
56=context_restore_core_config
57=context_restore_core_status
58=enable_disable_end
59=enable_disable_end_dummy_read
60=enable_disable_end_dummy_read_end
61=cascaded_function_call
62=context_restore
63=context_restore_shadow
64=context_restore_status_word_wreg
65=return
66=reset_function_head
67=clear_control_history_start
68=clear_control_history_loop
69=clear_control_history_end
70=clear_error_history_start
71=clear_error_history_loop
72=clear_error_history_end
73=return
74=charge_function_head
75=charge_error_history_start
76=charge_error_history_loop
77=charge_error_history_end
78=charge_control_history_start
79=charge_control_history_loop
80=charge_control_history_end
81=return
82=end


[add_data_structure_dbsft]
head_comment=%SEPARATOR%; Address offset declarations for data structure addressing
cycles=0
lines=30
comment0=status word at address-offset = 0
comment1=pointer to source memory address
comment2=pointer to alternate source memory address
comment3=pointer to target memory address
comment4=pointer to alternate target memory address
comment5=pointer to control reference memory address
comment6=pointer to A-coefficients array start address
comment7=pointer to B-coefficients array start address
comment8=pointer to control history array start address
comment9=pointer to error history array start address
comment10=size of the A-coefficients array
comment11=size of the B-coefficients array
comment12=size of the control history array
comment13=size of the error history array
comment14=value of input value normalization bit-shift scaler
comment15=value of A-term normalization bit-shift scaler
comment16=value of B-term normalization bit-shift scaler
comment17=(reserved)
comment18=input source offset value
comment19=minimum clamping value of control output 
comment20=maximum clamping value of control output 
comment21=pointer to ADC trigger #1 register memory address
comment22=value of ADC trigger #1 offset
comment23=pointer to ADC trigger #2 register memory address
comment24=value of ADC trigger #2 offset
comment25=pointer to external data buffer of most recent control input
comment26=pointer to external data buffer of most recent control error
comment27=pointer to external data buffer of most recent control output
comment28=pointer to external, cascaded function which will be called from controller
comment29=16-bit wide function parameter or pointer to a parameter data structure of cascaded function
code0=.equ offStatus,                 0
code1=.equ offSourceRegister,         2
code2=.equ offAltSourceRegister,      4
code3=.equ offTargetRegister,         6
code4=.equ offAltTargetRegister,      8
code5=.equ offControlReference,       10
code6=.equ offACoefficients,          12
code7=.equ offBCoefficients,          14
code8=.equ offControlHistory,         16
code9=.equ offErrorHistory,           18
code10=.equ offACoeffArraySize,        20
code11=.equ offBCoeffArraySize,        22
code12=.equ offCtrlHistArraySize,      24
code13=.equ offErrHistArraySize,       26
code14=.equ offPreShift,               28
code15=.equ offPostShiftA,             30
code16=.equ offPostShiftB,             32
code17=.equ reserved_1,                34
code18=.equ offInputOffset,            36
code19=.equ offMinOutput,              38
code20=.equ offMaxOutput,              40
code21=.equ offADCTriggerARegister,    42
code22=.equ offADCTriggerAOffset,      44
code23=.equ offADCTriggerBRegister,    46
code24=.equ offADCTriggerBOffset,      48
code25=.equ offPtrControlInput,        50
code26=.equ offPtrControlError,        52
code27=.equ offPtrControlOutput,       54
code28=.equ offPtrCascadedFunction,    56 
code29=.equ offPtrCascadedFunParam,    58


[blockset_dbsft_0]
;Instruction blockset for double-bitshed 16-bit fixed point controllers
;linear execution of compensation filter
wreg_usage=4,6,8,10,13
accu_usage=ab
count=83
0=disclaimer
1=lists
2=section_header
3=add_global_flags
4=add_data_structure_dbsft
5=section_code
6=exec_function_head
7=context_save
8=context_save_shadow
9=context_save_status_word_wreg
10=enable_disable_start
11=context_save
12=context_save_mac_registers
13=context_save_accumulator_a
14=context_save_accumulator_b
15=context_save_core_config
16=context_save_core_status
17=core_config
18=load_a_coeff_array_ptr
19=load_control_history_array_ptr
20=comp_mac_start_acca_clear_prefetch
21=comp_mac_loop_a_term_acca
22=comp_mac_end_acca
23=comp_backward_norm_acca
24=comp_read_input
25=shadow_copy_control_input
26=comp_get_error
27=comp_zero_input
28=comp_invert_input
29=comp_norm_error
30=shadow_copy_error_input
31=load_b_coeff_array_ptr
32=load_error_history_array_ptr
33=comp_error_history_update
34=comp_error_add_most_recent_to_history
35=comp_mac_start_accb_clear_prefetch
36=comp_mac_loop_b_term_accb
37=comp_mac_end_accb
38=comp_backward_norm_accb
39=comp_add_accb_to_acca
40=comp_mac_store_acca
41=anti_windup
42=anti_windup_max
43=anti_windup_min
44=comp_writeback
45=shadow_copy_control_output
46=adc_trigger_a_placement
47=adc_trigger_b_placement
48=load_control_history_array_ptr
49=comp_control_history_update
50=comp_control_add_most_recent_to_history
51=update_status_bitfield
52=context_restore
53=context_restore_mac_registers
54=context_restore_accumulator_a
55=context_restore_accumulator_b
56=context_restore_core_config
57=context_restore_core_status
58=enable_disable_end
59=enable_disable_end_dummy_read
60=enable_disable_end_dummy_read_end
61=cascaded_function_call
62=context_restore
63=context_restore_shadow
64=context_restore_status_word_wreg
65=return
66=reset_function_head
67=clear_control_history_start
68=clear_control_history_loop
69=clear_control_history_end
70=clear_error_history_start
71=clear_error_history_loop
72=clear_error_history_end
73=return
74=charge_function_head
75=charge_error_history_start
76=charge_error_history_loop
77=charge_error_history_end
78=charge_control_history_start
79=charge_control_history_loop
80=charge_control_history_end
81=return
82=end


[add_data_structure_fscl]
head_comment=%SEPARATOR%; Address offset declarations for data structure addressing
cycles=0
lines=30
comment0=status word at address-offset = 0
comment1=pointer to source memory address
comment2=pointer to alternate source memory address
comment3=pointer to target memory address
comment4=pointer to alternate target memory address
comment5=pointer to control reference memory address
comment6=pointer to A-coefficients array start address
comment7=pointer to B-coefficients array start address
comment8=pointer to control history array start address
comment9=pointer to error history array start address
comment10=size of the A-coefficients array
comment11=size of the B-coefficients array
comment12=size of the control history array
comment13=size of the error history array
comment14=value of input value normalization bit-shift scaler
comment15=(reserved)
comment16=(reserved)
comment17=(reserved)
comment18=input source offset value
comment19=minimum clamping value of control output 
comment20=maximum clamping value of control output 
comment21=pointer to ADC trigger #1 register memory address
comment22=value of ADC trigger #1 offset
comment23=pointer to ADC trigger #2 register memory address
comment24=value of ADC trigger #2 offset
comment25=pointer to external data buffer of most recent control input
comment26=pointer to external data buffer of most recent control error
comment27=pointer to external data buffer of most recent control output
comment28=pointer to external, cascaded function which will be called from controller
comment29=16-bit wide function parameter or pointer to a parameter data structure of cascaded function
code0=.equ offStatus,                 0
code1=.equ offSourceRegister,         2
code2=.equ offAltSourceRegister,      4
code3=.equ offTargetRegister,         6
code4=.equ off├éltTargetRegister,      8
code5=.equ offControlReference,       10
code6=.equ offACoefficients,          12
code7=.equ offBCoefficients,          14
code8=.equ offControlHistory,         16
code9=.equ offErrorHistory,           18
code10=.equ offACoeffArraySize,        20
code11=.equ offBCoeffArraySize,        22
code12=.equ offCtrlHistArraySize,      24
code13=.equ offErrHistArraySize,       26
code14=.equ offPreShift,               28
code15=.equ reserved_1,                30
code16=.equ reserved_2,                32
code17=.equ reserved_3,                34
code18=.equ offInputOffset,            36
code19=.equ offMinOutput,              38
code20=.equ offMaxOutput,              40
code21=.equ offADCTriggerARegister,    42
code22=.equ offADCTriggerAOffset,      44
code23=.equ offADCTriggerBRegister,    46
code24=.equ offADCTriggerBOffset,      48
code25=.equ offPtrControlInput,        50
code26=.equ offPtrControlError,        52
code27=.equ offPtrControlOutput,       54
code28=.equ offPtrCascadedFunction,    56 
code29=.equ offPtrCascadedFunParam,    58


[blockset_fscl_0]
;Instruction blockset for double-bitshed 16-bit fixed point controllers
;linear execution of compensation filter
wreg_usage=4,5,6,8,10,13
accu_usage=ab
count=82
0=disclaimer
1=lists
2=section_header
3=add_global_flags
4=add_data_structure_fscl
5=section_code
6=exec_function_head
7=context_save
8=context_save_shadow
9=context_save_status_word_wreg
10=enable_disable_start
11=context_save
12=fscl_context_save_mac_registers
13=context_save_accumulator_a
14=context_save_accumulator_b
15=context_save_core_config
16=context_save_core_status
17=core_config
18=load_a_coeff_array_ptr
19=load_control_history_array_ptr
20=fscl_comp_mac_start_clear
21=fscl_comp_mac_first
22=fscl_comp_mac_a_loop
23=fscl_comp_mac_end
24=comp_read_input
25=shadow_copy_control_input
26=comp_get_error
27=comp_zero_input
28=comp_invert_input
29=comp_norm_error
30=shadow_copy_error_input
31=load_b_coeff_array_ptr
32=load_error_history_array_ptr
33=comp_error_history_update
34=comp_error_add_most_recent_to_history
35=fscl_comp_mac_start_resume
36=fscl_comp_mac_first
37=fscl_comp_mac_b_loop
38=fscl_comp_mac_end
39=comp_mac_store_accb
40=anti_windup
41=anti_windup_max
42=anti_windup_min
43=comp_writeback
44=shadow_copy_control_output
45=adc_trigger_a_placement
46=adc_trigger_b_placement
47=load_control_history_array_ptr
48=comp_control_history_update
49=comp_control_add_most_recent_to_history
50=update_status_bitfield
51=context_restore
52=fscl_context_restore_mac_registers
53=context_restore_accumulator_a
54=context_restore_accumulator_b
55=context_restore_core_config
56=context_restore_core_status
57=enable_disable_end
58=enable_disable_end_dummy_read
59=enable_disable_end_dummy_read_end
60=cascaded_function_call
61=context_restore
62=context_restore_shadow
63=context_restore_status_word_wreg
64=return
65=reset_function_head
66=clear_control_history_start
67=clear_control_history_loop
68=clear_control_history_end
69=clear_error_history_start
70=clear_error_history_loop
71=clear_error_history_end
72=return
73=charge_function_head
74=charge_error_history_start
75=charge_error_history_loop
76=charge_error_history_end
77=charge_control_history_start
78=charge_control_history_loop
79=charge_control_history_end
80=return
81=end


[disclaimer]
;head_comment=;LICENSE / DISCLAIMER ************************************************************\n;  Microchip Technology Inc. and its subsidiaries.  You may use this software \n;  and any derivatives exclusively with Microchip products. \n;  \n;  THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER \n;  EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED \n;  WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A \n;  PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION \n;  WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION. \n;  \n;  IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, \n;  INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND \n;  WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS \n;  BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.  TO THE \n;  FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS \n;  IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF \n;  ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE. \n;  \n;  MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE \n;  TERMS. \n; **********************************************************************************
head_comment=;LICENSE / DISCLAIMER
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%

[lists]
head_comment=%SEPARATOR%;file start
cycles=0
lines=2
comment0=%EMPTY%
code0=.nolist
code1=.list

[section_header]
head_comment=%SEPARATOR%;local inclusions.
cycles=0
lines=1
comment0=place constant data in the data section
code0=.section .data

[section_code]
head_comment=%SEPARATOR%;local inclusions.
cycles=0
lines=1
comment0=place code in the code section
;code0=;.section .libdsp, code
code0=.section .text

[add_global_flags]
head_comment=%SEPARATOR%; Define status flags bit positions
cycles=0
lines=6
comment0=bit position of the ENABLE control bit
comment1=bit position of the INVERT_INPUT control bit
comment2=bit position of the SWAP_SOURCE control bit
comment3=bit position of the SWAP_TARGET control bit
comment4=bit position of the UPPER_SATURATION_FLAG status bit
comment5=bit position of the LOWER_SATURATION_FLAG status bit
code0=.equ NPMZ16_STATUS_ENABLE,       15
code1=.equ NPMZ16_STATUS_INVERT_INPUT, 14
code2=.equ NPMZ16_STATUS_SWAP_SOURCE,  13
code3=.equ NPMZ16_STATUS_SWAP_TARGET,  12
code4=.equ NPMZ16_STATUS_USAT,         1
code5=.equ NPMZ16_STATUS_LSAT,         0

[exec_function_head]
head_comment=%SEPARATOR%; Global function declaration\n; This function calls the z-domain controller processing the latest data point input%SEPARATOR%
cycles=0
lines=2
comment0=%EMPTY%
comment1=provide global scope to routine
comment2=start of routine
code0=.global %PREFIXG%_Update
code1=%PREFIXG%_Update:\n

[reset_function_head]
head_comment=%SEPARATOR%; Global function declaration %PREFIXG%_Reset\n; This function clears control and error histories enforcing a reset%SEPARATOR%
cycles=0
lines=2
comment0=%EMPTY%
comment1=%EMPTY%
code0=.global %PREFIXG%_Reset
code1=%PREFIXG%_Reset:

[charge_function_head]
head_comment=%SEPARATOR%; Global function declaration %PREFIXG%_Precharge\n; This function loads user-defined default values into control and error histories%SEPARATOR%
cycles=0
lines=2
comment0=%EMPTY%
comment1=%EMPTY%
code0=.global %PREFIXG%_Precharge
code1=%PREFIXG%_Precharge:

[clear_control_history_start]
head_comment=%SEPARATOR%; Clear control history array
cycles=0
lines=2
comment0=Set pointer to the base address of control history array
code0=push w0
code1=mov  [w0 + #offControlHistory], w0

[clear_control_history_loop]
filter_order_loop=a
head_comment=%EMPTY%
cycles=0
lines=1
comment0=Clear next address of control history array
code0=clr [w0++]

[clear_control_history_end]
head_comment=%EMPTY%
cycles=0
lines=2
comment0=Clear last address of control history array
code0=clr [w0]
code1=pop w0

[clear_error_history_start]
head_comment=%SEPARATOR%; Clear error history array
cycles=0
lines=2
comment0=Set pointer to the base address of error history array
code0=push w0
code1=mov [w0 + #offErrorHistory], w0

[clear_error_history_loop]
filter_order_loop=b
head_comment=%EMPTY%
cycles=0
lines=1
comment0=Clear next address of error history array
code0=clr [w0++]

[clear_error_history_end]
head_comment=%EMPTY%
cycles=0
lines=2
comment0=Clear last address of error history array
code0=clr [w0]
code1=pop w0

[charge_control_history_start]
head_comment=%SEPARATOR%; Charge control history array with defined value
cycles=0
lines=3
comment0=Set pointer to the base address of control history array
code0=push w0
code1=push w2
code2=mov  [w0 + #offControlHistory], w0

[charge_control_history_loop]
filter_order_loop=a
head_comment=%EMPTY%
cycles=0
lines=1
comment0=Load user value into next address of control history array
code0=mov w2, [w0++]

[charge_control_history_end]
head_comment=%EMPTY%
cycles=0
lines=3
comment0=Load user value into last address of control history array
code0=mov w2, [w0]
code1=pop w2
code2=pop w0

[charge_error_history_start]
head_comment=%SEPARATOR%; Charge error history array with defined value
cycles=0
lines=3
comment0=Set pointer to the base address of error history array
code0=push w0
code1=push w1
code2=mov  [w0 + #offErrorHistory], w0

[charge_error_history_loop]
filter_order_loop=b
head_comment=%EMPTY%
cycles=0
lines=1
comment0=Load user value into next address of error history array
code0=mov w1, [w0++]

[charge_error_history_end]
head_comment=%EMPTY%
cycles=0
lines=3
comment0=Load user value into last address of error history array
code0=mov w1, [w0]
code1=pop w1
code2=pop w0

[context_save]
head_comment=%SEPARATOR%; Save working registers
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%		

[context_restore]
head_comment=%SEPARATOR%; Restore working registers
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%		

[context_save_shadow]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=save shadowed working registers (w0...w3)
code0=push.s		

[context_save_mac_registers]
item_loop=wreg_usage
head_comment=%EMPTY%
cycles=4
lines=4
comment0=save working registers used for MAC operations (w4, w6, w8, w10)
code0=push w4
code1=push w6
code2=push w8
code3=push w10

[context_save_status_word_wreg]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=save working register used for status flag tracking
code0=push w12

[context_save_accumulator_a]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=save accumulator A registers
code0=push ACCAL
code1=push ACCAH
code2=push ACCAU

[context_save_accumulator_b]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=save accumulator B registers
code0=push ACCBL
code1=push ACCBH
code2=push ACCBU

[context_save_core_config]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=save CPU configuration register
code0=push CORCON

[context_save_core_status]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=save CPU status register
code0=push SR

[context_restore_shadow]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=restore shadowed working registers (w0...w3)
code0=pop.s		

[context_restore_mac_registers]
head_comment=%EMPTY%
cycles=4
lines=4
comment0=restore working registers used for MAC operations w4, w6, w8, w10)
code0=pop w4
code1=pop w6
code2=pop w8
code3=pop w10

[context_restore_status_word_wreg]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=restore working register used for status flag tracking
code0=pop w12

[context_restore_accumulator_a]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=restore accumulator A registers
code0=pop ACCAL
code1=pop ACCAH
code2=pop ACCAU

[context_restore_accumulator_b]
head_comment=%EMPTY%
cycles=3
lines=3
comment=restore accumulator B registers
code0=pop ACCBL
code1=pop ACCBH
code2=pop ACCBU

[context_restore_core_config]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=restore CPU configuration registers
code0=pop CORCON

[context_restore_core_status]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=restore CPU status registers
code0=pop SR

[enable_disable_start]
declaration=.equ NPMZ16_STATUS_ENABLE, 15
data_structure=.equ	offStatus, 0
head_comment=%SEPARATOR%; Check status word for Enable/Disable flag and bypass computation, if disabled
cycles=4
lines=3
comment0=%EMPTY%
code0=mov [w0 + #offStatus], w12
code1=btss w12, #NPMZ16_STATUS_ENABLE
code2=bra %PREFIXU%_BYPASS_LOOP

[enable_disable_end_dummy_read]
head_comment=%SEPARATOR%; Enable/Disable bypass branch target with dummy read of source buffer
cycles=2
lines=4
comment0=when enabled, step over dummy read and go straight to EXIT
comment1=Enable/Disable bypass branch target to perform dummy read of source to clear the source buffer
comment2=load pointer to input source register
comment3=move value from input source into working register
code0=goto %PREFIXU%_EXIT_LOOP
code1=%PREFIXU%_BYPASS_LOOP:
code2=mov [w0 + #offSourceRegister], w2
code3=mov [w2], w1 

[enable_disable_end_dummy_read_end]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=Exit control loop branch target 
code0=%PREFIXU%_EXIT_LOOP:

[enable_disable_end]
head_comment=%SEPARATOR%; Enable/Disable bypass branch target
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_BYPASS_LOOP:

[core_config]
head_comment=%SEPARATOR%; Configure DSP for fractional operation with normal saturation (Q1.31 format)
cycles=2
lines=2
comment0=%EMPTY%
code0=mov #0x00E4, w4
code1=mov w4, _CORCON

[cascaded_function_call]
head_comment=%SEPARATOR%; Call next function of cascade
cycles=3
lines=3
comment0=load functoin pointer
comment1=load single parameter or pointer to parameter data structure
comment2=call function
code0=mov [w0 + #offPtrCascadedFunction], w1
code1=mov [w0 + #offPtrCascadedFunParam], w0
code2=call w1

[update_status_bitfield]
head_comment=%SEPARATOR%; Update status flag bitfield
cycles=1
lines=1
comment0=%EMPTY%
code0=mov w12, [w0 + #offStatus]

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[anti_windup]
head_comment=%SEPARATOR%; Controller Anti-Windup (control output value clamping)
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%

[anti_windup_soft_desaturation]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load address of most recent item in error history
comment1=set most recent error to zero
code0=mov [w0 + #offErrorHistory], w6
code1=clr [w6]

[anti_windup_max_start]
head_comment=\n; Check for upper limit violation
cycles=3
lines=2
comment0=load upper limit value
comment1=compare values and skip next instruction if control output is within operating range (control output < upper limit)
code0=mov [w0 + #offMaxOutput], w6
code1=cpslt w4, w6

[anti_windup_max_options_start]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=jump to override label if control output > upper limit
code0=bra %PREFIXU%_CLAMP_MAX_OVERRIDE

[anti_windup_max_options_override_bypass]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=jump to exit
code0=bra %PREFIXU%_CLAMP_MAX_EXIT

[anti_windup_max_options_override_start]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_CLAMP_MAX_OVERRIDE:

[anti_windup_max_set_status_flag]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=set upper limit saturation flag bit
code0=bset w12, #NPMZ16_STATUS_USAT

[anti_windup_max_clear_status_flag]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=clear upper limit saturation flag bit
code0=bclr w12, #NPMZ16_STATUS_USAT

[anti_windup_max_override]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=override controller output
code0=mov w6, w4

[anti_windup_max_options_end]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_CLAMP_MAX_EXIT:

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[anti_windup_soft_desaturation]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load address of most recent item in error history
comment1=set most recent error to zero
code0=mov [w0 + #offErrorHistory], w6
code1=clr [w6]

[anti_windup_min_start]
head_comment=\n; Check for lower limit violation
cycles=3
lines=2
comment0=load lower limit value
comment1=compare values and skip next instruction if control output is within operating range (control output > lower limit)
code0=mov [w0 + #offMinOutput], w6
code1=cpsgt w4, w6

[anti_windup_min_options_start]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=jump to override label if control output < lower limit
code0=bra %PREFIXU%_CLAMP_MIN_OVERRIDE

[anti_windup_min_options_override_bypass]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=jump to exit
code0=bra %PREFIXU%_CLAMP_MIN_EXIT

[anti_windup_min_options_override_start]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_CLAMP_MIN_OVERRIDE:

[anti_windup_min_set_status_flag]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=set lower limit saturation flag bit
code0=bset w12, #NPMZ16_STATUS_LSAT

[anti_windup_min_clear_status_flag]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=clear lower limit saturation flag bit
code0=bclr w12, #NPMZ16_STATUS_LSAT

[anti_windup_min_override]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=override controller output
code0=mov w6, w4

[anti_windup_min_options_end]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_CLAMP_MIN_EXIT:

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[comp_read_input]
head_comment=%SEPARATOR%; Read data from input source and calculate error input to transfer function
cycles=2
lines=2
comment0=load pointer to input source register
comment1=move value from input source into working register
code0=mov [w0 + #offSourceRegister], w2
code1=mov [w2], w1

[comp_read_input_with_alt_source_switch]
head_comment=%SEPARATOR%; Read data from primary or alternate input source and calculate error input to transfer function
cycles=4
lines=4
comment0=load pointer to alternate input source register
comment1=test SWAP_SOURCE status bit in status word and skip following instruction if cleared
comment2=load pointer to primary input source register
comment3=move value from primary or alternate input source into working register
code0=mov [w0 + #offSourceRegister], w2
code1=btsc w12, #NPMZ16_STATUS_SWAP_SOURCE
code2=mov [w0 + #offAltSourceRegister], w2
code3=mov [w2], w1

[comp_zero_input]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load input offset value into working register
comment1=add offset to error value
code0=mov [w0 + #offInputOffset], w2
code1=add w1, w2, w1

[comp_invert_input]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=Test control bit if value should be inverted
comment1=invert value
code0=btsc w12, #NPMZ16_STATUS_INVERT_INPUT
code1=neg w1, w1

[shadow_copy_control_input]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load pointer address of target buffer of most recent controller input from data structure
comment1=copy most recent controller input value to given data buffer target
code0=mov [w0 + #offPtrControlInput], w2
code1=mov w1, [w2]

[comp_get_error]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=move pointer to control reference into working register
comment1=calculate error (=reference - input)
code0=mov [w0 + #offControlReference], w2
code1=subr w1, [w2], w1

[comp_norm_error]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=move error input scaler into working register
comment1=normalize error result to fractional number format
code0=mov [w0 + #offPreShift], w2
code1=sl w1, w2, w1

[shadow_copy_error_input]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load pointer address of target buffer of most recent error value from data structure
comment1=copy most recent error value to given data buffer target
code0=mov [w0 + #offPtrControlError], w2
code1=mov w1, [w2]

[shadow_copy_control_output]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load pointer address of target buffer of most recent controller output value from data structure
comment1=copy most recent controller output value to given data buffer target
code0=mov [w0 + #offPtrControlOutput], w2
code1=mov w1, [w2]

[comp_error_history_update]
address_loop=b
head_comment=%SEPARATOR%; Update error history (move error one tick along the delay line)
cycles=2
lines=2
comment0=move entry (n-%INDEX%) into buffer 
comment1=move buffered value one tick down the delay line
code0=mov [w10 + #%INDEX*ADDR-ADDR%], w6
code1=mov w6, [w10 + #%INDEX*ADDR%]

[comp_error_history_update_reverse]
filter_order_loop=b
head_comment=%SEPARATOR%; Update error history in reverse order (move error one tick along the delay line)
cycles=2
lines=2
comment0=move entry (n-%FO-INDEX%) one tick down the delay line
code0=mov [w10 + #%FO*ADDR% - #%INDEX*ADDR+ADDR%], w6
code1=mov w6, [w10 + #%FO*ADDR% - #%INDEX*ADDR%]

[comp_error_add_most_recent_to_mac]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=load most recent error input into MAC wreg
code0=mov w1, w6

[comp_error_add_most_recent_to_history]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent error input to history array
code0=mov w1, [w10]

[comp_error_add_most_recent_to_history_reverse]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent error input to history array
code0=mov w1, [w10 + #%FO*ADDR% - %FO*ADDR%]

[comp_control_history_update]
address_loop=a
head_comment=%SEPARATOR%; Update control output history
cycles=2
lines=2
comment0=move entry (n-%INDEX%) one tick down the delay line
code0=mov [w10 + #%INDEX*ADDR-ADDR%], w6
code1=mov w6, [w10 + #%INDEX*ADDR%]

[comp_control_history_update_reverse]
filter_order_loop=a
head_comment=%SEPARATOR%; Update control history in reverse order (move error one tick along the delay line)
cycles=2
lines=2
comment0=move entry (n-%FO-INDEX%) one tick down the delay line
code0=mov [w10 + #%FO*ADDR% - #%INDEX*ADDR+ADDR%], w6
code1=mov w6, [w10 + #%FO*ADDR% - #%INDEX*ADDR%]

[comp_control_add_most_recent_to_history]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent control output to history
code0=mov w4, [w10]

[comp_control_add_most_recent_to_history_reverse]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent control output to history
code0=mov w4, [w10 - %FO*ADDR%]

[comp_control_add_most_recent_to_history_indirect]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent control output to history
code0=mov w4, [w0 + #offControlHistory]

[load_a_coeff_array_ptr]
head_comment=%SEPARATOR%; Setup pointers to A-Term data arrays
cycles=1
lines=1
comment0=load pointer to first index of A coefficients array
code0=mov [w0 + #offACoefficients], w8

[load_a_coeff_array_ptr_reverse]
head_comment=%SEPARATOR%; Setup pointers to end of A-Term data arrays
cycles=2
lines=2
comment0=load pointer to end of A coefficients array
code0=mov [w0 + #offBCoefficients], w8
code1=add w8, #%FO*ADDR%, w8

[load_b_coeff_array_ptr]
head_comment=%SEPARATOR%; Setup pointers to B-Term data arrays
cycles=1
lines=1
comment0=load pointer to first index of B coefficients array
code0=mov [w0 + #offBCoefficients], w8

[load_b_coeff_array_ptr_reverse]
head_comment=%SEPARATOR%; Setup pointers to end of B-Term data arrays
cycles=2
lines=2
comment0=load pointer to end of B coefficients array
code0=mov [w0 + #offBCoefficients], w8
code1=add w8, #%FO*ADDR%, w8

[load_b0_coeff_to_wreg]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=Load coefficient B0 into wreg
code0=mov [w8], w6

[load_error_history_array_ptr]
head_comment=%SEPARATOR%; Setup pointer to first element of error history array
cycles=1
lines=1
comment0=load pointer address into wreg
code0=mov [w0 + #offErrorHistory], w10

[load_error_history_array_ptr_reverse]
head_comment=%SEPARATOR%; Setup pointer to first element of error history array
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #offErrorHistory], w10
code1=add w10, #%FO*ADDR%, w10

[load_error_history_before_update_array_ptr]
head_comment=%SEPARATOR%; Setup pointer to second element of error history array
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #offErrorHistory], w10
code1=add w10, #%ADDR%, w10

[load_error_history_before_update_array_ptr_reverse]
head_comment=%SEPARATOR%; Setup pointer to penultimate element of error history array
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #offErrorHistory], w10
code1=add w10, #%FO*ADDR-ADDR%, w10

[load_control_history_array_ptr]
head_comment=%SEPARATOR%; Load pointer to first element of control history array
cycles=1
lines=1
comment0=load pointer address into wreg
code0=mov [w0 + #offControlHistory], w10

[load_control_history_array_ptr_reverse]
head_comment=%SEPARATOR%; Load pointer to last element of control history array (reverse addressing)
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #offControlHistory], w10
code1=add w10, #%FO*ADDR%, w10

[load_control_history_before_update_array_ptr]
head_comment=%SEPARATOR%; Load pointer to second element of control history array
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #offControlHistory], w10
code1=add w10, #%ADDR%, w10

[load_control_history_array_before_update_ptr_reverse]
head_comment=%SEPARATOR%; Load pointer to penultimate element of control history array (reverse addressing)
cycles=2
lines=2
comment0=load pointer address into wreg
code0=mov [w0 + #offControlHistory + %FO*ADDR-ADDR%], w10

[comp_mac_start_acca_clear_no_prefetch]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=clear accumulator A without prefetch of operands
code0=clr a

[comp_mac_start_acca_clear_prefetch]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=clear accumulator A and prefetch first operands
code0=clr a, [w8]+=%ADDR%, w4, [w10]+=%ADDR%, w6

[comp_mac_start_acca_reverse_clear]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=clear accumulator A and prefetch last operands
code0=clr a, [w8]-=%ADDR%, w4, [w10 + #%FO*ADDR%]-=%ADDR%, w6

[comp_mac_start_acca_resume]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=leave contents accumulator A untouched and prefetch first operands
code0=movsac a, [w8]+=%ADDR%, w4, [w10]+=%ADDR%, w6

[comp_mac_start_acca_reverse_resume]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=leave contents accumulator A untouched and prefetch last operands
code0=movsac a, [w8]-=%ADDR%, w4, [w10]-=%ADDR%, w6

[comp_mac_start_accb_clear_no_prefetch]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=clear accumulator B without prefetch of operands
code0=clr b

[comp_mac_start_accb_clear_prefetch]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=clear accumulator B and prefetch first operands
code0=clr b, [w8]+=%ADDR%, w4, [w10]+=%ADDR%, w6

[comp_mac_start_accb_reverse_clear]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=clear accumulator B and prefetch last operands
code0=clr b, [w8]-=%ADDR%, w4, [w10 + #%FO*ADDR%]-=%ADDR%, w6

[comp_mac_start_accb_resume]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=leave contents of accumulator B untouched and prefetch first operands
code0=movsac b, [w8]+=%ADDR%, w4, [w10]+=%ADDR%, w6

[comp_mac_start_accb_reverse_resume]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=leave contents of accumulator B untouched and prefetch last operands
code0=movsac b, [w8]-=%ADDR%, w4, [w10]-=%ADDR%, w6

[comp_mac_loop_a_term_acca]
filter_order_loop=a
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply control output (n-%INDEX%) from the delay line with coefficient A%INDEX%
code0=mac w4*w6, a, [w8]+=%ADDR%, w4, [w10]+=%ADDR%, w6

[comp_mac_loop_a_term_reverse_acca]
filter_order_loop=a
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply control output (n-%FO-INDEX%) from the delay line with coefficient A%FO-INDEX%
code0=mac w4*w6, a, [w8]-=%ADDR%, w4, [w10]-=%ADDR%, w6

[comp_mac_loop_a_term_accb]
filter_order_loop=a
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply control output (n-%INDEX%) from the delay line with coefficient A%INDEX%
code0=mac w4*w6, b, [w8]+=%ADDR%, w4, [w10]+=%ADDR%, w6

[comp_mac_loop_a_term_reverse_accb]
filter_order_loop=a
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply control output (n-%FO-INDEX%) from the delay line with coefficient A%FO-INDEX%
code0=mac w4*w6, b, [w8]-=%ADDR%, w4, [w10]-=%ADDR%, w6

[comp_mac_loop_b_term_acca]
filter_order_loop=b
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate error input (n-%INDEX%) from the delay line with coefficient B%INDEX% and prefetch next operands
code0=mac w4*w6, a, [w8]+=%ADDR%, w4, [w10]+=%ADDR%, w6

[comp_mac_loop_b_term_reverse_acca]
filter_order_loop=b
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate error input (n-%FO-INDEX%) from the delay line with coefficient B%FO-INDEX% and prefetch next operands
code0=mac w4*w6, a, [w8]-=%ADDR%, w4, [w10]-=%ADDR%, w6

[comp_mac_loop_b_term_accb]
filter_order_loop=b
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate error input (n-%INDEX%) from the delay line with coefficient B%INDEX% and prefetch next operands
code0=mac w4*w6, b, [w8]+=%ADDR%, w4, [w10]+=%ADDR%, w6

[comp_mac_loop_b_term_reverse_accb]
filter_order_loop=b
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate error input (n-%FO-INDEX%) from the delay line with coefficient B%FO-INDEX% and prefetch next operands
code0=mac w4*w6, b, [w8]-=%ADDR%, w4, [w10]-=%ADDR%, w6

[comp_mac_end_acca]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate last control output with coefficient of the delay line (no more prefetch)
code0=mac w4*w6, a

[comp_mac_end_accb]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate last error input with coefficient of the delay line (no more prefetch)
code0=mac w4*w6, b

[comp_backward_norm_acca]
head_comment=%SEPARATOR%; Backward normalization of recent result
cycles=2
lines=2
comment0=%EMPTY%
code0=mov [w0 + #offPostShiftA], w6
code1=sftac a, w6

[comp_backward_norm_accb]
head_comment=%SEPARATOR%; Backward normalization of recent result
cycles=2
lines=2
comment0=%EMPTY%
code0=mov [w0 + #offPostShiftB], w6
code1=sftac b, w6

[comp_backward_norm_coeff_scaler_acca]
head_comment=%SEPARATOR%; Initialize Scale-factor and multiply
cycles=2
lines=2
comment0=%EMPTY%
code0=mov [w0 + #offPostScaler],  w6
code1=mpy w4*w6, a

[comp_mac_store_acca]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=store most recent accumulator result in working register
code0=sac.r a, w4

[comp_mac_store_accb]
head_comment=\n; Backwards normalization of the controller output
cycles=1
lines=1
comment0=store most recent accumulator result in working register
code0=sac.r b, w4

[comp_mac_load32b_a]
head_comment=%EMPTY%
cycles=3
lines=3
comment=%EMPTY%
code0=mov [w0 + #offACCxU], accau
code1=mov [w0 + #offACCxH], accah
code2=mov [w0 + #offACCxL], accal

[comp_mac_load32b_accb]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=%EMPTY%
code0=mov [w0 + #offACCxU], accbu
code1=mov [w0 + #offACCxH], accbh
code2=mov [w0 + #offACCxL], accbl

[comp_mac_store32b_a]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=%EMPTY%
code0=mov accau, [w0 + #ACCxU]
code1=mov accah, [w0 + #ACCxH]
code2=mov accal, [w0 + #ACCxL]

[comp_mac_store32b_accb]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=%EMPTY%
code0=mov accbu, [w0 + #ACCxU]
code1=mov accbh, [w0 + #ACCxH]
code2=mov accbl, [w0 + #ACCxL]

[comp_add_acca_to_accb]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add accumulator a to accumulator b
code0=add b

[comp_add_accb_to_acca]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add accumulator b to accumulator a
code0=add a

[comp_writeback]
head_comment=%SEPARATOR%; Write control output value to target
cycles=2
lines=2
comment0=move pointer to target in to working register
comment1=move control output into target address
code0=mov [w0 + #offTargetRegister], w8
code1=mov w4, [w8]

[comp_writeback_with_alt_target_switch]
head_comment=%SEPARATOR%; Write control output value to target
cycles=4
lines=4
comment0=move pointer to target to working register
comment1=if SWAP TARGET option is enabled, execute next instruction
comment2=move pointer to alternate target to working register
comment3=move control output into target address
code0=mov [w0 + #offTargetRegister], w8
code1=btsc w12, #NPMZ16_STATUS_SWAP_TARGET
code2=mov [w0 + #offAltTargetRegister], w8
code3=mov w4, [w8]

[comp_writeback_ssm]
head_comment=%SEPARATOR%; Add spread specturm modulator
cycles=3
lines=3
comment0=%EMPTY%
code0=mov [w0 + #offTargetRegister], w8
code1=mov [w0 + #offSSM_Factor], w6
code2=mpy w4*w6, [w8]

[adc_trigger_a_placement]
head_comment=%SEPARATOR%; Update ADC trigger A position
cycles=5
lines=5
comment0=%EMPTY%
code0=asr w4, #1, w6
code1=mov [w0 + #offADCTriggerAOffset], w8
code2=add w6, w8, w10
code3=mov [w0 + #offADCTriggerARegister], w8
code4=mov w10, [w8]

[adc_trigger_b_placement]
head_comment=%SEPARATOR%; Update ADC trigger B position
cycles=4
lines=4
comment0=%EMPTY%
code0=mov [w0 + #offADCTriggerBOffset], w8
code1=add w6, w8, w10
code2=mov [w0 + #offADCTriggerBRegister], w8
code3=mov w10, [w8]

[return]
head_comment=%SEPARATOR%; End of routine
cycles=1
lines=2
comment0=%EMPTY%
code0=return
code1=%SEPARATOR%

[end]
head_comment=%SEPARATOR%; End of file
cycles=1
lines=2
comment0=%EMPTY%
code0=.end
code1=%SEPARATOR%

;
; Specific projected floating point instruction blocks
;

[fscl_context_save_mac_registers]
item_loop=wreg_usage
head_comment=%EMPTY%
cycles=5
lines=5
comment0=save working registers used for MAC operations (w4, w5, w6, w8, w10)
code0=push w4
code1=push w5
code2=push w6
code3=push w8
code4=push w10

[fscl_context_restore_mac_registers]
item_loop=wreg_usage
head_comment=%EMPTY%
cycles=5
lines=5
comment0=restore working registers used for MAC operations (w4, w5, w6, w8, w10)
code0=pop w4
code1=pop w5
code2=pop w6
code3=pop w8
code4=pop w10

[fscl_comp_mac_start_clear]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=2
lines=2
comment0=clear both accumulators and prefetch first operands
code0=clr b, [w8]+=%ADDR%, w5
code1=clr a, [w8]+=%ADDR*2%, w4, [w10]+=%ADDR%, w6

[fscl_comp_mac_start_resume]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=2
lines=2
comment0=clear accumulator A, leave contents of accumulator B unchanged and prefetch first operands
code0=movsac b, [w8]+=%ADDR%, w5
code1=clr a, [w8]+=%ADDR*2%, w4, [w10]+=%ADDR%, w6

[fscl_comp_mac_first]
head_comment=%EMPTY%
cycles=4
lines=4
comment0=multiply control output (n-%INDEX%) from the delay line with coefficient X%INDEX%
code0=mpy w4*w6, a, [w8]+=%ADDR*2%, w4, [w10]+=%ADDR%, w6
code1=sftac a, w5
code2=add b

[fscl_comp_mac_a_loop]
filter_order_loop=as
head_comment=%EMPTY%
cycles=4
lines=4
comment0=multiply control output (n-%INDEX%) from the delay line with coefficient X%INDEX%
code0=mov [w8 - #%ADDR*3%], w5
code1=mpy w4*w6, a, [w8]+=%ADDR*2%, w4, [w10]+=%ADDR%, w6
code2=sftac a, w5
code3=add b

[fscl_comp_mac_b_loop]
filter_order_loop=bs
head_comment=%EMPTY%
cycles=4
lines=4
comment0=multiply control output (n-%INDEX%) from the delay line with coefficient X%INDEX%
code0=mov [w8 - #%ADDR*3%], w5
code1=mpy w4*w6, a, [w8]+=%ADDR*2%, w4, [w10]+=%ADDR%, w6
code2=sftac a, w5
code3=add b

[fscl_comp_mac_end]
head_comment=%EMPTY%
cycles=4
lines=4
comment0=multiply & accumulate last control output with coefficient of the delay line (no more prefetch)
code0=mov [w8 - #%ADDR*3%], w5
code1=mpy w4*w6, a
code2=sftac a, w5
code3=add b


___________________________________________________
(C)2020, Microchipt Technology Inc.
