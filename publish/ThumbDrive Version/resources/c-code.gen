[generic]
Name=C-Source and Header Generator Script
Description=This scriptprovides C-source and header files for user-tailored SMPS control loops based on DSP assembly code modules templates generated using the DCLD SDK
Author=Andreas Reiter - M91406
Version=2.0.13
Date=07/30/2020

[history]
count=21
0=11/08/19;1.0.0;Initial version after moving C-sources and headers from application code to external script
1=01/10/20;1.1.0;Added support for cascaded functions. This allows the assembly routine to call another controller or user-defined function extension code module.\r\nAdded pointers to alternate source and terget register supporting bi-directional control and advanced adaptive control methods
2=03/18/2020;1.1.1;Changed function call name of controller initialization from xxx_Init to xxx_Initialize to stay consistent with other generic code modules
3=03/24/2020;1.1.2;Added grouping structures to NPNZ16b_t data structure
4=03/25/2020;1.1.3;Added DCLD Version Key macro to npnz16b.h header file, This allows to identify the library version in user code.
5=03/25/2020;1.1.4;Fixed bug in AGM related defines.
6=03/25/2020;1.1.5;Fixed typo in CGS_VERSION_DATE token
7=03/26/2020;2.0.0;Introduction of unified, 32-bit wide coefficient number format
8=03/27/2020;2.0.1;Separated input and output ports and added individual normalization scaling parameters
9=03/30/2020;2.0.2;Renamed data structure group 'TriggerControl' to 'ADC TriggerControl'
10=03/31/2020;2.0.3;Added P-Term controller for plant transfer function measurement support
11=04/03/2020;2.0.4;Added Token IDs for enhanced code generation option support
12=04/21/2020;2.0.5;Added user-defined function pointer to observer function to AGC declarations
13=04/23/2020;2.0.6;Fixed comments in C-Source file and bug not updating DCD version code
14=04/24/2020;2.0.7;Bugfix: ptrAgcObserverFunction was declared as 16-bit pointer, which causes conflicts with declaration is user code. Type has been changed to uint16_t.
15=04/27/2020;2.0.8;Bugfix: Library header enumeration NPNZ_STATUS_FLAGS_t caused the MPLAB X real time parser to fail in resolving the label. Thus it was renamed to NPNZ_STATUS_FLAGS_e, eventually resolving the problem
16=05/20/2020;2.0.9;Added alternate control output mirror feature
17=05/20/2020;2.0.10;Changed port offset and norm scaler to signed numbers
18=07/08/2020;2.0.11;Added new data provider for raw and compensated control input reading
19=07/15/2020;2.0.12;Changed data structure declarations to match C99 standards
20=07/30/2020;2.0.13;Renamed status flags flt_clamp_min and flt_clamp_max to lower_saturation_event and upper_saturation_event


[tokens]
count=18
0=%EMPTY%
1=%SPACE%
2=%IDENT%
3=%DATA_TYPE_FRACTIONAL%
4=%DATA_TYPE_INT32%
5=%FILE_NAME_PATTERN%
6=%PREFIX%
7=%FILTER_ORDER%
8=%FILTER_ORDER+1%
9=%STRUCTURE_LABEL%
10=%CGS_VERSION%
11=%CGS_VERSION_DATE%
12=%APP_PRODUCT_NAME%
13=%APP_PRODUCT_VERSION%
14=%SUPPORT_URL%
15=%VENDOR_URL%
16=%TOOL_HOME_URL%
17=%ASM_INCLUDE_FILE%

[option_ids]
count=41
0=%{(1100)}%;context_management
1=%{(1101)}%;context_shadow
2=%{(1102)}%;context_mac_wreg
3=%{(1103)}%;context_acc
4=%{(1104)}%;context_acc_a
5=%{(1105)}%;context_acc_b
6=%{(1106)}%;context_core_config
7=%{(1107)}%;context_core_status
8=%{(1200)}%;option_enable
9=%{(1201)}%;option_store_reload_acc
10=%{(1202)}%;option_core_config
11=%{(1203)}%;option_enable_switch
12=%{(1204)}%;option_enable_switch_always_read
13=%{(1205)}%;option_error_normalization
14=%{(1206)}%;option_adc_trigger_a_placement
15=%{(1207)}%;option_adc_trigger_b_placement
16=%{(1208)}%;option_cascade_call
17=%{(1209)}%;option_add_p-term
18=%{(1300)}%;data_interface_enable
19=%{(1301)}%;data_interface_alt_input
20=%{(1302)}%;data_interface_alt_output
21=%{(1303)}%;data_interface_copy_to_alt_output
22=%{(1400)}%;data_provider_enable
23=%{(1401)}%;data_provider_control_input_raw
24=%{(1402)}%;data_provider_control_input_compensated
25=%{(1403)}%;data_provider_control_error
26=%{(1404)}%;data_provider_control_output
27=%{(1500)}%;anti_windup_enable
28=%{(1501)}%;anti_windup_max
29=%{(1502)}%;anti_windup_max_status_flag
30=%{(1503)}%;anti_windup_min
31=%{(1504)}%;anti_windup_min_status_flag
32=%{(1505)}%;anti_windup_debounce_flag
33=%{(1506)}%;anti_windup_saturation_flag
34=%{(1600)}%;feedback_conditioning_enable
35=%{(1601)}%;feedback_offset_compensation
36=%{(1602)}%;bi_directional_feedback_flag
37=%{(1800)}%;agc_enable
38=%{(1801)}%;agc_enable_switch
39=%{(1802)}%;agc_get_factor_function_call
40=%{(9001)}%;library_data_structure_include


[labels]
%SUPPORT_URL%=https://www.microchip.com/SMPS/
%VENDOR_URL%=https://www.microchip.com/
%TOOL_HOME_URL%=https://areiter128.github.io/DCLD
%STRUCTURE_LABEL%=NPNZ16b


[library_header]
count=393
line0=      /* *********************************************************************************
line1=%SPACE%* %APP_PRODUCT_NAME%, Version %APP_PRODUCT_VERSION%
line2=%SPACE%* *********************************************************************************
line3=%SPACE%* Generic library header for z-domain compensation filter assembly functions
line4=%SPACE%* CGS Version: %CGS_VERSION%
line5=%SPACE%* CGS Date:    %CGS_VERSION_DATE%
line6=%SPACE%* ********************************************************************************/
line7=#ifndef __SPECIAL_FUNCTION_LAYER_LIB_NPNZ16B_H__
line8=#define __SPECIAL_FUNCTION_LAYER_LIB_NPNZ16B_H__
line9=%EMPTY%
line10=#include <xc.h> // include processor files - each processor file is guarded
line11=#include <dsp.h> // include DSP data types (e.g. fractional)
line12=#include <stdint.h> // include standard integer number data types
line13=#include <stddef.h> // include standard definition data types
line14=#include <stdbool.h> // include standard boolean data types (true/false)
line15=%EMPTY%
line16=      /*@@DCLD_VERSION macro
line17=%SPACE%* *************************************************************************************************
line18=%SPACE%* Summary:
line19=%SPACE%* Generic macro allowing to identify the file version of 'npnz16b.h'
line20=%SPACE%* 
line21=%SPACE%* Description:
line22=%SPACE%* This version key represents the product version of DCLD as integer number
line23=%SPACE%* of the form [MAJOR][MINOR][REVISION] => version 0.9.3.xxx would be shown as 903.
line24=%SPACE%* User code can check if the file version is compliant with the proprietary user 
line25=%SPACE%* code by using pre-compiler directives such as 
line26=%SPACE%* 
line27=%SPACE%* #if (__DCLD_VERSION > 908)
line28=%SPACE%*  #pragma message "This code has not been tested with the recently included version of npnz16b.h"
line29=%SPACE%* #endif
line30=%SPACE%*  
line31=%SPACE%* *************************************************************************************************/
line32=%EMPTY%
line33=#ifndef __DCLD_VERSION
line34=%IDENT%#define __DCLD_VERSION    %DCLD_VERSION_CODE%
line35=#endif  // end of __DCLD_VERSION
line36=%EMPTY%
line37=      /*@@NPNZ_STATUS_t data object
line38=%SPACE%* *************************************************************************************************
line39=%SPACE%* Summary:
line40=%SPACE%* Common Controller Status and Control Flag Bits
line41=%SPACE%* 
line42=%SPACE%* Description:
line43=%SPACE%* The 16-bit wide NPNZ_STATUS_t data object holds status and control bits for  
line44=%SPACE%* monitoring and control of the NPNZ16b_t controller during runtime. The lower 8 bit
line45=%SPACE%* of the status word are used for status indication while the upper 8 bit are used
line46=%SPACE%* by control bits.
line47=%SPACE%* 
line48=%SPACE%* For enhanced programming convenience definitions of status and control flags are 
line49=%SPACE%* provided
line50=%SPACE%*  
line51=%SPACE%* *************************************************************************************************/
line52=%EMPTY%
line53=      /* Status word values */
line54=#define NPNZ16_CONTROL_STATUS_CLEAR     0b0000000000000000
line55=#define NPNZ16_CONTROL_SATUATION_MSK    0b0000000000000011
line56=#define NPNZ16_CONTROL_LSAT_ACTIVE      0b0000000000000001
line57=#define NPNZ16_CONTROL_LSAT_CLEAR       0b0000000000000000
line58=#define NPNZ16_CONTROL_USAT_ACTIVE      0b0000000000000010
line59=#define NPNZ16_CONTROL_USAT_CLEAR       0b0000000000000000
line60=#define NPNZ16_CONTROL_AGC_DISABLE      0b0000000000000000
line61=#define NPNZ16_CONTROL_AGC_ENABLED      0b0000100000000000
line62=#define NPNZ16_CONTROL_TARGET_DEFAULT   0b0000000000000000
line63=#define NPNZ16_CONTROL_TARGET_SWAPED    0b0001000000000000
line64=#define NPNZ16_CONTROL_SOURCE_DEFAULT   0b0000000000000000
line65=#define NPNZ16_CONTROL_SOURCE_SWAPED    0b0010000000000000
line66=#define NPNZ16_CONTROL_INV_INPUT_OFF    0b0000000000000000
line67=#define NPNZ16_CONTROL_INV_INPUT_ON     0b0100000000000000
line68=#define NPNZ16_CONTROL_ENABLE_OFF       0b0000000000000000
line69=#define NPNZ16_CONTROL_ENABLE_ON        0b1000000000000000
line70=%EMPTY%
line71=      /* Status flags (bit-field) */
line72=typedef enum {
line73=%IDENT%NPNZ_SAT_CLEAR   = 0b0,     // No saturation condition detected
line74=%IDENT%NPNZ_SAT_ACTIVE = 0b1,      // Saturation limit violation detected
line75=}NPNZ_CONTROL_STATUS_SATURATION_e; // NPNZ output saturation status bits
line76=extern volatile NPNZ_CONTROL_STATUS_SATURATION_e npnzEnumControlStatusSaturation;
line77=%EMPTY%
line78=      /* Control flags (bit-field) */
line79=typedef enum {
line80=%IDENT%NPNZ_AGC_DISABLED   = 0b0,  // Adaptive Gain Modulation is disabled
line81=%IDENT%NPNZ_AGC_ENABLED = 0b1      // Adaptive Gain Modulation is enabled
line82=}NPNZ_CONTROL_AGC_ENABLE_e;     // Adaptive Gain Modulation control bits
line83=extern volatile NPNZ_CONTROL_AGC_ENABLE_e npnzEnumControlAgcEnable;
line84=%EMPTY%
line85=typedef enum {
line86=%IDENT%NPNZ_SOURCE_DEFAULT = 0b0,  // Controller source ports are not swapped, primary source is active input
line87=%IDENT%NPNZ_SOURCE_SWAPED = 0b1    // Controller source ports are swapped, alternate source is active input
line88=}NPNZ_CONTROL_SOURCE_SWAP_e;    // NPNZ Source Port Swap Control bits
line89=extern volatile NPNZ_CONTROL_SOURCE_SWAP_e npnzEnumControlSourceSwap;
line90=%EMPTY%
line91=typedef enum {
line92=%IDENT%NPNZ_TARGET_DEFAULT = 0b0,  // Controller target ports are not swapped, primary source is active output
line93=%IDENT%NPNZ_TARGET_SWAPED = 0b1    // Controller target ports are swapped, alternate target is active output
line94=}NPNZ_CONTROL_TARGET_SWAP_e;    // NPNZ Target Port Swap Control bits
line95=extern volatile NPNZ_CONTROL_TARGET_SWAP_e npnzEnumControlTargetSwap;
line96=%EMPTY%
line97=typedef enum {
line98=%IDENT%NPNZ_INPUT_DEFAULT = 0b0,   // Controller error value is not inverted
line99=%IDENT%NPNZ_INPUT_INVERTED = 0b1   // Controller error value is inverted
line100=}NPNZ_CONTROL_INPUT_INV_e;      // NPNZ Error Value Inversion Control bit
line101=extern volatile NPNZ_CONTROL_INPUT_INV_e npnzEnumControlInputInversion;
line102=%EMPTY%
line103=typedef enum {
line104=%IDENT%NPNZ_DISABLED = 0b0,        // Controller error value is not inverted
line105=%IDENT%NPNZ_ENABLED = 0b1          // Controller error value is inverted
line106=}NPNZ_CONTROL_ENABLE_e;         // NPNZ Controller Enable Control bit
line107=extern volatile NPNZ_CONTROL_ENABLE_e npnzEnumControlEnable;
line108=%EMPTY%
line109=      /* Controller status data structure */
line110=typedef struct NPNZ_STATUS_s {
line111=%IDENT%union {
line112=%IDENT%struct {
line113=%IDENT%%IDENT%volatile bool lower_saturation_event : 1; // Bit 0: control loop is clamped at minimum output level
line114=%IDENT%%IDENT%volatile bool upper_saturation_event : 1; // Bit 1: control loop is clamped at maximum output level
line115=%IDENT%%IDENT%volatile unsigned : 1; // Bit 2: reserved
line116=%IDENT%%IDENT%volatile unsigned : 1; // Bit 3: reserved
line117=%IDENT%%IDENT%volatile unsigned : 1; // Bit 4: reserved
line118=%IDENT%%IDENT%volatile unsigned : 1; // Bit 5: reserved
line119=%IDENT%%IDENT%volatile unsigned : 1; // Bit 6: reserved
line120=%IDENT%%IDENT%volatile unsigned : 1; // Bit 7: reserved
line121=%IDENT%%IDENT%volatile unsigned : 1; // Bit 8: reserved
line122=%IDENT%%IDENT%volatile unsigned : 1; // Bit 9: reserved
line123=%IDENT%%IDENT%volatile unsigned : 1; // Bit 11: reserved
line124=%IDENT%%IDENT%volatile bool agc_enabled: 1; // Bit 11: when set, Adaptive Gain Control Modulation is enabled
line125=%IDENT%%IDENT%volatile bool swap_target: 1; // Bit 12: when set, AltTarget is used as data output of controller
line126=%IDENT%%IDENT%volatile bool swap_source: 1; // Bit 13: when set, AltSource is used as data input to controller
line127=%IDENT%%IDENT%volatile bool invert_input: 1; // Bit 14: when set, most recent error input value to controller is inverted
line128=%IDENT%%IDENT%volatile bool enabled : 1; // Bit 15: enables/disables control loop execution
line129=%IDENT%} __attribute__((packed))bits;    // Controller status bit-field for direct bit access
line130=%IDENT%volatile uint16_t value;          // Controller status full register access
line131=%IDENT%};
line132=} __attribute__((packed)) NPNZ_STATUS_t; // Controller status data structure
line133=%EMPTY%
line134=      /*@@NPNZ_PORTS_t data object
line135=%SPACE%* *************************************************************************************************
line136=%SPACE%* Summary:
line137=%SPACE%* Filter Coefficient Arrays, Number Format Handling and Input/Output History Parameters
line138=%SPACE%* 
line139=%SPACE%* Description:
line140=%SPACE%* The NPNZ_PORTS_t data object holds a list of nested NPNZ_PORT_t data objects, each
line141=%SPACE%* defining an individual controller input or output port. The NPNZ16b_t data objects defines 
line142=%SPACE%* up to two input and two output ports of type struct NPNZ_PORT_t and one additional 
line143=%SPACE%* pointer to an external, user-defined 16-bit reference source variable. Each port of type 
line144=%SPACE%* struct NPNZ_PORT_t declares its individual source/target memory address, normalization 
line145=%SPACE%* scaler and offset:
line146=%SPACE%* 
line147=%SPACE%*  - Primary Source:   common feedback input object
line148=%SPACE%*  - Alternate Source: additional, alternate feedback input object (optional)
line149=%SPACE%*  - Primary Target:   common control output target object 
line150=%SPACE%*  - Alternate Target: additional, alternate control output target object (optional)
line151=%SPACE%*  - Control Reference: pointer to external 16-bit reference source variable
line152=%SPACE%* 
line153=%SPACE%* *************************************************************************************************/
line154=%EMPTY%
line155=      /* Controller Input/Output Port */
line156=typedef struct NPNZ_PORT_s{
line157=%IDENT%volatile uint16_t* ptrAddress; // Pointer to register or variable where the value is read from (e.g. ADCBUFx) or written to (e.g. PGxDC)
line158=%IDENT%volatile int16_t   NormScaler; // Bit-shift scaler of the Q15 normalization factor
line159=%IDENT%volatile fractional NormFactor; // Q15 normalization factor
line160=%IDENT%volatile int16_t   Offset; // Value/signal offset of this port
line161=} __attribute__((packed)) NPNZ_PORT_t;
line162=%EMPTY%
line163=      /* List of Controller Input/Output Ports */
line164=typedef struct NPNZ_PORTS_s{
line165=%EMPTY%
line166=%IDENT%volatile struct NPNZ_PORT_s Source; // Primary data input port declaration
line167=%IDENT%volatile struct NPNZ_PORT_s AltSource; // Secondary data input port declaration
line168=%IDENT%volatile struct NPNZ_PORT_s Target; // Primary data output port declaration
line169=%IDENT%volatile struct NPNZ_PORT_s AltTarget; // Secondary data output port declaration
line170=%IDENT%volatile uint16_t* ptrControlReference; // Pointer to global variable of input register holding the controller reference value (e.g. uint16_t my_ref)
line171=%EMPTY%
line172=} __attribute__((packed)) NPNZ_PORTS_t; // Controller block input and output port definitions
line173=%EMPTY%
line174=      /*@@NPNZ_FILTER_PARAMS_t data object
line175=%SPACE%* *************************************************************************************************
line176=%SPACE%* Summary:
line177=%SPACE%* Filter Coefficient Arrays, Number Format Handling and Input/Output History Parameters
line178=%SPACE%* 
line179=%SPACE%* Description:
line180=%SPACE%* The NPNZ_FILTER_PARAMS_t data object holds all configuration parameters of the compensation
line181=%SPACE%* filter. These parameters include pointers to external arrays of filter coefficients, error
line182=%SPACE%* and control history as well as number format normalization parameters like pre- and post-
line183=%SPACE%* scalers.
line184=%SPACE%*  
line185=%SPACE%* *************************************************************************************************/
line186=%EMPTY%
line187=typedef struct NPNZ_FILTER_PARAMS_s{
line188=%EMPTY%
line189=%IDENT%volatile int32_t* ptrACoefficients; // Pointer to A coefficients located in X-space
line190=%IDENT%volatile int32_t* ptrBCoefficients; // Pointer to B coefficients located in X-space
line191=%IDENT%volatile fractional* ptrControlHistory; // Pointer to n delay-line samples located in Y-space with first sample being the most recent
line192=%IDENT%volatile fractional* ptrErrorHistory; // Pointer to n+1 delay-line samples located in Y-space with first sample being the most recent
line193=%EMPTY%
line194=%IDENT%// Array size information
line195=%IDENT%volatile uint16_t ACoefficientsArraySize; // Size of the A coefficients array in X-space
line196=%IDENT%volatile uint16_t BCoefficientsArraySize; // Size of the B coefficients array in X-space
line197=%IDENT%volatile uint16_t ControlHistoryArraySize; // Size of the control history array in Y-space
line198=%IDENT%volatile uint16_t ErrorHistoryArraySize; // Size of the error history array in Y-space
line199=%EMPTY%
line200=%IDENT%// Feedback scaling Input/Output Normalization
line201=%IDENT%volatile int16_t normPreShift; // Normalization of ADC-resolution to Q15 (R/W)
line202=%IDENT%volatile int16_t normPostShiftA; // Normalization of A-term control output to Q15 (R/W)
line203=%IDENT%volatile int16_t normPostShiftB; // Normalization of B-term control output to Q15 (R/W)
line204=%IDENT%volatile int16_t normPostScaler; // Control output normalization factor (Q15) (R/W)
line205=%EMPTY%
line206=%IDENT%// P-Term Coefficients (for plant measurements only)
line207=%IDENT%volatile int16_t PTermScaler; // Q15 P-Term Coefficient Bit-Shift Scaler (R/W)
line208=%IDENT%volatile int16_t PTermFactor; // Q15 P-Term Coefficient Factor (R/W)
line209=} __attribute__((packed)) NPNZ_FILTER_PARAMS_t; // Filter parameters such as pointer to history and coefficient arrays and number scaling
line210=%EMPTY%
line211=      /*@@NPNZ_LIMITS_t data object
line212=%SPACE%* *************************************************************************************************
line213=%SPACE%* Summary:
line214=%SPACE%* System Anti-Windup (Output Clamping) Thresholds
line215=%SPACE%* 
line216=%SPACE%* Description:
line217=%SPACE%* The NPNZ_LIMITS_t data object holds all parameters required to automatically clamp the 
line218=%SPACE%* most recent control output to user-defined thresholds. This data type allows the 
line219=%SPACE%* definition of individual output value minima and maxima for the NPNZ controller primary 
line220=%SPACE%* and alternate output port.
line221=%SPACE%* 
line222=%SPACE%* This feature is optional and needs to be enabled, configured and managed manually in
line223=%SPACE%* user code.
line224=%SPACE%*  
line225=%SPACE%* *************************************************************************************************/
line226=%EMPTY%
line227=typedef struct NPNZ_LIMITS_s{
line228=%EMPTY%
line229=%IDENT%volatile int16_t MinOutput; // Minimum output value used for clamping (R/W)
line230=%IDENT%volatile int16_t MaxOutput; // Maximum output value used for clamping (R/W)
line231=%IDENT%volatile int16_t AltMinOutput; // Alternate minimum output value used for clamping (R/W)
line232=%IDENT%volatile int16_t AltMaxOutput; // Alternate maximum output value used for clamping (R/W)
line233=%EMPTY%
line234=} __attribute__((packed)) NPNZ_LIMITS_t; // Input and output clamping values
line235=%EMPTY%
line236=      /*@@NPNZ_ADC_TRGCTRL_t data object
line237=%SPACE%* *************************************************************************************************
line238=%SPACE%* Summary:
line239=%SPACE%* Automated ADC Trigger handling
line240=%SPACE%* 
line241=%SPACE%* Description:
line242=%SPACE%* The NPNZ_ADC_TRGCTRL_t data object holds all parameters required to automatically position
line243=%SPACE%* ADC triggers based on the most recent control output. This feature is used in voltage or
line244=%SPACE%* average current mode control to automatically track average values in triangular feedback
line245=%SPACE%* signal waveforms.
line246=%SPACE%* 
line247=%SPACE%* This feature is optional and needs to be enabled, configured and managed manually in
line248=%SPACE%* user code.
line249=%SPACE%*  
line250=%SPACE%* *************************************************************************************************/
line251=%EMPTY%
line252=typedef struct NPNZ_ADC_TRGCTRL_s{
line253=%EMPTY%
line254=%IDENT%volatile uint16_t* ptrADCTriggerARegister; // Pointer to ADC trigger #1 register (e.g. TRIG1)
line255=%IDENT%volatile uint16_t ADCTriggerAOffset; // ADC trigger #1 offset to compensate propagation delays
line256=%IDENT%volatile uint16_t* ptrADCTriggerBRegister; // Pointer to ADC trigger #2 register (e.g. TRIG2)
line257=%IDENT%volatile uint16_t ADCTriggerBOffset; // ADC trigger #2 offset to compensate propagation delays
line258=%EMPTY%
line259=} __attribute__((packed)) NPNZ_ADC_TRGCTRL_t; // Automatic ADC trigger placement options for ADC Trigger A and B
line260=%EMPTY%
line261=      /*@@NPNZ_DATA_PROVIDERS_t data object
line262=%SPACE%* *************************************************************************************************
line263=%SPACE%* Summary:
line264=%SPACE%* Data Provider Target Memory Addresses
line265=%SPACE%* 
line266=%SPACE%* Description:
line267=%SPACE%* The NPNZ_DATA_PROVIDERS_t data object holds pointers to external, user-defined, global
line268=%SPACE%* variables allowing the NPNZ controller to push internal data to external, user-defined,
line269=%SPACE%* global variables during the execution of the NPNZ controller, resulting in an automated
line270=%SPACE%* updated of user-code variable values during runtime.
line271=%SPACE%* 
line272=%SPACE%* This feature is optional and needs to be enabled, configured and managed manually in
line273=%SPACE%* user code.
line274=%SPACE%*  
line275=%SPACE%* *************************************************************************************************/
line276=%EMPTY%
line277=typedef struct NPNZ_DATA_PROVIDERS_s{
line278=%EMPTY%
line279=%IDENT%volatile uint16_t* ptrDProvControlInput; // Pointer to external data buffer of most recent, raw control input
line280=%IDENT%volatile uint16_t* ptrDProvControlInputCompensated; // Pointer to external data buffer of most recent, compensated control input
line281=%IDENT%volatile uint16_t* ptrDProvControlError; // Pointer to external data buffer of most recent control error
line282=%IDENT%volatile uint16_t* ptrDProvControlOutput; // Pointer to external data buffer of most recent control output
line283=%EMPTY%
line284=} __attribute__((packed)) NPNZ_DATA_PROVIDERS_t; // Automated data sources pushing data points to user-defined variables
line285=%EMPTY%
line286=      /*@@NPNZ_CASCADE_TRG_t data object
line287=%SPACE%* *************************************************************************************************
line288=%SPACE%* Summary:
line289=%SPACE%* Cascaded Function Call Parameters
line290=%SPACE%* 
line291=%SPACE%* Description:
line292=%SPACE%* The NPNZ_CASCADE_TRG_t data object holds all parameters required to perform cascaded 
line293=%SPACE%* function call triggers. When enabled, the NPNZ controller can automatically call any
line294=%SPACE%* user-defined function after the execution of the control loop. This data object declares
line295=%SPACE%* a function pointer <ptrCascadedFunction> and one additional, 16-bit wide function parameter
line296=%SPACE%* <CascadedFunctionParam>.
line297=%SPACE%* 
line298=%SPACE%* This feature is optional and needs to be enabled, configured and managed manually in
line299=%SPACE%* user code.
line300=%SPACE%*  
line301=%SPACE%* *************************************************************************************************/
line302=%EMPTY%
line303=typedef struct NPNZ_CASCADE_TRG_s{
line304=%EMPTY%
line305=%IDENT%volatile uint16_t ptrCascadedFunction; // Pointer to Function which should be called at the end of the control loop
line306=%IDENT%volatile uint16_t CascadedFunctionParam; // Parameter of function called (can be a pointer to a data structure)
line307=%EMPTY%
line308=} __attribute__((packed)) NPNZ_CASCADE_TRG_t; // Cascade triggers with parameters for next function call
line309=%EMPTY%
line310=      /*@@NPNZ_GAIN_CONTROL_t data object
line311=%SPACE%* *************************************************************************************************
line312=%SPACE%* Summary:
line313=%SPACE%* Adaptive Gain Control Modulation Parameters
line314=%SPACE%* 
line315=%SPACE%* Description:
line316=%SPACE%* The NPNZ_GAIN_CONTROL_t data object holds all parameters required to perform real-time 
line317=%SPACE%* gain modulation of the z-domain feedback loop. The loop gain is modulated by multiplying
line318=%SPACE%* the result of the NPNZ controller B-term with an additional scaling factor. This scaling
line319=%SPACE%* factor is represented by a fast floating point number, consisting of a factional factor
line320=%SPACE%* <AgcFactor> between -1 and 1 and an integer bit-shift scaler <AgcScaler>.
line321=%SPACE%* 
line322=%SPACE%* This feature is optional and needs to be enabled, configured and managed manually in
line323=%SPACE%* user code.
line324=%SPACE%*  
line325=%SPACE%* *************************************************************************************************/
line326=%EMPTY%
line327=typedef struct NPNZ_GAIN_CONTROL_s{
line328=%EMPTY%
line329=%IDENT%volatile uint16_t AgcScaler; // Bit-shift scaler of Adaptive Gain Modulation factor
line330=%IDENT%volatile fractional AgcFactor; // Q15 value of Adaptive Gain Modulation factor
line331=%IDENT%volatile fractional AgcMedian; // Q15 value of Adaptive Gain Modulation nominal operating point
line332=%IDENT%volatile uint16_t ptrAgcObserverFunction; // Function Pointer to Observer function updating the AGC modulation factor
line333=%EMPTY%
line334=} __attribute__((packed)) NPNZ_GAIN_CONTROL_t; // Parameter section for advanced control options
line335=%EMPTY%
line336=      /*@@NPNZ_USER_DATA_BUFFER_t data object
line337=%SPACE%* *************************************************************************************************
line338=%SPACE%* Summary:
line339=%SPACE%* User Data Space for Advanced Control Functions  
line340=%SPACE%* 
line341=%SPACE%* Description:
line342=%SPACE%* The NPNZ_USER_DATA_BUFFER_t data object reserves four word of additional data space for 
line343=%SPACE%* user parameters. These parameters may be handled by user code and are not assigned to any
line344=%SPACE%* specific, pre-defined functions.
line345=%SPACE%*  
line346=%SPACE%* *************************************************************************************************/
line347=%EMPTY%
line348=typedef struct NPNZ_USER_DATA_BUFFER_s{
line349=%EMPTY%
line350=%IDENT%volatile uint16_t usrParam1; // generic 16-bit wide, user-defined parameter #1 for advanced control options
line351=%IDENT%volatile uint16_t usrParam2; // generic 16-bit wide, user-defined parameter #2 for advanced control options
line352=%IDENT%volatile uint16_t usrParam3; // generic 16-bit wide, user-defined parameter #3 for advanced control options
line353=%IDENT%volatile uint16_t usrParam4; // generic 16-bit wide, user-defined parameter #4 for advanced control options
line354=%EMPTY%
line355=} __attribute__((packed)) NPNZ_USER_DATA_BUFFER_t; // Parameter section for advanced control options
line356=%EMPTY%
line357=      /*@@NPNZ16b_t data structure
line358=%SPACE%* *************************************************************************************************
line359=%SPACE%* Summary:
line360=%SPACE%* Global NPNZ controller data object  
line361=%SPACE%* 
line362=%SPACE%* Description:
line363=%SPACE%* The NPNZ16b_t data object holds all configuration, status, control and monitoring values 
line364=%SPACE%* of a z-domain lead-lag compensator based controller. All data types of this data object,
line365=%SPACE%* including floating, are scaled to a 16 bit number space, optimized for code execution on
line366=%SPACE%* Microchip dsPIC33 family of devices. Please refer to the description of nested data 
line367=%SPACE%* structures above for more information about nested data objects.
line368=%SPACE%*  
line369=%SPACE%* *************************************************************************************************/
line370=%EMPTY%
line371=typedef struct NPNZ16b_s {
line372=%EMPTY%
line373=%IDENT%volatile struct NPNZ_STATUS_s status; // Control Loop Status and Control flags
line374=%IDENT%volatile struct NPNZ_PORTS_s Ports; // Controller input and output ports
line375=%IDENT%volatile struct NPNZ_FILTER_PARAMS_s Filter; // Filter parameters such as pointer to history and coefficient arrays and number scaling
line376=%IDENT%volatile struct NPNZ_LIMITS_s Limits; // Input and output clamping values
line377=%IDENT%volatile struct NPNZ_ADC_TRGCTRL_s ADCTriggerControl; // Automatic ADC trigger placement options for ADC Trigger A and B
line378=%IDENT%volatile struct NPNZ_DATA_PROVIDERS_s DataProviders; // Automated data sources pushing recent data points to user-defined variables
line379=%IDENT%volatile struct NPNZ_CASCADE_TRG_s CascadeTrigger; // Cascade triggers with parameters for next function call
line380=%IDENT%volatile struct NPNZ_GAIN_CONTROL_s GainControl; // Parameter section for advanced control options
line381=%IDENT%volatile struct NPNZ_USER_DATA_BUFFER_s Advanced; // Parameter section for advanced user control options
line382=%EMPTY%
line383=} __attribute__((packed)) NPNZ16b_t; // Generic nPnZ Controller Object with 16-bit fixed point coefficients, data input and data output
line384=%EMPTY%
line385=      /* ********************************************************************************/
line386=#endif  // end of __SPECIAL_FUNCTION_LAYER_LIB_NPNZ16B_H__ header file section
line387=%EMPTY%
line388=%EMPTY%
line389=      //**********************************************************************************
line390=      // Download latest version of this tool here: %TOOL_HOME_URL%
line391=      //**********************************************************************************
line392=%EMPTY%


[comp_header]
count=110
line0=      /* *********************************************************************************
line1=%SPACE%* %APP_PRODUCT_NAME%, Version %APP_PRODUCT_VERSION%
line2=%SPACE%* *********************************************************************************
line3=%SPACE%* %FILTER_ORDER%p%FILTER_ORDER%z controller function declarations and compensation filter coefficients
line4=%SPACE%* derived for following operating conditions:
line5=%SPACE%* *********************************************************************************
line6=%SPACE%*
line7=%SPACE%*  Controller Type:    %COMP_TYPE_NAME%
line8=%SPACE%*  Sampling Frequency: %SAMPLING_FREQUENCY% Hz 
line9=%SPACE%*  Fixed Point Format: %Q_FORMAT%
line10=%SPACE%*  Scaling Mode:       %SCALING_MODE%
line11=%SPACE%*  Input Gain:         %INPUT_GAIN%
line12=%SPACE%*
line13=%SPACE%* *********************************************************************************
line14=%SPACE%* CGS Version:         %CGS_VERSION%
line15=%SPACE%* CGS Date:            %CGS_VERSION_DATE%
line16=%SPACE%* *********************************************************************************
line17=%SPACE%* User:                %USER_NAME%
line18=%SPACE%* Date/Time:           %DATE_TODAY%
line19=%SPACE%* ********************************************************************************/
line20=%EMPTY%
line21=#ifndef __SPECIAL_FUNCTION_LAYER_%FILENAME_PATTERN_U%_H__
line22=#define __SPECIAL_FUNCTION_LAYER_%FILENAME_PATTERN_U%_H__
line23=%EMPTY%
line24=#include <xc.h> // include processor files - each processor file is guarded 
line25=#include <dsp.h> // include DSP data types (e.g. fractional)
line26=#include <stdint.h> // include standard integer number data types 
line27=#include <stdbool.h> // include standard boolean data types (true/false)
line28=%EMPTY%
line29=#include "%LIB_HEADER_INCLUDE_PATH%npnz16b.h" // include NPNZ library header file
line30=%EMPTY%
line31=      /* *******************************************************************************
line32=%SPACE%* Data Arrays:
line33=%SPACE%* The NPNZ16b_t data structure contains pointers to coefficient, control and error  
line34=%SPACE%* history arrays. The pointer target objects (variables and arrays) are defined 
line35=%SPACE%* in controller source file %FILENAME_PATTERN_L%.c
line36=%SPACE%*
line37=%SPACE%* Type definitions for A- and B- coefficient arrays as well as error- and control 
line38=%SPACE%* history arrays are aligned in memory using the 'packed' attribute for optimized    
line39=%SPACE%* addressing during DSP computations. These aligned data structures need to be   
line40=%SPACE%* placed in specific memory locations to allow direct X/Y-access from the DSP. 
line41=%SPACE%* This X/Y-memory placement is covered by the declarations used in controller 
line42=%SPACE%* source file %FILENAME_PATTERN_L%.c
line43=%SPACE%* ******************************************************************************/
line44=typedef struct %PREFIXU%CONTROL_LOOP_COEFFICIENTS_s
line45={
line46=%IDENT%volatile %COEFF_DATA_TYPE% ACoefficients[%FILTER_ORDER%]; // A-Coefficients
line47=%IDENT%volatile %COEFF_DATA_TYPE% BCoefficients[%FILTER_ORDER+1%]; // B-Coefficients
line48=} __attribute__((packed)) %PREFIXU%CONTROL_LOOP_COEFFICIENTS_t;
line49=%EMPTY%
line50=typedef struct %PREFIXU%CONTROL_LOOP_HISTORIES_s
line51={
line52=%IDENT%volatile %HISTORY_DATA_TYPE% ControlHistory[%FILTER_ORDER%];  // Control History Array
line53=%IDENT%volatile %HISTORY_DATA_TYPE% ErrorHistory[%FILTER_ORDER+1%];  // Error History Array
line54=} __attribute__((packed)) %PREFIXU%CONTROL_LOOP_HISTORIES_t;
line55=%{(1209)}%%EMPTY%
line56=%{(1209)}%// P-Term Coefficient for Plant Measurements
line57=%{(1209)}%extern volatile int16_t %PREFIX%pterm_factor;
line58=%{(1209)}%extern volatile int16_t %PREFIX%pterm_scaler;
line59=%{(1800)}%%EMPTY%
line60=%{(1800)}%// Adaptive Gain Control Coefficient
line61=%{(1800)}%extern volatile int16_t %PREFIX%agc_factor_default;
line62=%{(1800)}%extern volatile int16_t %PREFIX%agc_scaler_default;
line63=%EMPTY%
line64=%EMPTY%
line65=// User-defined NPNZ16b_s controller data object
line66=extern volatile struct %STRUCTURE_LABEL%_s %FILENAME_PATTERN%; // user-controller data object
line67=%EMPTY%
line68=      /* *******************************************************************************
line69=%SPACE%* Function call prototypes for initialization routines and control loops
line70=%SPACE%* ******************************************************************************/
line71=%EMPTY%
line72=// Initialization of %FILENAME_PATTERN% controller object
line73=extern volatile uint16_t %FILENAME_PATTERN%_Initialize( // %FILENAME_PATTERN% initialization function call
line74=%IDENT%%IDENT%volatile struct %STRUCTURE_LABEL%_s* controller // Pointer to nPnZ data type object
line75=%IDENT%);
line76=%EMPTY%
line77=// Clears the %FILTER_ORDER%P%FILTER_ORDER%Z controller output and error histories
line78=extern void %FILENAME_PATTERN%_Reset( // %FILENAME_PATTERN% reset function call (Assembly)
line79=%IDENT%%IDENT%volatile struct %STRUCTURE_LABEL%_s* controller // Pointer to nPnZ data type object
line80=%IDENT%);
line81=%EMPTY%
line82=// Loads user-defined values into %FILTER_ORDER%P%FILTER_ORDER%Z controller output and error histories
line83=extern void %FILENAME_PATTERN%_Precharge( // %FILENAME_PATTERN% history pre-charge function call (Assembly)
line84=%IDENT%%IDENT%volatile struct %STRUCTURE_LABEL%_s* controller, // Pointer to nPnZ data type object
line85=%IDENT%%IDENT%volatile %HISTORY_DATA_TYPE% ctrl_input, // user-defined, constant error history value
line86=%IDENT%%IDENT%volatile %HISTORY_DATA_TYPE% ctrl_output // user-defined, constant control output history value
line87=%IDENT%);
line88=%EMPTY%
line89=// Calls the %FILENAME_PATTERN% control loop
line90=extern void %FILENAME_PATTERN%_Update( // Calls the %FILTER_ORDER%P%FILTER_ORDER%Z controller (Assembly)
line91=%IDENT%%IDENT%volatile struct %STRUCTURE_LABEL%_s* controller // Pointer to nPnZ data type object
line92=%IDENT%);
line93=%EMPTY%
line94=%{(1209)}%// Calls the %FILENAME_PATTERN% P-Term controller during measurements of plant transfer functions
line95=%{(1209)}%// THIS CONTROLLER IS USED FOR MEASUREMENTS OF THE PLANT TRANSFER FUNCTION ONLY.
line96=%{(1209)}%// THIS LOOP IS BY DEFAULT UNSTABLE AND ONLY WORKS UNDER STABLE TEST CONDITIONS
line97=%{(1209)}%// DO NOT USE THIS CONTROLLER TYPE FOR NORMAL OPERATION
line98=%{(1209)}%extern void %FILENAME_PATTERN%_PTermUpdate( // Calls the P-Term controller (Assembly)
line99=%{(1209)}%%IDENT%%IDENT%volatile struct %STRUCTURE_LABEL%_s* controller // Pointer to nPnZ data type object
line100=%{(1209)}%%IDENT%);
line101=%{(1209)}%%EMPTY%
line102=%EMPTY%
line103=#endif // end of __SPECIAL_FUNCTION_LAYER_%FILENAME_PATTERN_U%_H__
line104=%EMPTY%
line105=%EMPTY%
line106=//**********************************************************************************
line107=// Download latest version of this tool here: %TOOL_HOME_URL%
line108=//**********************************************************************************
line109=%EMPTY%


[comp_source_head]
count=86
line0=      /* *********************************************************************************
line1=%SPACE%* %APP_PRODUCT_NAME%, Version %APP_PRODUCT_VERSION%
line2=%SPACE%* *********************************************************************************
line3=%SPACE%* %FILTER_ORDER%p%FILTER_ORDER%z controller function declarations and compensation filter coefficients
line4=%SPACE%* derived for following operating conditions:
line5=%SPACE%* *********************************************************************************
line6=%SPACE%*
line7=%SPACE%*  Controller Type:    %COMP_TYPE_NAME%
line8=%SPACE%*  Sampling Frequency: %SAMPLING_FREQUENCY% Hz 
line9=%SPACE%*  Fixed Point Format: %Q_FORMAT%
line10=%SPACE%*  Scaling Mode:       %SCALING_MODE%
line11=%SPACE%*  Input Gain:         %INPUT_GAIN%
line12=%SPACE%*
line13=%SPACE%* *********************************************************************************
line14=%SPACE%* CGS Version:         %CGS_VERSION%
line15=%SPACE%* CGS Date:            %CGS_VERSION_DATE%
line16=%SPACE%* *********************************************************************************
line17=%SPACE%* User:                %USER_NAME%
line18=%SPACE%* Date/Time:           %DATE_TODAY%
line19=%SPACE%* ********************************************************************************/
line20=%EMPTY%
line21=#include "%C_HEADER_INCLUDE_PATH%"
line22=%EMPTY%
line23=      /* *********************************************************************************
line24=%SPACE%* Data Arrays:
line25=%SPACE%* This source file declares the default parameters of the z-domain compensation  
line26=%SPACE%* filter. The NPNZ16b_t data structure contains two pointers to A- and B- 
line27=%SPACE%* coefficient arrays and two pointers to control and error history arrays.
line28=%SPACE%*
line29=%SPACE%* For optimized data processing during DSP computations, these arrays must be 
line30=%SPACE%* located in specific memory locations (X-space for coefficient arrays and 
line31=%SPACE%* Y-space for control and error history arrays). 
line32=%SPACE%*
line33=%SPACE%* The following declarations are used to define the array data contents, their 
line34=%SPACE%* length and memory location. These declarations are made publicly accessible 
line35=%SPACE%* through extern declarations in header file %FILENAME_PATTERN_L%.h
line36=%SPACE%* ********************************************************************************/
line37=%EMPTY%
line38=volatile struct %PREFIXU%CONTROL_LOOP_COEFFICIENTS_s __attribute__((space(xmemory), near)) %PREFIX%coefficients; // A/B-Coefficients 
line39=volatile uint16_t %PREFIX%ACoefficients_size = (sizeof(%PREFIX%coefficients.ACoefficients)/sizeof(%PREFIX%coefficients.ACoefficients[0])); // A-coefficient array size
line40=volatile uint16_t %PREFIX%BCoefficients_size = (sizeof(%PREFIX%coefficients.BCoefficients)/sizeof(%PREFIX%coefficients.BCoefficients[0])); // B-coefficient array size
line41=%EMPTY%
line42=volatile struct %PREFIXU%CONTROL_LOOP_HISTORIES_s __attribute__((space(ymemory), far)) %PREFIX%histories; // Control/Error Histories 
line43=volatile uint16_t %PREFIX%ControlHistory_size = (sizeof(%PREFIX%histories.ControlHistory)/sizeof(%PREFIX%histories.ControlHistory[0])); // Control history array size
line44=volatile uint16_t %PREFIX%ErrorHistory_size = (sizeof(%PREFIX%histories.ErrorHistory)/sizeof(%PREFIX%histories.ErrorHistory[0])); // Error history array size
line45=%EMPTY%
line46=      /* *********************************************************************************
line47=%SPACE%* Pole&Zero Placement:
line48=%SPACE%* *********************************************************************************
line49=%SPACE%*
line50=%SPACE%*%IDENT%fP%INDEX%:%IDENT%%LOOP_POLE_LOCATION_LIST% Hz
line51=%SPACE%*%IDENT%fZ%INDEX%:%IDENT%%LOOP_ZERO_LOCATION_LIST% Hz
line52=%SPACE%*
line53=%SPACE%* *********************************************************************************
line54=%SPACE%* Filter Coefficients and Parameters:
line55=%SPACE%* ********************************************************************************/
line56=volatile %COEFF_DATA_TYPE% %PREFIX%ACoefficients [%FILTER_ORDER%] =
line57={
line58=%IDENT%%LOOP_A_COEFFICIENTS_LIST% // Coefficient A%INDEX% will be multiplied with controller output u(n-%INDEX%)
line59=};
line60=%EMPTY%
line61=volatile %COEFF_DATA_TYPE% %PREFIX%BCoefficients [%FILTER_ORDER+1%] =
line62={
line63=%IDENT%%LOOP_B_COEFFICIENTS_LIST% // Coefficient B%INDEX% will be multiplied with error input e(n-%INDEX%)
line64=};
line65=%EMPTY%
line66=// Coefficient normalization factors
line67=volatile int16_t %PREFIX%pre_scaler = %PRESCALER%;
line68=volatile int16_t %PREFIX%post_shift_A = %POSTSHIFT_A%;
line69=volatile int16_t %PREFIX%post_shift_B = %POSTSHIFT_B%;
line70=volatile fractional %PREFIX%post_scaler = %POSTSCALER%;
line71=%{(1209)}%%EMPTY%
line72=%{(1209)}%// P-Term Coefficient for Plant Measurements
line73=%{(1209)}%volatile int16_t %PREFIX%pterm_factor = %PTERMFACTOR%;
line74=%{(1209)}%volatile int16_t %PREFIX%pterm_scaler = %PTERMSCALER%;
line75=%{(1800)}%%EMPTY%
line76=%{(1800)}%//Adaptive Gain Control Coefficient
line77=%{(1800)}%volatile int16_t %PREFIX%agc_factor_default = %AGCFACTOR%;
line78=%{(1800)}%volatile int16_t %PREFIX%agc_scaler_default = %AGCSCALER%;
line79=%EMPTY%
line80=%EMPTY%
line81=// User-defined NPNZ16b_t controller data object
line82=volatile struct %STRUCTURE_LABEL%_s %FILENAME_PATTERN%; // user-controller data object
line83=%EMPTY%
line84=     /* ********************************************************************************/
line85=%EMPTY%


[comp_source_functions]
count=1
function0=comp_source_init


[comp_source_init]
count=75
line0=      /*!%FILENAME_PATTERN%_Init()
line1=%SPACE%* *********************************************************************************
line2=%SPACE%* Summary: Initializes controller coefficient arrays and normalization
line3=%SPACE%* 
line4=%SPACE%* Parameters:
line5=%SPACE%*     - struct %STRUCTURE_LABEL%_s* controller
line6=%SPACE%* 
line7=%SPACE%* Returns:
line8=%SPACE%*     - uint16_t:  0->failure
line9=%SPACE%*                  1->success
line10=%EMPTY%
line11=%SPACE%* Description:
line12=%SPACE%* This function needs to be called from user code once to initialize coefficient 
line13=%SPACE%* arrays and number normalization settings of the %FILENAME_PATTERN% controller 
line14=%SPACE%* object.
line15=%SPACE%* 
line16=%SPACE%* PLEASE NOTE:
line17=%SPACE%* This routine DOES NOT initialize the complete controller object.
line18=%SPACE%* User-defined settings such as pointers to the control reference, source and  
line19=%SPACE%* target registers, output minima and maxima and further, design-dependent  
line20=%SPACE%* settings, need to be specified in user code.
line21=%SPACE%* ********************************************************************************/
line22=volatile uint16_t %FILENAME_PATTERN%_Initialize(volatile struct %STRUCTURE_LABEL%_s* controller)
line23={
line24=%IDENT%volatile uint16_t i=0;
line25=%EMPTY%
line26=%IDENT%// Initialize controller data structure at runtime with pre-defined default values
line27=%IDENT%controller->status.value = NPNZ16_CONTROL_STATUS_CLEAR;  // clear all status flag bits (will turn off execution))
line28=%IDENT%
line29=%IDENT%controller->Filter.ptrACoefficients = &%PREFIX%coefficients.ACoefficients[0]; // initialize pointer to A-coefficients array
line30=%IDENT%controller->Filter.ptrBCoefficients = &%PREFIX%coefficients.BCoefficients[0]; // initialize pointer to B-coefficients array
line31=%IDENT%controller->Filter.ptrControlHistory = &%PREFIX%histories.ControlHistory[0]; // initialize pointer to control history array
line32=%IDENT%controller->Filter.ptrErrorHistory = &%PREFIX%histories.ErrorHistory[0]; // initialize pointer to error history array
line33=%IDENT%controller->Filter.normPostShiftA = %PREFIX%post_shift_A; // initialize A-coefficients/single bit-shift scaler
line34=%IDENT%controller->Filter.normPostShiftB = %PREFIX%post_shift_B; // initialize B-coefficients/dual/post scale factor bit-shift scaler
line35=%IDENT%controller->Filter.normPostScaler = %PREFIX%post_scaler; // initialize control output value normalization scaling factor
line36=%IDENT%controller->Filter.normPreShift = %PREFIX%pre_scaler; // initialize A-coefficients/single bit-shift scaler
line37=%IDENT%
line38=%IDENT%controller->Filter.ACoefficientsArraySize = %PREFIX%ACoefficients_size; // initialize A-coefficients array size
line39=%IDENT%controller->Filter.BCoefficientsArraySize = %PREFIX%BCoefficients_size; // initialize A-coefficients array size
line40=%IDENT%controller->Filter.ControlHistoryArraySize = %PREFIX%ControlHistory_size; // initialize control history array size
line41=%IDENT%controller->Filter.ErrorHistoryArraySize = %PREFIX%ErrorHistory_size; // initialize error history array size
line42=%IDENT%
line43=%IDENT%
line44=%IDENT%// Load default set of A-coefficients from user RAM into X-Space controller A-array
line45=%IDENT%for(i=0; i<controller->Filter.ACoefficientsArraySize; i++)
line46=%IDENT%{
line47=%IDENT%%IDENT%%PREFIX%coefficients.ACoefficients[i] = %PREFIX%ACoefficients[i];
line48=%IDENT%}
line49=%EMPTY%
line50=%IDENT%// Load default set of B-coefficients from user RAM into X-Space controller B-array
line51=%IDENT%for(i=0; i<controller->Filter.BCoefficientsArraySize; i++)
line52=%IDENT%{
line53=%IDENT%%IDENT%%PREFIX%coefficients.BCoefficients[i] = %PREFIX%BCoefficients[i];
line54=%IDENT%}
line55=%EMPTY%
line56=%IDENT%// Clear error and control histories of the 3P3Z controller
line57=%IDENT%%FILENAME_PATTERN%_Reset(&%FILENAME_PATTERN%);
line58=%{(1209)}%%IDENT%
line59=%{(1209)}%%IDENT%// Load P-Term factor and scaler into data structure
line60=%{(1209)}%%IDENT%controller->Filter.PTermFactor = %PREFIX%pterm_factor;;
line61=%{(1209)}%%IDENT%controller->Filter.PTermScaler = %PREFIX%pterm_scaler;
line62=%{(1800)}%%IDENT%
line63=%{(1800)}%%IDENT%// Load initial AGC factor and scaler into data structure
line64=%{(1800)}%%IDENT%controller->GainControl.AgcFactor = %PREFIX%agc_factor_default;
line65=%{(1800)}%%IDENT%controller->GainControl.AgcScaler = %PREFIX%agc_scaler_default;
line66=%IDENT%
line67=%IDENT%return(1);
line68=}
line69=%EMPTY%
line70=%EMPTY%
line71=//**********************************************************************************
line72=// Download latest version of this tool here: %TOOL_HOME_URL%
line73=//**********************************************************************************
line74=%EMPTY%


___________________________________________________
(C)2020, Microchipt Technology Inc.
