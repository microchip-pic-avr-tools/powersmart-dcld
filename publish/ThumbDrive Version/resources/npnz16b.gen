[generic]
Name=Code Generator Script
Description=This script defines DSP assembly code, API  C-source code and header file templates used to generate user-tailored SMPS control firmware using the Digital Control Library Designer component of the PowerSmart™ SDK
Author=Andreas Reiter - M91406
Version=3.0.1
Date=12/16/2020
URL=https://areiter128.github.io/DCLD

[history]
count=2
0=09/14/20;3.0.0;Consolidated code generator script for NPNZ16b merging assembly and C-code generation
1=12/16/2020;3.0.1;Renamed comments and macros to support rebranding of DCLD to PowerSmart DCLD

[asm:execution_lists]
count=5
0=execlist_common_inc
1=execlist_sbsft
2=execlist_scscl
3=execlist_dbsft
4=execlist_fscl

[ccode:execution_lists]
count=4
0=execlist_c_source
1=execlist_c_header
2=execlist_c_lib_header
3=execlist_c_config

[simplis:execution_lists]
count=2
0=execlist_simplis_symbol
1=execlist_simplis_instance

[scaling_modes]
count=4
key0=sbsft
key1=scscl
key2=dbsft
key3=fscl
descr0=Single Bitshift-Scaling Mode
descr1=Single Output Factor Scaling Mode
descr2=Dual Bitshift-Scaling Mode
descr3=Fast Floating Point Coefficient Scaling Mode
data_addr_offset0=4
data_addr_offset1=4
data_addr_offset2=4
data_addr_offset3=4
coeff_addr_offset0=2
coeff_addr_offset1=2
coeff_addr_offset2=2
coeff_addr_offset3=2

[MSExcelExport]
PoleAtOrigin=IMDIV(wp0 ,COMPLEX(0,[<SHEET.CELL.RADIANDS>]))
LeadLagBlock=IMDIV(IMSUM(IMDIV(COMPLEX(0,[<SHEET.CELL.RADIANDS>]),wz%FO%,1),IMSUM(IMDIV(COMPLEX(0,[<SHEET.CELL.RADIANDS>]),wp%FO%),1))
FORMULA=IMPRODUCT(%PoleAtOrigin%, %LeadLagBlock%)


[tokens]
count=26
0=%EMPTY%
1=%SPACE%
2=%IDENT%
3=%NOIDENT%
4=%DATA_TYPE_FRACTIONAL%
5=%DATA_TYPE_INT32%
6=%FILE_NAME_PATTERN%
7=%PREFIX%
8=%FILTER_ORDER%
9=%FILTER_ORDER-1%
10=%FILTER_ORDER+1%
11=%SCALING_MODE_INDEX%
12=%SCALING_MODE_NAME%
13=%SCALING_MODE_DESCIPTION%
14=%STRUCTURE_LABEL%
15=%USER_NAME%
16=%DATE_TIME_NOW%
17=%CGS_NAME%
18=%CGS_VERSION%
19=%CGS_VERSION_DATE%
21=%APP_PRODUCT_NAME%
22=%APP_PRODUCT_VERSION%
23=%SUPPORT_URL%
24=%VENDOR_URL%
25=%TOOL_HOME_URL%
26=%ASM_INCLUDE_FILE%

[labels]
count=4
0=%SUPPORT_URL%;https://www.microchip.com/SMPS/
1=%VENDOR_URL%;https://www.microchip.com/
2=%TOOL_HOME_URL%;https://areiter128.github.io/DCLD
3=%STRUCTURE_LABEL%;NPNZ16b

[option_flags]
count=6
0=<RTCCTRG0>
1=<RTCCTRG1>
2=<RTCCTRG2>
3=<RTCCTRG3>
4=<RTCCTRG9>
5=<SRTCC1>

[option_ids]
count=43
0=%{(0000)}%;token_disabled
1=%{(1100)}%;context_management
2=%{(1101)}%;context_shadow
3=%{(1102)}%;context_mac_wreg
4=%{(1103)}%;context_acc
5=%{(1104)}%;context_acc_a
6=%{(1105)}%;context_acc_b
7=%{(1106)}%;context_core_config
8=%{(1107)}%;context_core_status
9=%{(1200)}%;option_enable
10=%{(1201)}%;option_store_reload_acc
11=%{(1202)}%;option_core_config
12=%{(1203)}%;option_enable_switch
13=%{(1204)}%;option_enable_switch_always_read
14=%{(1205)}%;option_error_normalization
15=%{(1206)}%;option_adc_trigger_a_placement
16=%{(1207)}%;option_adc_trigger_b_placement
17=%{(1209)}%;option_add_p-term
18=%{(1300)}%;data_interface_enable
19=%{(1301)}%;data_interface_alt_input
20=%{(1302)}%;data_interface_alt_output
21=%{(1303)}%;data_interface_copy_to_alt_output
22=%{(1304)}%;data_interface_cascade_call
23=%{(1400)}%;data_provider_enable
24=%{(1401)}%;data_provider_control_input_raw
25=%{(1402)}%;data_provider_control_input_compensated
26=%{(1403)}%;data_provider_control_error
27=%{(1404)}%;data_provider_control_output
28=%{(1500)}%;anti_windup_enable
29=%{(1501)}%;anti_windup_max
30=%{(1502)}%;anti_windup_max_status_flag
31=%{(1503)}%;anti_windup_min
32=%{(1504)}%;anti_windup_min_status_flag
33=%{(1505)}%;anti_windup_debounce_flag
34=%{(1506)}%;anti_windup_saturation_flag
35=%{(1600)}%;feedback_conditioning_enable
36=%{(1601)}%;feedback_offset_compensation
37=%{(1602)}%;bi_directional_feedback_flag
38=%{(1800)}%;agc_enable
39=%{(1801)}%;agc_enable_switch
40=%{(1802)}%;agc_get_factor_function_call
41=%{(1810)}%;agc_maximize_output_resolution
42=%{(9001)}%;library_data_structure_include


[execlist_common_inc]
description=Assembly code data structure offset declarations of global NPNZ16b library object data structure
count=6
0=disclaimer
1=version_header
2=npnz16b_global_flags
3=npnz16b_data_structure
4=include_header_end
5=tool_link


[execlist_sbsft]
description=16-bit fixed point coefficients scaled by one, unified single bit-shift scaler
name=Single Bitshift-Scaling Mode
wreg_usage=0,1,2,3,4,6,8,10
accu_usage=ab
coeff_addr_offset=4
data_addr_offset=2
count=195
0=version_header
1=version_header_filter_info
2=lists
3=section_header
4=%{(9001)}%include_header
5=%{(!9001)}%npnz16b_global_flags
6=%{(!9001)}%npnz16b_data_structure
7=section_code
8=exec_function_head<RTCCTRG0>
9=%{(1100)&&(1101)}%context_save
10=%{(1100)&&(1101)}%context_save_shadow
11=%{(1200)&&(1203)}%enable_disable_start
12=%{(1100)}%context_save
13=%{(1100)&&(1102)}%context_save_mac_registers
14=%{(1100)&&(1103)&&(1104)}%context_save_accumulator_a
15=%{(1100)&&(1103)&&(1105)}%context_save_accumulator_b
16=%{(1100)&&(1106)}%context_save_core_config
17=%{(1100)&&(1107)}%context_save_core_status
18=%{(1200)&&(1202)}%core_config
19=load_a_coeff_array_ptr
20=load_control_history_array_ptr
21=comp_mac_start_acca_clear_prefetch
22=comp_mac_loop_a_term_acca
23=comp_mac_end_acca
24=%{(0000)}%load_error_history_array_ptr
25=comp_error_history_update
26=%{(!1301)}%comp_read_input<RTCCTRG1>
27=%{(1300)&&(1301)}%comp_read_input_from_alt_source_switch<RTCCTRG1>
28=%{(1400)&&(1401)}%shadow_copy_control_input_raw
29=%{(1600)&&(1601)}%comp_zero_input
30=%{(1600)&&(1602)}%comp_invert_input
31=%{(1400)&&(1402)}%shadow_copy_control_input_compensated
32=comp_get_error
33=%{(1200)&&(1205)}%comp_norm_error
34=%{(1400)&&(1403)}%shadow_copy_error_input
35=load_b_coeff_array_ptr
36=comp_error_add_most_recent_to_history
37=comp_mac_start_accb_clear_prefetch
38=comp_mac_loop_b_term_accb
39=comp_mac_end_accb
40=%{(1800)}%agc_factor_multiply_start
41=%{(1800)&&(1801)}%agc_factor_multiply_enable_start
42=%{(1800)&&(!1810)}%agc_factor_multiply_store_accb
43=%{(1800)&&(1810)}%agc_factor_multiply_store_accb_high_res
44=%{(1800)&&(1802)}%agc_factor_multiply_factor_update_call
45=%{(1800)&&(!1810)}%agc_factor_multiply_scaled
46=%{(1800)&&(1810)}%agc_factor_multiply_scaled_high_res
47=%{(1800)&&(1801)}%agc_factor_multiply_enable_end
48=comp_add_accb_to_acca
49=comp_backward_norm_a_acca
50=comp_mac_store_acca
51=%{(1500)}%%{(1501)||(1503)}%anti_windup
52=%{(1500)&&(1506)}%anti_windup_output_saturation_start
53=%{(1500)&&(1501)}%%{(!1300)||(!1302)||(1303)}%anti_windup_max_start
54=%{(1500)&&(1501)&&(1300)&&(1302)&&(!1303)}%anti_windup_max_start_with_alt_target_switch
55=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start<SRTCC1>
56=%{(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
57=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass
58=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start
59=%{(1500)&&(1501)}%anti_windup_max_override<SRTCC1>
60=%{(1500)&&(1501)&&(1505)}%anti_windup_debouncing
61=%{(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag<SRTCC1>
62=%{(1500)&&(1501)}%anti_windup_max_options_end
63=%{(1500)&&(1503)}%%{(!1300)||(!1302)||(1303)}%anti_windup_min_start
64=%{(1500)&&(1503)&&(1300)&&(1302)&&(!1303)}%anti_windup_min_start_with_alt_target_switch
65=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start<SRTCC1>
66=%{(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
67=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass
68=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start
69=%{(1500)&&(1503)}%anti_windup_min_override<SRTCC1>
70=%{(1500)&&(1503)&&(1505)}%anti_windup_debouncing
71=%{(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag<SRTCC1>
72=%{(1500)&&(1503)}%anti_windup_min_options_end
73=comp_writeback_start
74=%{(1300)&&(1302)&&(!1303)}%comp_writeback_to_alt_target_switch
75=comp_writeback_end<RTCCTRG2>
76=%{(1300)&&(1302)&&(1303)}%comp_writeback_mirror_to_alt_target<RTCCTRG2>
77=%{(1400)&&(1404)}%shadow_copy_control_output
78=%{(1200)}%%{(1206)||(1207)}%adc_trigger_placement_start
79=%{(1200)&&(1207)}%adc_trigger_b_placement<RTCCTRG3>
80=%{(1200)&&(1206)}%adc_trigger_a_placement<RTCCTRG3>
81=load_control_history_array_ptr
82=comp_control_history_update
83=%{(1500)&&(1506)}%anti_windup_output_saturation_end
84=%{(!1500)||(!1506)}%comp_control_add_most_recent_to_history
85=%{(1100)}%context_restore
86=%{(1100)&&(1107)}%context_restore_core_status
87=%{(1100)&&(1106)}%context_restore_core_config
88=%{(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
89=%{(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
90=%{(1100)&&(1102)}%context_restore_mac_registers
91=%{(1200)&&(1203)&&(!1204)}%enable_disable_end
92=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read<SRTCC1>
93=%{(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input_raw<SRTCC1>
94=%{(1200)&&(1203)&&(1204)&&(1400)&&(1600)&&(1601)}%%{(1402)||(1403)}%comp_zero_input<SRTCC1>
95=%{(1200)&&(1203)&&(1204)&&(1400)&&(1600)&&(1602)}%%{(1402)||(1403)}%comp_invert_input<SRTCC1>
96=%{(1200)&&(1203)&&(1204)&&(1400)&&(1402)}%shadow_copy_control_input_compensated<SRTCC1>
97=%{(1200)&&(1203)&&(1204)&&(1400)&&(1403)}%comp_get_error<SRTCC1>
98=%{(1200)&&(1203)&&(1204)&&(1205)&&(1400)&&(1403)}%comp_norm_error<SRTCC1>
99=%{(1200)&&(1203)&&(1204)&&(1400)&&(1403)}%shadow_copy_error_input<SRTCC1>
100=%{(1200)&&(1203)&&(1204)&&(1400)&&(1404)}%shadow_copy_control_output_zeroed_when_disabled<SRTCC1>
101=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end
102=%{(1300)&&(1304)}%cascaded_function_call
103=%{(1100)&&(1101)}%context_restore
104=%{(1100)&&(1101)}%context_restore_shadow
105=return<RTCCTRG9>
106=reset_function_head
107=clear_control_history_start
108=clear_control_history_loop
109=clear_control_history_end
110=clear_error_history_start
111=clear_error_history_loop
112=clear_error_history_end
113=return
114=charge_function_head
115=charge_error_history_start
116=charge_error_history_loop
117=charge_error_history_end
118=charge_control_history_start
119=charge_control_history_loop
120=charge_control_history_end
121=return
122=%{(1209)}%pterm_function_head
123=%{(1209)&&(1100)&&(1101)}%context_save
124=%{(1209)&&(1100)&&(1101)}%context_save_shadow
125=%{(1209)&&(1200)&&(1203)}%enable_disable_start_pterm
126=%{(1209)&&(1100)}%context_save
127=%{(1209)&&(1100)&&(1102)}%context_save_mac_registers
128=%{(1209)&&(1100)&&(1103)&&(1104)}%context_save_accumulator_a
129=%{(1209)&&(1100)&&(1103)&&(1105)}%context_save_accumulator_b
130=%{(1209)&&(1100)&&(1106)}%context_save_core_config
131=%{(1209)&&(1100)&&(1107)}%context_save_core_status
132=%{(1209)&&(1200)&&(1202)}%core_config
133=%{(1209)}%comp_read_input
134=%{(1209)&&(1400)&&(1401)}%shadow_copy_control_input_raw
135=%{(1209)&&(1600)&&(1601)}%comp_zero_input
136=%{(1209)&&(1400)&&(1402)}%shadow_copy_control_input_compensated
137=%{(1209)&&(1600)&&(1602)}%comp_invert_input
138=%{(1209)}%comp_get_error
139=%{(1209)&&(1200)&&(1205)}%comp_norm_error
140=%{(1209)&&(1400)&&(1403)}%shadow_copy_error_input
141=%{(1209)}%pterm_comp_load_gain_factor
142=%{(1209)}%pterm_comp_exec_pterm
143=%{(1209)&&(1500)}%%{(1501)||(1503)}%anti_windup
144=%{(1209)&&(1500)&&(1501)}%%{(!1300)||(!1302)||(1303)}%anti_windup_max_start
145=%{(1209)&&(1500)&&(1501)&&(1300)&&(1302)&&(!1303)}%anti_windup_max_start_with_alt_target_switch
146=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start_pterm
147=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
148=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass_pterm
149=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start_pterm
150=%{(1209)&&(1500)&&(1501)}%anti_windup_max_override
151=%{(1209)&&(1500)&&(1501)&&(1505)}%anti_windup_debouncing
152=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag
153=%{(1209)&&(1500)&&(1501)}%anti_windup_max_options_end_pterm
154=%{(1209)&&(1500)&&(1503)}%%{(!1300)||(!1302)||(1303)}%anti_windup_min_start
155=%{(1209)&&(1500)&&(1503)&&(1300)&&(1302)&&(!1303)}%anti_windup_min_start_with_alt_target_switch
156=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start_pterm
157=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
158=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass_pterm
159=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start_pterm
160=%{(1209)&&(1500)&&(1503)}%anti_windup_min_override
161=%{(1209)&&(1500)&&(1503)&&(1505)}%anti_windup_debouncing
162=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag
163=%{(1209)&&(1500)&&(1503)}%anti_windup_min_options_end_pterm
164=%{(1209)}%comp_writeback_start
165=%{(1209)&&(1300)&&(1302)&&(!1303)}%comp_writeback_to_alt_target_switch
166=%{(1209)}%comp_writeback_end
167=%{(1209)&&(1300)&&(1302)&&(1303)}%comp_writeback_mirror_to_alt_target
168=%{(1209)&&(1400)&&(1404)}%shadow_copy_control_output
169=%{(1209)&&(1200)}%%{(1206)||(1207)}%adc_trigger_placement_start
170=%{(1209)&&(1200)&&(1206)&&(1207)}%adc_trigger_b_placement
171=%{(1209)&&(1200)&&(1206)}%adc_trigger_a_placement
172=%{(1209)&&(1100)}%context_restore
173=%{(1209)&&(1100)&&(1107)}%context_restore_core_status
174=%{(1209)&&(1100)&&(1106)}%context_restore_core_config
175=%{(1209)&&(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
176=%{(1209)&&(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
177=%{(1209)&&(1100)&&(1102)}%context_restore_mac_registers
178=%{(1209)&&(1200)&&(1203)&&(!1204)}%enable_disable_end_pterm
179=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_pterm<SRTCC1>
180=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input_raw<SRTCC1>
181=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1600)&&(1601)}%%{(1402)||(1403)}%comp_zero_input<SRTCC1>
182=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1600)&&(1602)}%%{(1402)||(1403)}%comp_invert_input<SRTCC1>
183=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1402)}%shadow_copy_control_input_compensated<SRTCC1>
184=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1403)}%comp_get_error<SRTCC1>
185=%{(1209)&&(1200)&&(1203)&&(1204)&&(1205)&&(1400)&&(1403)}%comp_norm_error<SRTCC1>
186=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1403)}%shadow_copy_error_input<SRTCC1>
187=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1404)}%shadow_copy_control_output_zeroed_when_disabled<SRTCC1>
188=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end_pterm
189=%{(1209)&&(1300)&&(1304)}%cascaded_function_call
190=%{(1209)&&(1100)&&(1101)}%context_restore
191=%{(1209)&&(1100)&&(1101)}%context_restore_shadow
192=%{(1209)}%return
193=end
194=tool_link


[execlist_scscl]
description=Output factor modulated, single bit-shifted 16-bit fixed point controller
name=Single Output Factor Scaling Mode
wreg_usage=0,1,2,3,4,6,8,10
accu_usage=ab
coeff_addr_offset=4
data_addr_offset=2
count=194
0=version_header
1=version_header_filter_info
2=lists
3=section_header
4=%{(9001)}%include_header
5=%{(!9001)}%npnz16b_global_flags
6=%{(!9001)}%npnz16b_data_structure
7=section_code
8=exec_function_head<RTCCTRG0>
9=%{(1100)&&(1101)}%context_save
10=%{(1100)&&(1101)}%context_save_shadow
11=%{(1200)&&(1203)}%enable_disable_start
12=%{(1100)}%context_save
13=%{(1100)&&(1102)}%context_save_mac_registers
14=%{(1100)&&(1103)&&(1104)}%context_save_accumulator_a
15=%{(1100)&&(1103)&&(1105)}%context_save_accumulator_b
16=%{(1100)&&(1106)}%context_save_core_config
17=%{(1100)&&(1107)}%context_save_core_status
18=%{(1200)&&(1202)}%core_config
19=load_a_coeff_array_ptr
20=load_control_history_array_ptr
21=comp_mac_start_acca_clear_prefetch
22=comp_mac_loop_a_term_acca
23=comp_mac_end_acca
24=%{(0000)}%load_error_history_array_ptr
25=comp_error_history_update
26=comp_read_input<RTCCTRG1>
27=%{(1400)&&(1401)}%shadow_copy_control_input_raw
28=%{(1600)&&(1601)}%comp_zero_input
29=%{(1600)&&(1602)}%comp_invert_input
30=%{(1400)&&(1402)}%shadow_copy_control_input_compensated
31=comp_get_error
32=%{(1200)&&(1205)}%comp_norm_error
33=%{(1400)&&(1403)}%shadow_copy_error_input
34=load_b_coeff_array_ptr
35=comp_error_add_most_recent_to_history
36=comp_mac_start_accb_clear_prefetch
37=comp_mac_loop_b_term_accb
38=comp_mac_end_accb
39=%{(1800)}%agc_factor_multiply_start
40=%{(1800)&&(1801)}%agc_factor_multiply_enable_start
41=%{(1800)&&(!1810)}%agc_factor_multiply_store_accb
42=%{(1800)&&(1810)}%agc_factor_multiply_store_accb_high_res
43=%{(1800)&&(1802)}%agc_factor_multiply_factor_update_call
44=%{(1800)&&(!1810)}%agc_factor_multiply_scaled
45=%{(1800)&&(1810)}%agc_factor_multiply_scaled_high_res
46=%{(1800)&&(1801)}%agc_factor_multiply_enable_end
47=comp_add_accb_to_acca
48=comp_backward_norm_coeff_scaler_acca
49=comp_mac_store_acca
50=%{(1500)}%%{(1501)||(1503)}%anti_windup
51=%{(1500)&&(1506)}%anti_windup_output_saturation_start
52=%{(1500)&&(1501)}%%{(!1300)||(!1302)||(1303)}%anti_windup_max_start
53=%{(1500)&&(1501)&&(1300)&&(1302)&&(!1303)}%anti_windup_max_start_with_alt_target_switch
54=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start<SRTCC1>
55=%{(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
56=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass
57=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start
58=%{(1500)&&(1501)}%anti_windup_max_override<SRTCC1>
59=%{(1500)&&(1501)&&(1505)}%anti_windup_debouncing
60=%{(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag<SRTCC1>
61=%{(1500)&&(1501)}%anti_windup_max_options_end
62=%{(1500)&&(1503)}%%{(!1300)||(!1302)||(1303)}%anti_windup_min_start
63=%{(1500)&&(1503)&&(1300)&&(1302)&&(!1303)}%anti_windup_min_start_with_alt_target_switch
64=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start<SRTCC1>
65=%{(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
66=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass
67=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start
68=%{(1500)&&(1503)}%anti_windup_min_override<SRTCC1>
69=%{(1500)&&(1503)&&(1505)}%anti_windup_debouncing
70=%{(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag<SRTCC1>
71=%{(1500)&&(1503)}%anti_windup_min_options_end
72=comp_writeback_start
73=%{(1300)&&(1302)&&(!1303)}%comp_writeback_to_alt_target_switch
74=comp_writeback_end<RTCCTRG2>
75=%{(1300)&&(1302)&&(1303)}%comp_writeback_mirror_to_alt_target<RTCCTRG2>
76=%{(1400)&&(1404)}%shadow_copy_control_output
77=%{(1200)}%%{(1206)||(1207)}%adc_trigger_placement_start
78=%{(1200)&&(1207)}%adc_trigger_b_placement<RTCCTRG3>
79=%{(1200)&&(1206)}%adc_trigger_a_placement<RTCCTRG3>
80=load_control_history_array_ptr
81=comp_control_history_update
82=%{(1500)&&(1506)}%anti_windup_output_saturation_end
83=%{(!1500)||(!1506)}%comp_control_add_most_recent_to_history
84=%{(1100)}%context_restore
85=%{(1100)&&(1107)}%context_restore_core_status
86=%{(1100)&&(1106)}%context_restore_core_config
87=%{(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
88=%{(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
89=%{(1100)&&(1102)}%context_restore_mac_registers
90=%{(1200)&&(1203)&&(!1204)}%enable_disable_end
91=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read<SRTCC1>
92=%{(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input_raw<SRTCC1>
93=%{(1200)&&(1203)&&(1204)&&(1400)&&(1600)&&(1601)}%%{(1402)||(1403)}%comp_zero_input<SRTCC1>
94=%{(1200)&&(1203)&&(1204)&&(1400)&&(1600)&&(1602)}%%{(1402)||(1403)}%comp_invert_input<SRTCC1>
95=%{(1200)&&(1203)&&(1204)&&(1400)&&(1402)}%shadow_copy_control_input_compensated<SRTCC1>
96=%{(1200)&&(1203)&&(1204)&&(1400)&&(1403)}%comp_get_error<SRTCC1>
97=%{(1200)&&(1203)&&(1204)&&(1205)&&(1400)&&(1403)}%comp_norm_error<SRTCC1>
98=%{(1200)&&(1203)&&(1204)&&(1400)&&(1403)}%shadow_copy_error_input<SRTCC1>
99=%{(1200)&&(1203)&&(1204)&&(1400)&&(1404)}%shadow_copy_control_output_zeroed_when_disabled<SRTCC1>
100=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end
101=%{(1300)&&(1304)}%cascaded_function_call
102=%{(1100)&&(1101)}%context_restore
103=%{(1100)&&(1101)}%context_restore_shadow
104=return<RTCCTRG9>
105=reset_function_head
106=clear_control_history_start
107=clear_control_history_loop
108=clear_control_history_end
109=clear_error_history_start
110=clear_error_history_loop
111=clear_error_history_end
112=return
113=charge_function_head
114=charge_error_history_start
115=charge_error_history_loop
116=charge_error_history_end
117=charge_control_history_start
118=charge_control_history_loop
119=charge_control_history_end
120=return
121=%{(1209)}%pterm_function_head
122=%{(1209)&&(1100)&&(1101)}%context_save
123=%{(1209)&&(1100)&&(1101)}%context_save_shadow
124=%{(1209)&&(1200)&&(1203)}%enable_disable_start_pterm
125=%{(1209)&&(1100)}%context_save
126=%{(1209)&&(1100)&&(1102)}%context_save_mac_registers
127=%{(1209)&&(1100)&&(1103)&&(1104)}%context_save_accumulator_a
128=%{(1209)&&(1100)&&(1103)&&(1105)}%context_save_accumulator_b
129=%{(1209)&&(1100)&&(1106)}%context_save_core_config
130=%{(1209)&&(1100)&&(1107)}%context_save_core_status
131=%{(1209)&&(1200)&&(1202)}%core_config
132=%{(1209)}%comp_read_input
133=%{(1209)&&(1400)&&(1401)}%shadow_copy_control_input_raw
134=%{(1209)&&(1600)&&(1601)}%comp_zero_input
135=%{(1209)&&(1400)&&(1402)}%shadow_copy_control_input_compensated
136=%{(1209)&&(1600)&&(1602)}%comp_invert_input
137=%{(1209)}%comp_get_error
138=%{(1209)&&(1200)&&(1205)}%comp_norm_error
139=%{(1209)&&(1400)&&(1403)}%shadow_copy_error_input
140=%{(1209)}%pterm_comp_load_gain_factor
141=%{(1209)}%pterm_comp_exec_pterm
142=%{(1209)&&(1500)}%%{(1501)||(1503)}%anti_windup
143=%{(1209)&&(1500)&&(1501)}%%{(!1300)||(!1302)||(1303)}%anti_windup_max_start
144=%{(1209)&&(1500)&&(1501)&&(1300)&&(1302)&&(!1303)}%anti_windup_max_start_with_alt_target_switch
145=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start_pterm
146=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
147=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass_pterm
148=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start_pterm
149=%{(1209)&&(1500)&&(1501)}%anti_windup_max_override
150=%{(1209)&&(1500)&&(1501)&&(1505)}%anti_windup_debouncing
151=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag
152=%{(1209)&&(1500)&&(1501)}%anti_windup_max_options_end_pterm
153=%{(1209)&&(1500)&&(1503)}%%{(!1300)||(!1302)||(1303)}%anti_windup_min_start
154=%{(1209)&&(1500)&&(1503)&&(1300)&&(1302)&&(!1303)}%anti_windup_min_start_with_alt_target_switch
155=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start_pterm
156=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
157=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass_pterm
158=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start_pterm
159=%{(1209)&&(1500)&&(1503)}%anti_windup_min_override
160=%{(1209)&&(1500)&&(1503)&&(1505)}%anti_windup_debouncing
161=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag
162=%{(1209)&&(1500)&&(1503)}%anti_windup_min_options_end_pterm
163=%{(1209)}%comp_writeback_start
164=%{(1209)&&(1300)&&(1302)&&(!1303)}%comp_writeback_to_alt_target_switch
165=%{(1209)}%comp_writeback_end
166=%{(1209)&&(1300)&&(1302)&&(1303)}%comp_writeback_mirror_to_alt_target
167=%{(1209)&&(1400)&&(1404)}%shadow_copy_control_output
168=%{(1209)&&(1200)}%%{(1206)||(1207)}%adc_trigger_placement_start
169=%{(1209)&&(1200)&&(1206)&&(1207)}%adc_trigger_b_placement
170=%{(1209)&&(1200)&&(1206)}%adc_trigger_a_placement
171=%{(1209)&&(1100)}%context_restore
172=%{(1209)&&(1100)&&(1107)}%context_restore_core_status
173=%{(1209)&&(1100)&&(1106)}%context_restore_core_config
174=%{(1209)&&(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
175=%{(1209)&&(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
176=%{(1209)&&(1100)&&(1102)}%context_restore_mac_registers
177=%{(1209)&&(1200)&&(1203)&&(!1204)}%enable_disable_end_pterm
178=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_pterm<SRTCC1>
179=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input_raw<SRTCC1>
180=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1600)&&(1601)}%%{(1402)||(1403)}%comp_zero_input<SRTCC1>
181=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1600)&&(1602)}%%{(1402)||(1403)}%comp_invert_input<SRTCC1>
182=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1402)}%shadow_copy_control_input_compensated<SRTCC1>
183=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1403)}%comp_get_error<SRTCC1>
184=%{(1209)&&(1200)&&(1203)&&(1204)&&(1205)&&(1400)&&(1403)}%comp_norm_error<SRTCC1>
185=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1403)}%shadow_copy_error_input<SRTCC1>
186=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1404)}%shadow_copy_control_output_zeroed_when_disabled<SRTCC1>
187=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end_pterm
188=%{(1209)&&(1300)&&(1304)}%cascaded_function_call
189=%{(1209)&&(1100)&&(1101)}%context_restore
190=%{(1209)&&(1100)&&(1101)}%context_restore_shadow
191=%{(1209)}%return
192=end
193=tool_link


[execlist_dbsft]
description=Instruction blockset for double-bit shifted 16-bit fixed point controllers
name=Dual Bitshift-Scaling Mode
wreg_usage=0,1,2,3,4,6,8,10
accu_usage=ab
coeff_addr_offset=4
data_addr_offset=2
count=195
0=version_header
1=version_header_filter_info
2=lists
3=section_header
4=%{(9001)}%include_header
5=%{(!9001)}%npnz16b_global_flags
6=%{(!9001)}%npnz16b_data_structure
7=section_code
8=exec_function_head<RTCCTRG0>
9=%{(1100)&&(1101)}%context_save
10=%{(1100)&&(1101)}%context_save_shadow
11=%{(1200)&&(1203)}%enable_disable_start
12=%{(1100)}%context_save
13=%{(1100)&&(1102)}%context_save_mac_registers
14=%{(1100)&&(1103)&&(1104)}%context_save_accumulator_a
15=%{(1100)&&(1103)&&(1105)}%context_save_accumulator_b
16=%{(1100)&&(1106)}%context_save_core_config
17=%{(1100)&&(1107)}%context_save_core_status
18=%{(1200)&&(1202)}%core_config
19=load_a_coeff_array_ptr
20=load_control_history_array_ptr
21=comp_mac_start_acca_clear_prefetch
22=comp_mac_loop_a_term_acca
23=comp_mac_end_acca
24=comp_backward_norm_a_acca
25=%{(0000)}%load_error_history_array_ptr
26=comp_error_history_update
27=comp_read_input<RTCCTRG1>
28=%{(1400)&&(1401)}%shadow_copy_control_input_raw
29=%{(1600)&&(1601)}%comp_zero_input
30=%{(1600)&&(1602)}%comp_invert_input
31=%{(1400)&&(1402)}%shadow_copy_control_input_compensated
32=comp_get_error
33=%{(1200)&&(1205)}%comp_norm_error
34=%{(1400)&&(1403)}%shadow_copy_error_input
35=load_b_coeff_array_ptr
36=comp_error_add_most_recent_to_history
37=comp_mac_start_accb_clear_prefetch
38=comp_mac_loop_b_term_accb
39=comp_mac_end_accb
40=comp_backward_norm_b_accb
41=%{(1800)}%agc_factor_multiply_start
42=%{(1800)&&(1801)}%agc_factor_multiply_enable_start
43=%{(1800)&&(!1810)}%agc_factor_multiply_store_accb
44=%{(1800)&&(1810)}%agc_factor_multiply_store_accb_high_res
45=%{(1800)&&(1802)}%agc_factor_multiply_factor_update_call
46=%{(1800)&&(!1810)}%agc_factor_multiply_scaled
47=%{(1800)&&(1810)}%agc_factor_multiply_scaled_high_res
48=%{(1800)&&(1801)}%agc_factor_multiply_enable_end
49=comp_add_accb_to_acca
50=comp_mac_store_acca
51=%{(1500)}%%{(1501)||(1503)}%anti_windup
52=%{(1500)&&(1506)}%anti_windup_output_saturation_start
53=%{(1500)&&(1501)}%%{(!1300)||(!1302)||(1303)}%anti_windup_max_start
54=%{(1500)&&(1501)&&(1300)&&(1302)&&(!1303)}%anti_windup_max_start_with_alt_target_switch
55=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start<SRTCC1>
56=%{(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
57=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass
58=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start
59=%{(1500)&&(1501)}%anti_windup_max_override<SRTCC1>
60=%{(1500)&&(1501)&&(1505)}%anti_windup_debouncing
61=%{(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag<SRTCC1>
62=%{(1500)&&(1501)}%anti_windup_max_options_end
63=%{(1500)&&(1503)}%%{(!1300)||(!1302)||(1303)}%anti_windup_min_start
64=%{(1500)&&(1503)&&(1300)&&(1302)&&(!1303)}%anti_windup_min_start_with_alt_target_switch
65=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start<SRTCC1>
66=%{(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
67=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass
68=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start
69=%{(1500)&&(1503)}%anti_windup_min_override<SRTCC1>
70=%{(1500)&&(1503)&&(1505)}%anti_windup_debouncing
71=%{(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag<SRTCC1>
72=%{(1500)&&(1503)}%anti_windup_min_options_end
73=comp_writeback_start
74=%{(1300)&&(1302)&&(!1303)}%comp_writeback_to_alt_target_switch
75=comp_writeback_end<RTCCTRG2>
76=%{(1300)&&(1302)&&(1303)}%comp_writeback_mirror_to_alt_target<RTCCTRG2>
77=%{(1400)&&(1404)}%shadow_copy_control_output
78=%{(1200)}%%{(1206)||(1207)}%adc_trigger_placement_start
79=%{(1200)&&(1207)}%adc_trigger_b_placement<RTCCTRG3>
80=%{(1200)&&(1206)}%adc_trigger_a_placement<RTCCTRG3>
81=load_control_history_array_ptr
82=comp_control_history_update
83=%{(1500)&&(1506)}%anti_windup_output_saturation_end
84=%{(!1500)||(!1506)}%comp_control_add_most_recent_to_history
85=%{(1100)}%context_restore
86=%{(1100)&&(1107)}%context_restore_core_status
87=%{(1100)&&(1106)}%context_restore_core_config
88=%{(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
89=%{(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
90=%{(1100)&&(1102)}%context_restore_mac_registers
91=%{(1200)&&(1203)&&(!1204)}%enable_disable_end
92=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read<SRTCC1>
93=%{(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input_raw<SRTCC1>
94=%{(1200)&&(1203)&&(1204)&&(1400)&&(1600)&&(1601)}%%{(1402)||(1403)}%comp_zero_input<SRTCC1>
95=%{(1200)&&(1203)&&(1204)&&(1400)&&(1600)&&(1602)}%%{(1402)||(1403)}%comp_invert_input<SRTCC1>
96=%{(1200)&&(1203)&&(1204)&&(1400)&&(1402)}%shadow_copy_control_input_compensated<SRTCC1>
97=%{(1200)&&(1203)&&(1204)&&(1400)&&(1403)}%comp_get_error<SRTCC1>
98=%{(1200)&&(1203)&&(1204)&&(1205)&&(1400)&&(1403)}%comp_norm_error<SRTCC1>
99=%{(1200)&&(1203)&&(1204)&&(1400)&&(1403)}%shadow_copy_error_input<SRTCC1>
100=%{(1200)&&(1203)&&(1204)&&(1400)&&(1404)}%shadow_copy_control_output_zeroed_when_disabled<SRTCC1>
101=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end
102=%{(1300)&&(1304)}%cascaded_function_call
103=%{(1100)&&(1101)}%context_restore
104=%{(1100)&&(1101)}%context_restore_shadow
105=return<RTCCTRG9>
106=reset_function_head
107=clear_control_history_start
108=clear_control_history_loop
109=clear_control_history_end
110=clear_error_history_start
111=clear_error_history_loop
112=clear_error_history_end
113=return
114=charge_function_head
115=charge_error_history_start
116=charge_error_history_loop
117=charge_error_history_end
118=charge_control_history_start
119=charge_control_history_loop
120=charge_control_history_end
121=return
122=%{(1209)}%pterm_function_head
123=%{(1209)&&(1100)&&(1101)}%context_save
124=%{(1209)&&(1100)&&(1101)}%context_save_shadow
125=%{(1209)&&(1200)&&(1203)}%enable_disable_start_pterm
126=%{(1209)&&(1100)}%context_save
127=%{(1209)&&(1100)&&(1102)}%context_save_mac_registers
128=%{(1209)&&(1100)&&(1103)&&(1104)}%context_save_accumulator_a
129=%{(1209)&&(1100)&&(1103)&&(1105)}%context_save_accumulator_b
130=%{(1209)&&(1100)&&(1106)}%context_save_core_config
131=%{(1209)&&(1100)&&(1107)}%context_save_core_status
132=%{(1209)&&(1200)&&(1202)}%core_config
133=%{(1209)}%comp_read_input
134=%{(1209)&&(1400)&&(1401)}%shadow_copy_control_input_raw
135=%{(1209)&&(1600)&&(1601)}%comp_zero_input
136=%{(1209)&&(1400)&&(1402)}%shadow_copy_control_input_compensated
137=%{(1209)&&(1600)&&(1602)}%comp_invert_input
138=%{(1209)}%comp_get_error
139=%{(1209)&&(1200)&&(1205)}%comp_norm_error
140=%{(1209)&&(1400)&&(1403)}%shadow_copy_error_input
141=%{(1209)}%pterm_comp_load_gain_factor
142=%{(1209)}%pterm_comp_exec_pterm
143=%{(1209)&&(1500)}%%{(1501)||(1503)}%anti_windup
144=%{(1209)&&(1500)&&(1501)}%%{(!1300)||(!1302)||(1303)}%anti_windup_max_start
145=%{(1209)&&(1500)&&(1501)&&(1300)&&(1302)&&(!1303)}%anti_windup_max_start_with_alt_target_switch
146=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start_pterm
147=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
148=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass_pterm
149=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start_pterm
150=%{(1209)&&(1500)&&(1501)}%anti_windup_max_override
151=%{(1209)&&(1500)&&(1501)&&(1505)}%anti_windup_debouncing
152=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag
153=%{(1209)&&(1500)&&(1501)}%anti_windup_max_options_end_pterm
154=%{(1209)&&(1500)&&(1503)}%%{(!1300)||(!1302)||(1303)}%anti_windup_min_start
155=%{(1209)&&(1500)&&(1503)&&(1300)&&(1302)&&(!1303)}%anti_windup_min_start_with_alt_target_switch
156=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start_pterm
157=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
158=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass_pterm
159=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start_pterm
160=%{(1209)&&(1500)&&(1503)}%anti_windup_min_override
161=%{(1209)&&(1500)&&(1503)&&(1505)}%anti_windup_debouncing
162=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag
163=%{(1209)&&(1500)&&(1503)}%anti_windup_min_options_end_pterm
164=%{(1209)}%comp_writeback_start
165=%{(1209)&&(1300)&&(1302)&&(!1303)}%comp_writeback_to_alt_target_switch
166=%{(1209)}%comp_writeback_end
167=%{(1209)&&(1300)&&(1302)&&(1303)}%comp_writeback_mirror_to_alt_target
168=%{(1209)&&(1400)&&(1404)}%shadow_copy_control_output
169=%{(1209)&&(1200)}%%{(1206)||(1207)}%adc_trigger_placement_start
170=%{(1209)&&(1200)&&(1206)&&(1207)}%adc_trigger_b_placement
171=%{(1209)&&(1200)&&(1206)}%adc_trigger_a_placement
172=%{(1209)&&(1100)}%context_restore
173=%{(1209)&&(1100)&&(1107)}%context_restore_core_status
174=%{(1209)&&(1100)&&(1106)}%context_restore_core_config
175=%{(1209)&&(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
176=%{(1209)&&(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
177=%{(1209)&&(1100)&&(1102)}%context_restore_mac_registers
178=%{(1209)&&(1200)&&(1203)&&(!1204)}%enable_disable_end_pterm
179=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_pterm<SRTCC1>
180=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input_raw<SRTCC1>
181=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1600)&&(1601)}%%{(1402)||(1403)}%comp_zero_input<SRTCC1>
182=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1600)&&(1602)}%%{(1402)||(1403)}%comp_invert_input<SRTCC1>
183=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1402)}%shadow_copy_control_input_compensated<SRTCC1>
184=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1403)}%comp_get_error<SRTCC1>
185=%{(1209)&&(1200)&&(1203)&&(1204)&&(1205)&&(1400)&&(1403)}%comp_norm_error<SRTCC1>
186=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1403)}%shadow_copy_error_input<SRTCC1>
187=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1404)}%shadow_copy_control_output_zeroed_when_disabled<SRTCC1>
188=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end_pterm
189=%{(1209)&&(1300)&&(1304)}%cascaded_function_call
190=%{(1209)&&(1100)&&(1101)}%context_restore
191=%{(1209)&&(1100)&&(1101)}%context_restore_shadow
192=%{(1209)}%return
193=end
194=tool_link


[execlist_fscl]
description=Instruction blockset for compensation filter computation using fast-floating point scaled coefficients
name=Fast Floating Point Coefficient Scaling Mode
wreg_usage=0,1,2,3,4,5,6,8,10
accu_usage=ab
coeff_addr_offset=4
data_addr_offset=2
count=194
0=version_header
1=version_header_filter_info
2=lists
3=section_header
4=%{(9001)}%include_header
5=%{(!9001)}%npnz16b_global_flags
6=%{(!9001)}%npnz16b_data_structure
7=section_code
8=exec_function_head<RTCCTRG0>
9=%{(1100)&&(1101)}%context_save
10=%{(1100)&&(1101)}%context_save_shadow
11=%{(1200)&&(1203)}%enable_disable_start
12=%{(1100)}%context_save
13=%{(1100)&&(1102)}%context_save_mac_registers_fscl
14=%{(1100)&&(1103)&&(1104)}%context_save_accumulator_a
15=%{(1100)&&(1103)&&(1105)}%context_save_accumulator_b
16=%{(1100)&&(1106)}%context_save_core_config
17=%{(1100)&&(1107)}%context_save_core_status
18=%{(1200)&&(1202)}%core_config
19=load_error_history_array_ptr
20=comp_error_history_update
21=comp_read_input<RTCCTRG1>
22=%{(1400)&&(1401)}%shadow_copy_control_input_raw
23=%{(1600)&&(1601)}%comp_zero_input
24=%{(1600)&&(1602)}%comp_invert_input
25=%{(1400)&&(1402)}%shadow_copy_control_input_compensated
26=comp_get_error
27=%{(1200)&&(1205)}%comp_norm_error
28=%{(1400)&&(1403)}%shadow_copy_error_input
29=load_b_coeff_array_ptr
30=comp_error_add_most_recent_to_history
31=fscl_comp_mac_start_clear
32=fscl_comp_mac_first
33=fscl_comp_mac_b_loop
34=fscl_comp_mac_end
35=%{(1800)}%agc_factor_multiply_start
36=%{(1800)&&(1801)}%agc_factor_multiply_enable_start
37=%{(1800)&&(!1810)}%agc_factor_multiply_store_accb
38=%{(1800)&&(1810)}%agc_factor_multiply_store_accb_high_res
39=%{(1800)&&(1802)}%agc_factor_multiply_factor_update_call
40=%{(1800)&&(!1810)}%agc_factor_multiply_scaled
41=%{(1800)&&(1810)}%agc_factor_multiply_scaled_high_res
42=%{(1800)&&(1801)}%agc_factor_multiply_enable_end
43=load_a_coeff_array_ptr
44=load_control_history_array_ptr
45=fscl_comp_mac_start_resume
46=fscl_comp_mac_first
47=fscl_comp_mac_a_loop
48=fscl_comp_mac_end
49=comp_mac_store_accb
50=%{(1500)}%%{(1501)||(1503)}%anti_windup
51=%{(1500)&&(1506)}%anti_windup_output_saturation_start
52=%{(1500)&&(1501)}%%{(!1300)||(!1302)||(1303)}%anti_windup_max_start
53=%{(1500)&&(1501)&&(1300)&&(1302)&&(!1303)}%anti_windup_max_start_with_alt_target_switch
54=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start<SRTCC1>
55=%{(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
56=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass
57=%{(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start
58=%{(1500)&&(1501)}%anti_windup_max_override<SRTCC1>
59=%{(1500)&&(1501)&&(1505)}%anti_windup_debouncing
60=%{(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag<SRTCC1>
61=%{(1500)&&(1501)}%anti_windup_max_options_end
62=%{(1500)&&(1503)}%%{(!1300)||(!1302)||(1303)}%anti_windup_min_start
63=%{(1500)&&(1503)&&(1300)&&(1302)&&(!1303)}%anti_windup_min_start_with_alt_target_switch
64=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start<SRTCC1>
65=%{(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
66=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass
67=%{(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start
68=%{(1500)&&(1503)}%anti_windup_min_override<SRTCC1>
69=%{(1500)&&(1503)&&(1505)}%anti_windup_debouncing
70=%{(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag<SRTCC1>
71=%{(1500)&&(1503)}%anti_windup_min_options_end
72=comp_writeback_start
73=%{(1300)&&(1302)&&(!1303)}%comp_writeback_to_alt_target_switch
74=comp_writeback_end<RTCCTRG2>
75=%{(1300)&&(1302)&&(1303)}%comp_writeback_mirror_to_alt_target<RTCCTRG2>
76=%{(1400)&&(1404)}%shadow_copy_control_output
77=%{(1200)}%%{(1206)||(1207)}%adc_trigger_placement_start
78=%{(1200)&&(1207)}%adc_trigger_b_placement<RTCCTRG3>
79=%{(1200)&&(1206)}%adc_trigger_a_placement<RTCCTRG3>
80=load_control_history_array_ptr
81=comp_control_history_update
82=%{(1500)&&(1506)}%anti_windup_output_saturation_end
83=%{(!1500)||(!1506)}%comp_control_add_most_recent_to_history
84=%{(1100)}%context_restore
85=%{(1100)&&(1107)}%context_restore_core_status
86=%{(1100)&&(1106)}%context_restore_core_config
87=%{(1100)&&(1103)&&(1105)}%context_restore_accumulator_b
88=%{(1100)&&(1103)&&(1104)}%context_restore_accumulator_a
89=%{(1100)&&(1102)}%context_restore_mac_registers_fscl
90=%{(1200)&&(1203)&&(!1204)}%enable_disable_end
91=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read
92=%{(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input_raw<SRTCC1>
93=%{(1200)&&(1203)&&(1204)&&(1400)&&(1600)&&(1601)}%%{(1402)||(1403)}%comp_zero_input<SRTCC1>
94=%{(1200)&&(1203)&&(1204)&&(1400)&&(1600)&&(1602)}%%{(1402)||(1403)}%comp_invert_input<SRTCC1>
95=%{(1200)&&(1203)&&(1204)&&(1400)&&(1402)}%shadow_copy_control_input_compensated<SRTCC1>
96=%{(1200)&&(1203)&&(1204)&&(1400)&&(1403)}%comp_get_error<SRTCC1>
97=%{(1200)&&(1203)&&(1204)&&(1205)&&(1400)&&(1403)}%comp_norm_error<SRTCC1>
98=%{(1200)&&(1203)&&(1204)&&(1400)&&(1403)}%shadow_copy_error_input<SRTCC1>
99=%{(1200)&&(1203)&&(1204)&&(1400)&&(1404)}%shadow_copy_control_output_zeroed_when_disabled<SRTCC1>
100=%{(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end<SRTCC1>
101=%{(1300)&&(1304)}%cascaded_function_call
102=%{(1100)&&(1101)}%context_restore
103=%{(1100)&&(1101)}%context_restore_shadow
104=return<RTCCTRG9>
105=reset_function_head
106=clear_control_history_start
107=clear_control_history_loop
108=clear_control_history_end
109=clear_error_history_start
110=clear_error_history_loop
111=clear_error_history_end
112=return
113=charge_function_head
114=charge_error_history_start
115=charge_error_history_loop
116=charge_error_history_end
117=charge_control_history_start
118=charge_control_history_loop
119=charge_control_history_end
120=return
121=%{(1209)}%pterm_function_head
122=%{(1209)&&(1100)&&(1101)}%context_save
123=%{(1209)&&(1100)&&(1101)}%context_save_shadow
124=%{(1209)&&(1200)&&(1203)}%enable_disable_start_pterm
125=%{(1209)&&(1100)}%context_save
126=%{(1209)&&(1100)&&(1102)}%context_save_mac_registers
127=%{(1209)&&(1100)&&(1103)&&(1104)}%context_save_accumulator_a
128=%{(1209)&&(1100)&&(1103)&&(1105)}%context_save_accumulator_b
129=%{(1209)&&(1100)&&(1106)}%context_save_core_config
130=%{(1209)&&(1100)&&(1107)}%context_save_core_status
131=%{(1209)&&(1200)&&(1202)}%core_config
132=%{(1209)}%comp_read_input
133=%{(1209)&&(1400)&&(1401)}%shadow_copy_control_input_raw
134=%{(1209)&&(1600)&&(1601)}%comp_zero_input
135=%{(1209)&&(1400)&&(1402)}%shadow_copy_control_input_compensated
136=%{(1209)&&(1600)&&(1602)}%comp_invert_input
137=%{(1209)}%comp_get_error
138=%{(1209)&&(1200)&&(1205)}%comp_norm_error
139=%{(1209)&&(1400)&&(1403)}%shadow_copy_error_input
140=%{(1209)}%pterm_comp_load_gain_factor
141=%{(1209)}%pterm_comp_exec_pterm
142=%{(1209)&&(1500)}%%{(1501)||(1503)}%anti_windup
143=%{(1209)&&(1500)&&(1501)}%%{(!1300)||(!1302)||(1303)}%anti_windup_max_start
144=%{(1209)&&(1500)&&(1501)&&(1300)&&(1302)&&(!1303)}%anti_windup_max_start_with_alt_target_switch
145=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_start_pterm
146=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_clear_status_flag
147=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_bypass_pterm
148=%{(1209)&&(1500)&&(1501)}%%{(1502)||(1505)}%anti_windup_max_options_override_start_pterm
149=%{(1209)&&(1500)&&(1501)}%anti_windup_max_override
150=%{(1209)&&(1500)&&(1501)&&(1505)}%anti_windup_debouncing
151=%{(1209)&&(1500)&&(1501)&&(1502)}%anti_windup_max_set_status_flag
152=%{(1209)&&(1500)&&(1501)}%anti_windup_max_options_end_pterm
153=%{(1209)&&(1500)&&(1503)}%%{(!1300)||(!1302)||(1303)}%anti_windup_min_start
154=%{(1209)&&(1500)&&(1503)&&(1300)&&(1302)&&(!1303)}%anti_windup_min_start_with_alt_target_switch
155=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_start_pterm
156=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_clear_status_flag
157=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_bypass_pterm
158=%{(1209)&&(1500)&&(1503)}%%{(1504)||(1505)}%anti_windup_min_options_override_start_pterm
159=%{(1209)&&(1500)&&(1503)}%anti_windup_min_override
160=%{(1209)&&(1500)&&(1503)&&(1505)}%anti_windup_debouncing
161=%{(1209)&&(1500)&&(1503)&&(1504)}%anti_windup_min_set_status_flag
162=%{(1209)&&(1500)&&(1503)}%anti_windup_min_options_end_pterm
163=%{(1209)}%comp_writeback_start
164=%{(1209)&&(1300)&&(1302)&&(!1303)}%comp_writeback_to_alt_target_switch
165=%{(1209)}%comp_writeback_end
166=%{(1209)&&(1300)&&(1302)&&(1303)}%comp_writeback_mirror_to_alt_target
167=%{(1209)&&(1400)&&(1404)}%shadow_copy_control_output
168=%{(1209)&&(1200)}%%{(1206)||(1207)}%adc_trigger_placement_start
169=%{(1209)&&(1200)&&(1206)&&(1207)}%adc_trigger_b_placement
170=%{(1209)&&(1200)&&(1206)}%adc_trigger_a_placement
171=%{(1209)&&(1100)}%context_restore
172=%{(1209)&&(1100)&&(1107)}%context_restore_core_status<SRTCC1>
173=%{(1209)&&(1100)&&(1106)}%context_restore_core_config<SRTCC1>
174=%{(1209)&&(1100)&&(1103)&&(1105)}%context_restore_accumulator_b<SRTCC1>
175=%{(1209)&&(1100)&&(1103)&&(1104)}%context_restore_accumulator_a<SRTCC1>
176=%{(1209)&&(1100)&&(1102)}%context_restore_mac_registers<SRTCC1>
177=%{(1209)&&(1200)&&(1203)&&(!1204)}%enable_disable_end_pterm<SRTCC1>
178=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_pterm<SRTCC1>
179=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1401)}%shadow_copy_control_input_raw<SRTCC1>
180=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1600)&&(1601)}%%{(1402)||(1403)}%comp_zero_input<SRTCC1>
181=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1600)&&(1602)}%%{(1402)||(1403)}%comp_invert_input
182=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1402)}%shadow_copy_control_input_compensated
183=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1403)}%comp_get_error
184=%{(1209)&&(1200)&&(1203)&&(1204)&&(1205)&&(1400)&&(1403)}%comp_norm_error
185=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1403)}%shadow_copy_error_input
186=%{(1209)&&(1200)&&(1203)&&(1204)&&(1400)&&(1404)}%shadow_copy_control_output_zeroed_when_disabled
187=%{(1209)&&(1200)&&(1203)&&(1204)}%enable_disable_end_dummy_read_end_pterm
188=%{(1209)&&(1300)&&(1304)}%cascaded_function_call
189=%{(1209)&&(1100)&&(1101)}%context_restore
190=%{(1209)&&(1100)&&(1101)}%context_restore_shadow
191=%{(1209)}%return
192=end
193=tool_link


[asm:blocks]
count=177
0=disclaimer
1=version_header
2=version_header_filter_info
3=tool_link
4=lists
5=section_header
6=npnz16b_global_flags
7=include_header
8=include_header_end
9=npnz16b_data_structure
10=section_code
11=exec_function_head
12=reset_function_head
13=charge_function_head
14=pterm_function_head
15=clear_control_history_start
16=clear_control_history_loop
17=clear_control_history_end
18=clear_error_history_start
19=clear_error_history_loop
20=clear_error_history_end
21=charge_control_history_start
22=charge_control_history_loop
23=charge_control_history_end
24=charge_error_history_start
25=charge_error_history_loop
26=charge_error_history_end
27=context_save
28=context_restore
29=context_save_shadow
30=context_save_mac_registers
31=context_save_accumulator_a
32=context_save_accumulator_b
33=context_save_core_config
34=context_save_core_status
35=context_restore_shadow
36=context_restore_mac_registers
37=context_restore_accumulator_a
38=context_restore_accumulator_b
39=context_restore_core_config
40=context_restore_core_status
41=enable_disable_start
42=enable_disable_start_pterm
43=enable_disable_end_dummy_read
44=enable_disable_end_dummy_read_pterm
45=enable_disable_end_dummy_read_end
46=enable_disable_end_dummy_read_end_pterm
47=enable_disable_end
48=enable_disable_end_pterm
49=core_config
50=cascaded_function_call
51=anti_windup
52=anti_windup_debouncing
53=anti_windup_output_saturation_start
54=anti_windup_output_saturation_end
55=anti_windup_max_start
56=anti_windup_max_start_with_alt_target_switch
57=anti_windup_max_options_start
58=anti_windup_max_options_start_pterm
59=anti_windup_max_options_override_bypass
60=anti_windup_max_options_override_bypass_pterm
61=anti_windup_max_options_override_start
62=anti_windup_max_options_override_start_pterm
63=anti_windup_max_set_status_flag
64=anti_windup_max_clear_status_flag
65=anti_windup_max_override
66=anti_windup_max_options_end
67=anti_windup_max_options_end_pterm
68=anti_windup_min_start
69=anti_windup_min_start_with_alt_target_switch
70=anti_windup_min_options_start
71=anti_windup_min_options_start_pterm
72=anti_windup_min_options_override_bypass
73=anti_windup_min_options_override_bypass_pterm
74=anti_windup_min_options_override_start
75=anti_windup_min_options_override_start_pterm
76=anti_windup_min_set_status_flag
77=anti_windup_min_clear_status_flag
78=anti_windup_min_override
79=anti_windup_min_options_end
80=anti_windup_min_options_end_pterm
81=comp_read_input
82=comp_read_input_from_alt_source_switch
83=comp_zero_input
84=comp_invert_input
85=shadow_copy_control_input_raw
86=shadow_copy_control_input_compensated
87=comp_get_error
88=comp_norm_error
89=shadow_copy_error_input
90=shadow_copy_control_output
91=shadow_copy_control_output_zeroed_when_disabled
92=comp_error_history_update
93=comp_error_history_update_reverse
94=comp_error_add_most_recent_to_mac
95=comp_error_add_most_recent_to_history
96=comp_error_add_most_recent_to_history_reverse
97=comp_control_history_update
98=comp_control_history_update_reverse
99=comp_control_add_most_recent_to_history
100=comp_control_add_most_recent_to_history_reverse
101=comp_control_add_most_recent_to_history_indirect
102=load_a_coeff_array_ptr
103=load_a_coeff_array_ptr_reverse
104=load_b_coeff_array_ptr
105=load_b_coeff_array_ptr_reverse
106=load_b0_coeff_to_wreg
107=load_error_history_array_ptr
108=load_error_history_array_ptr_reverse
109=load_error_history_before_update_array_ptr
110=load_error_history_before_update_array_ptr_reverse
111=load_control_history_array_ptr
112=load_control_history_array_ptr_reverse
113=load_control_history_before_update_array_ptr
114=load_control_history_array_before_update_ptr_reverse
115=comp_mac_start_acca_clear_no_prefetch
116=comp_mac_start_acca_clear_prefetch
117=comp_mac_start_acca_reverse_clear
118=comp_mac_start_acca_resume
119=comp_mac_start_acca_reverse_resume
120=comp_mac_start_accb_clear_no_prefetch
121=comp_mac_start_accb_clear_prefetch
122=comp_mac_start_accb_reverse_clear
123=comp_mac_start_accb_resume
124=comp_mac_start_accb_reverse_resume
125=comp_mac_loop_a_term_acca
126=comp_mac_loop_a_term_reverse_acca
127=comp_mac_loop_a_term_accb
128=comp_mac_loop_a_term_reverse_accb
129=comp_mac_loop_b_term_acca
130=comp_mac_loop_b_term_reverse_acca
131=comp_mac_loop_b_term_accb
132=comp_mac_loop_b_term_reverse_accb
133=comp_mac_end_acca
134=comp_mac_end_accb
135=comp_backward_norm_a_acca
136=comp_backward_norm_a_accb
137=comp_backward_norm_b_acca
138=comp_backward_norm_b_accb
139=comp_backward_norm_coeff_scaler_acca
140=comp_mac_store_acca
141=comp_mac_store_accb
142=comp_mac_load32b_a
143=comp_mac_load32b_accb
144=comp_mac_store32b_a
145=comp_mac_store32b_accb
146=comp_add_acca_to_accb
147=comp_add_accb_to_acca
148=comp_writeback_start
149=comp_writeback_to_alt_target_switch
150=comp_writeback_end
151=comp_writeback_mirror_to_alt_target
152=comp_writeback_ssm
153=adc_trigger_placement_start
154=adc_trigger_a_placement
155=adc_trigger_b_placement
156=return
157=end
158=context_save_mac_registers_fscl
159=context_restore_mac_registers_fscl
160=fscl_comp_mac_start_clear
161=fscl_comp_mac_start_resume
162=fscl_comp_mac_first
163=fscl_comp_mac_a_loop
164=fscl_comp_mac_b_loop
165=fscl_comp_mac_end
166=pterm_comp_load_gain_factor
167=pterm_comp_exec_pterm
168=agc_factor_multiply_start
169=agc_factor_multiply_enable_start
170=agc_factor_multiply_enable_end
171=agc_factor_multiply_store_accb_high_res
172=agc_factor_multiply_store_accb
173=agc_factor_multiply_factor_update_call
174=agc_factor_multiply_scaled_high_res
175=agc_factor_multiply_scaled
176=agc_factor_get_factor

[disclaimer]
head_comment=%NOIDENT%;LICENSE / DISCLAIMER 
cycles=0
lines=3
comment0=%EMPTY%
code0=%NOIDENT%; **********************************************************************************
code1=%NOIDENT%; Microchip Technology Inc. and its subsidiaries.  You may use this software \n;  and any derivatives exclusively with Microchip products. \n;  \n;  THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER \n;  EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED \n;  WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A \n;  PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION \n;  WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION. \n;  \n;  IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, \n;  INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND \n;  WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS \n;  BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.  TO THE \n;  FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS \n;  IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF \n;  ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE. \n;  \n;  MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE \n;  TERMS.
code2=%NOIDENT%; **********************************************************************************

[version_header]
head_comment=%EMPTY%
cycles=0
lines=6
comment0=%EMPTY%
code0=%NOIDENT%; **********************************************************************************
code1=%NOIDENT%;  SDK Version: %APP_PRODUCT_NAME% v%APP_PRODUCT_VERSION% 
code2=%NOIDENT%;  CGS Version: %CGS_NAME% v%CGS_VERSION% (%CGS_VERSION_DATE%)
code3=%NOIDENT%;  Author:      %USER_NAME%
code4=%NOIDENT%;  Date/Time:   %DATE_TIME_NOW%
code5=%NOIDENT%; **********************************************************************************

[version_header_filter_info]
head_comment=%EMPTY%
cycles=0
lines=2
comment0=%EMPTY%
code0=%NOIDENT%;  %FILTER_ORDER%P%FILTER_ORDER%Z Control Library File (%SCALING_MODE_DESCIPTION%)
code1=%NOIDENT%; **********************************************************************************

[tool_link]
head_comment=\n%SPACE%\n; **********************************************************************************\n;  Download latest version of this tool here: %TOOL_HOME_URL%\n; **********************************************************************************
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%

[lists]
head_comment=%SEPARATOR%;file start
cycles=0
lines=2
comment0=(no external dependencies)
comment1=list of all external dependencies
code0=.nolist
code1=.list

[section_header]
head_comment=%SEPARATOR%;local inclusions.
cycles=0
lines=1
comment0=place constant data in the data section
code0=.section .data

[npnz16b_global_flags]
head_comment=%SEPARATOR%; Define status flags bit positions
cycles=0
lines=7
comment0=bit position of the ENABLE control bit
comment1=bit position of the INVERT_INPUT control bit
comment2=bit position of the SWAP_SOURCE control bit
comment3=bit position of the SWAP_TARGET control bit
comment4=bit position of the AGC_ENABLED control bit
comment5=bit position of the UPPER_SATURATION_FLAG status bit
comment6=bit position of the LOWER_SATURATION_FLAG status bit
code0=.equ NPNZ16_STATUS_ENABLED,      15
code1=.equ NPNZ16_STATUS_INVERT_INPUT, 14
code2=.equ NPNZ16_STATUS_SWAP_SOURCE,  13
code3=.equ NPNZ16_STATUS_SWAP_TARGET,  12
code4=.equ NPNZ16_STATUS_AGC_ENABLED,  11
code5=.equ NPNZ16_STATUS_USAT,         1
code6=.equ NPNZ16_STATUS_LSAT,         0

[include_header]
head_comment=%SEPARATOR%;include NPNZ16B_t data structure and global constants.
cycles=0
lines=1
comment0=include NPNZ16b_t object data structure value offsets and status flag labels
code0=.include "%ASM_INCLUDE_FILE%"

[include_header_end]
head_comment=%SEPARATOR%;end of include of NPNZ16B_t data structure and global constants
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%

[npnz16b_data_structure]
head_comment=%SEPARATOR%; NPNZ16b_t data structure address offset declarations for data structure addressing
cycles=0
lines=54
comment0=controller object status word at address-offset = 0
comment1=parameter group Ports.Source: pointer to source memory address
comment2=parameter group Ports.Source: bit-shift scaler of normalization factor
comment3=parameter group Ports.Source: Q15 normalization factor
comment4=parameter group Ports.Source: value of source input signal/value offset
comment5=parameter group Ports.AltSource: pointer to alternate source memory address
comment6=parameter group Ports.AltSource: bit-shift scaler of normalization factor
comment7=parameter group Ports.AltSource: Q15 normalization factor
comment8=parameter group Ports.AltSource: value of alternate source input signal/value offset
comment9=parameter group Ports.Target: pointer to target memory address
comment10=parameter group Ports.Target: bit-shift scaler of normalization factor
comment11=parameter group Ports.Target: Q15 normalization factor
comment12=parameter group Ports.Target: value of target output signal/value offset
comment13=parameter group Ports.AltTarget: pointer to alternate target memory address
comment14=parameter group Ports.AltTarget: bit-shift scaler of normalization factor
comment15=parameter group Ports.AltTarget: Q15 normalization factor
comment16=parameter group Ports.AltTarget: value of alternate target output signal/value offset
comment17=parameter group Ports.ConrolReference: pointer to control reference variable/register memory address
comment18=parameter group Filter: pointer to A-coefficients array start address
comment19=parameter group Filter: pointer to B-coefficients array start address
comment20=parameter group Filter: pointer to control history array start address
comment21=parameter group Filter: pointer to error history array start address
comment22=parameter group Filter: size of the A-coefficients array
comment23=parameter group Filter: size of the B-coefficients array
comment24=parameter group Filter: size of the control history array
comment25=parameter group Filter: size of the error history array
comment26=parameter group Filter: value of input value normalization bit-shift scaler
comment27=parameter group Filter: value of A-term normalization bit-shift scaler
comment28=parameter group Filter: value of B-term normalization bit-shift scaler
comment29=parameter group Filter: control loop output normalization factor
comment30=parameter group Filter: P-Term coefficient scaler
comment31=parameter group Filter: P-Term coefficient fractional factor
comment32=parameter group Limits: minimum clamping value of primary control output 
comment33=parameter group Limits: maximum clamping value of primary control output 
comment34=parameter group Limits: minimum clamping value of alternate control output 
comment35=parameter group Limits: maximum clamping value of alternate control output 
comment36=parameter group ADCTriggerControl: pointer to ADC trigger A register memory address
comment37=parameter group ADCTriggerControl: value of ADC trigger A offset
comment38=parameter group ADCTriggerControl: pointer to ADC trigger B register memory address
comment39=parameter group ADCTriggerControl: value of ADC trigger B offset
comment40=parameter group DataProviders: pointer to external variable/register the most recent, raw control input will be pushed to
comment41=parameter group DataProviders: pointer to external variable/register the most recent, compensated control input will be pushed to
comment42=parameter group DataProviders: pointer to external variable/register the most recent control error will be pushed to
comment43=parameter group DataProviders: pointer to external variable/register the most recent control output will be pushed to
comment44=parameter group CascadeTrigger: pointer to external, cascaded function which will be called by this controller
comment45=parameter group CascadeTrigger: 16-bit wide function parameter or pointer to a parameter data structure of cascaded function
comment46=parameter group GainControl: bit-shift scaler of Adaptive Gain Control Modulation factor
comment47=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation factor
comment48=parameter group GainControl: Q15 value of Adaptive Gain Control Modulation nominal operating point
comment49=parameter group GainControl: function pointer to observer function updating the AGC modulation factor
comment50=parameter group Advanced: generic 16-bit wide, user-defined parameter #1 for user-defined, advanced control options
comment51=parameter group Advanced: generic 16-bit wide, user-defined parameter #2 for user-defined, advanced control options
comment52=parameter group Advanced: generic 16-bit wide, user-defined parameter #3 for user-defined, advanced control options
comment53=parameter group Advanced: generic 16-bit wide, user-defined parameter #4 for user-defined, advanced control options
code0=.equ Status,                    0
code1=.equ ptrSourceRegister,         2
code2=.equ SourceNormShift,           4
code3=.equ SourceNormFactor,          6
code4=.equ SourceOffset,              8
code5=.equ ptrAltSourceRegister,      10
code6=.equ AltSourceNormShift,        12
code7=.equ AltSourceNormFactor,       14
code8=.equ AltSourceOffset,           16
code9=.equ ptrTargetRegister,         18
code10=.equ TargetNormShift,           20
code11=.equ TargetNormFactor,          22
code12=.equ TargetOffset,              24
code13=.equ ptrAltTargetRegister,      26
code14=.equ AltTargetNormShift,        28
code15=.equ AltTargetNormFactor,       30
code16=.equ AltTargetOffset,           32
code17=.equ ptrControlReference,       34
code18=.equ ptrACoefficients,          36
code19=.equ ptrBCoefficients,          38
code20=.equ ptrControlHistory,         40
code21=.equ ptrErrorHistory,           42
code22=.equ ACoefficientsArraySize,    44
code23=.equ BCoefficientsArraySize,    46
code24=.equ ControlHistoryArraySize,   48
code25=.equ ErrorHistoryArraySize,     50
code26=.equ normPreShift,              52
code27=.equ normPostShiftA,            54
code28=.equ normPostShiftB,            56
code29=.equ normPostScaler,            58
code30=.equ PTermScaler,               60
code31=.equ PTermFactor,               62
code32=.equ MinOutput,                 64
code33=.equ MaxOutput,                 66
code34=.equ AltMinOutput,              68
code35=.equ AltMaxOutput,              70
code36=.equ ptrADCTriggerARegister,    72
code37=.equ ADCTriggerAOffset,         74
code38=.equ ptrADCTriggerBRegister,    76
code39=.equ ADCTriggerBOffset,         78
code40=.equ ptrDProvControlInput,      80
code41=.equ ptrDProvControlInputComp,  82
code42=.equ ptrDProvControlError,      84
code43=.equ ptrDProvControlOutput,     86
code44=.equ ptrCascadedFunction,       88
code45=.equ CascadedFunctionParam,     90
code46=.equ AgcScaler,                 92
code47=.equ AgcFactor,                 94
code48=.equ AgcMedian,                 96
code49=.equ ptrAgcObserverFunction,    98
code50=.equ usrParam1,                 100
code51=.equ usrParam2,                 102
code52=.equ usrParam3,                 104
code53=.equ usrParam4,                 106

[section_code]
head_comment=%SEPARATOR%;source code section.
cycles=0
lines=1
comment0=place code in the text section
;code0=;.section .libdsp, code
code0=.section .text

[exec_function_head]
head_comment=%SEPARATOR%; Global function declaration\n; This function calls the z-domain controller processing the latest data point input%SEPARATOR%
cycles=0
lines=2
comment0=provide global scope to routine
comment1=local function label
code0=.global _%PREFIX%_Update
code1=_%PREFIX%_Update:\n

[reset_function_head]
head_comment=%SEPARATOR%; Global function declaration %PREFIX%_Reset\n; This function clears control and error histories enforcing a reset%SEPARATOR%
cycles=0
lines=2
comment0=provide global scope to routine
comment1=local function label
code0=.global _%PREFIX%_Reset
code1=_%PREFIX%_Reset:

[charge_function_head]
head_comment=%SEPARATOR%; Global function declaration %PREFIX%_Precharge\n; This function loads user-defined default values into control and error histories%SEPARATOR%
cycles=0
lines=2
comment0=provide global scope to routine
comment1=local function label
code0=.global _%PREFIX%_Precharge
code1=_%PREFIX%_Precharge:

[pterm_function_head]
head_comment=%SEPARATOR%; Global function declaration %PREFIX%_PTermUpdate\n; This function executes a P-term based control loop used for plant measurements only.\n; THIS LOOP IS NOT SUITED FOR STABLE OPERATION%SEPARATOR%
cycles=0
lines=2
comment0=provide global scope to routine
comment1=local function label
code0=.global _%PREFIX%_PTermUpdate
code1=_%PREFIX%_PTermUpdate:

[clear_control_history_start]
head_comment=%SEPARATOR%; Clear control history array
cycles=0
lines=2
comment0=save contents of working register WREG0
comment1=set pointer to the base address of control history array
code0=push w0
code1=mov [w0 + #ptrControlHistory], w0

[clear_control_history_loop]
address_loop=a
head_comment=%EMPTY%
cycles=0
lines=1
comment0=clear next address of control history array
code0=clr [w0++]

[clear_control_history_end]
head_comment=%EMPTY%
cycles=0
lines=2
comment0=clear last address of control history array
comment1=restore contents of working register WREG0
code0=clr [w0]
code1=pop w0

[clear_error_history_start]
head_comment=%SEPARATOR%; Clear error history array
cycles=0
lines=2
comment0=save contents of working register WREG0
comment1=set pointer to the base address of error history array
code0=push w0
code1=mov [w0 + #ptrErrorHistory], w0

[clear_error_history_loop]
address_loop=b
head_comment=%EMPTY%
cycles=0
lines=1
comment0=Clear next address of error history array
code0=clr [w0++]

[clear_error_history_end]
head_comment=%EMPTY%
cycles=0
lines=2
comment0=clear last address of error history array
comment1=restore contents of working register WREG0
code0=clr [w0]
code1=pop w0

[charge_control_history_start]
head_comment=%SEPARATOR%; Charge control history array with defined value
cycles=0
lines=3
comment0=save contents of working register WREG0
comment1=save contents of working register WREG2
comment2=set pointer to the base address of control history array
code0=push w0
code1=push w2
code2=mov  [w0 + #ptrControlHistory], w0

[charge_control_history_loop]
address_loop=a
head_comment=%EMPTY%
cycles=0
lines=1
comment0=Load user value into next address of control history array
code0=mov w2, [w0++]

[charge_control_history_end]
head_comment=%EMPTY%
cycles=0
lines=3
comment0=Load user value into last address of control history array
comment1=restore contents of working register WREG2
comment2=restore contents of working register WREG0
code0=mov w2, [w0]
code1=pop w2
code2=pop w0

[charge_error_history_start]
head_comment=%SEPARATOR%; Charge error history array with defined value
cycles=0
lines=3
comment0=save contents of working register WREG0
comment1=save contents of working register WREG1
comment2=set pointer to the base address of error history array
code0=push w0
code1=push w1
code2=mov  [w0 + #ptrErrorHistory], w0

[charge_error_history_loop]
address_loop=b
head_comment=%EMPTY%
cycles=0
lines=1
comment0=Load user value into next address of error history array
code0=mov w1, [w0++]

[charge_error_history_end]
head_comment=%EMPTY%
cycles=0
lines=3
comment0=load user value into last address of error history array
comment1=restore contents of working register WREG1
comment2=restore contents of working register WREG0
code0=mov w1, [w0]
code1=pop w1
code2=pop w0

[context_save]
head_comment=%SEPARATOR%; Save working registers
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%		

[context_restore]
head_comment=%SEPARATOR%; Restore working registers in reverse order
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%		

[context_save_shadow]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=save shadowed working registers (WREG0, WREG1, WREG2, WREG3)
code0=push.s		

[context_save_mac_registers]
item_loop=wreg_usage
head_comment=%EMPTY%
cycles=4
lines=4
comment0=save MAC operation working register WREG4
comment1=save MAC operation working register WREG6
comment2=save MAC operation working register WREG8
comment3=save MAC operation working register WREG10
code0=push w4
code1=push w6
code2=push w8
code3=push w10

[context_save_accumulator_a]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=save accumulator A register (LOW WORD:   bit <15…0>)
comment1=save accumulator A register (HIGH WORD:  bit <31…16>)
comment2=save accumulator A register (UPPER BYTE: bit <39…32>)
code0=push ACCAL
code1=push ACCAH
code2=push ACCAU

[context_save_accumulator_b]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=save accumulator B register (LOW WORD:   bit <15…0>)
comment1=save accumulator B register (HIGH WORD:  bit <31…16>)
comment2=save accumulator B register (UPPER BYTE: bit <39…32>)
code0=push ACCBL
code1=push ACCBH
code2=push ACCBU

[context_save_core_config]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=save CPU configuration register
code0=push CORCON

[context_save_core_status]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=save CPU status register
code0=push SR

[context_restore_shadow]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=restore shadowed working registers (WREG0, WREG1, WREG2, WREG3)
code0=pop.s		

[context_restore_mac_registers]
head_comment=%EMPTY%
cycles=4
lines=4
comment0=restore MAC operation working register WREG10
comment1=restore MAC operation working register WREG8
comment2=restore MAC operation working register WREG6
comment3=restore MAC operation working register WREG4
code0=pop w10
code1=pop w8
code2=pop w6
code3=pop w4

[context_restore_accumulator_a]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=restore accumulator A register (UPPER BYTE: bit <39…32>)
comment1=restore accumulator A register (HIGH WORD:  bit <31…16>)
comment2=restore accumulator A register (LOW WORD:   bit <15…0>)
code0=pop ACCAU
code1=pop ACCAH
code2=pop ACCAL

[context_restore_accumulator_b]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=restore accumulator B register (UPPER BYTE: bit <39…32>)
comment1=restore accumulator B register (HIGH WORD:  bit <31…16>)
comment2=restore accumulator B register (LOW WORD:   bit <15…0>)
code0=pop ACCBU
code1=pop ACCBH
code2=pop ACCBL

[context_restore_core_config]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=restore CPU configuration registers
code0=pop CORCON

[context_restore_core_status]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=restore CPU status registers
code0=pop SR

[enable_disable_start]
declaration=.equ NPNZ16_STATUS_ENABLED, 15
data_structure=.equ	Status, 0
head_comment=%SEPARATOR%; Check status word for Enable/Disable flag and bypass computation, if disabled
cycles=3
lines=2
comment0=check ENABLED bit state, skip (do not execute) next instruction if set
comment1=if ENABLED bit is cleared, jump to end of control code
code0=btss [w0], #NPNZ16_STATUS_ENABLED
code1=bra %PREFIXU%_LOOP_BYPASS

[enable_disable_start_pterm]
;declaration=.equ NPNZ16_STATUS_ENABLED, 15
;data_structure=.equ	Status, 0
head_comment=%SEPARATOR%; Check status word for Enable/Disable flag and bypass computation when disabled
cycles=3
lines=2
comment0=check ENABLED bit state, skip (do not execute) next instruction if set
comment1=if ENABLED bit is cleared, jump to end of control code
code0=btss [w0], #NPNZ16_STATUS_ENABLED
code1=bra %PREFIXU%_PTERM_LOOP_BYPASS

[enable_disable_end_dummy_read]
head_comment=%SEPARATOR%; Enable/Disable bypass branch target with dummy read of source buffer
cycles=2
lines=4
comment0=when enabled, step over dummy read and go straight to EXIT
comment1=Enable/Disable bypass branch target to perform dummy read of source to clear the source buffer
comment2=load pointer to input source register
comment3=move value from input source into working register
code0=goto %PREFIXU%_LOOP_EXIT
code1=%PREFIXU%_LOOP_BYPASS:
code2=mov [w0 + #ptrSourceRegister], w2
code3=mov [w2], w1 

[enable_disable_end_dummy_read_pterm]
head_comment=%SEPARATOR%; Enable/Disable bypass branch target with dummy read of source buffer
cycles=2
lines=4
comment0=when enabled, step over dummy read and go straight to EXIT
comment1=Enable/Disable bypass branch target to perform dummy read of source to clear the source buffer
comment2=load pointer to input source register
comment3=move value from input source into working register
code0=goto %PREFIXU%_PTERM_LOOP_EXIT
code1=%PREFIXU%_PTERM_LOOP_BYPASS:
code2=mov [w0 + #ptrSourceRegister], w2
code3=mov [w2], w1 

[enable_disable_end_dummy_read_end]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=Exit control loop branch target 
code0=%PREFIXU%_LOOP_EXIT:

[enable_disable_end_dummy_read_end_pterm]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=Exit P-Term control loop branch target 
code0=%PREFIXU%_PTERM_LOOP_EXIT:

[enable_disable_end]
head_comment=%SEPARATOR%; Enable/Disable bypass branch target
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_LOOP_BYPASS:

[enable_disable_end_pterm]
head_comment=%SEPARATOR%; Enable/Disable bypass branch target
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_PTERM_LOOP_BYPASS:

[core_config]
head_comment=%SEPARATOR%; Configure DSP for fractional operation with normal saturation (Q1.31 format)
cycles=2
lines=2
comment0=load default value of DSP core configuration enabling saturation and signed fractional multiply
comment1=load default configuration into CORCON register
code0=mov #0x00E4, w4
code1=mov w4, _CORCON

[cascaded_function_call]
head_comment=%SEPARATOR%; Call next function of cascade
cycles=6
lines=3
comment0=load function pointer to cascaded, extern function
comment1=load single parameter or pointer to parameter data structure
comment2=call function
code0=mov [w0 + #ptrCascadedFunction], w1
code1=mov [w0 + #CascadedFunctionParam], w0
code2=call w1

[anti_windup]
head_comment=%SEPARATOR%; Controller Anti-Windup (control output value clamping)
cycles=0
lines=0
comment0=%EMPTY%
code0=%EMPTY%

[anti_windup_debouncing]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load address of most recent item in error history
comment1=clear most recent error
code0=mov [w0 + #ptrErrorHistory], w6
code1=clr [w6]

[anti_windup_output_saturation_start]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=save copy of most recent control output in unused working register
code0=mov w4, w2

[anti_windup_output_saturation_end]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add copy of unlimited most recent control output to history
code0=mov w2, [w10]

[anti_windup_max_start]
head_comment=\n; Check for upper limit violation
cycles=4
lines=2
comment0=load upper limit value
comment1=compare values and skip next instruction if control output is within operating range (control output < upper limit)
code0=mov [w0 + #MaxOutput], w6
code1=cpslt w4, w6

[anti_windup_max_start_with_alt_target_switch]
head_comment=\n; Check for upper limit violation
cycles=5
lines=4
comment0=load upper limit value
comment1=compare values and skip next instruction if control output is within operating range (control output < upper limit)
comment2=if SWAP TARGET option is enabled, execute next instruction
comment3=overwrite primary maximum threshold value in working register with alternate maximum threshold value
code0=mov [w0 + #MaxOutput], w6
code1=btsc [w0], #NPNZ16_STATUS_SWAP_TARGET
code2=mov [w0 + #AltMaxOutput], w6
code3=cpslt w4, w6

[anti_windup_max_options_start]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=jump to override label if control output > upper limit
code0=bra %PREFIXU%_CLAMP_MAX_OVERRIDE

[anti_windup_max_options_start_pterm]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=jump to override label if control output > upper limit
code0=bra %PREFIXU%_PTERM_CLAMP_MAX_OVERRIDE

[anti_windup_max_options_override_bypass]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=jump to exit
code0=bra %PREFIXU%_CLAMP_MAX_EXIT

[anti_windup_max_options_override_bypass_pterm]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=jump to exit
code0=bra %PREFIXU%_PTERM_CLAMP_MAX_EXIT

[anti_windup_max_options_override_start]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_CLAMP_MAX_OVERRIDE:

[anti_windup_max_options_override_start_pterm]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_PTERM_CLAMP_MAX_OVERRIDE:

[anti_windup_max_set_status_flag]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=set upper limit saturation flag bit
code0=bset [w0], #NPNZ16_STATUS_USAT

[anti_windup_max_clear_status_flag]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=clear upper limit saturation flag bit
code0=bclr [w0], #NPNZ16_STATUS_USAT

[anti_windup_max_override]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=override controller output
code0=mov w6, w4

[anti_windup_max_options_end]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_CLAMP_MAX_EXIT:

[anti_windup_max_options_end_pterm]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_PTERM_CLAMP_MAX_EXIT:

[anti_windup_min_start]
head_comment=\n; Check for lower limit violation
cycles=4
lines=2
comment0=load lower limit value
comment1=compare values and skip next instruction if control output is within operating range (control output > lower limit)
code0=mov [w0 + #MinOutput], w6
code1=cpsgt w4, w6

[anti_windup_min_start_with_alt_target_switch]
head_comment=\n; Check for lower limit violation
cycles=5
lines=4
comment0=load lower limit threshold value
comment1=if SWAP TARGET option is enabled, execute next instruction
comment2=overwrite primary minimum threshold value in working register with alternate minimum threshold value
comment3=compare values and skip next instruction if control output is within operating range (control output > lower limit)
code0=mov [w0 + #MinOutput], w6
code1=btsc [w0], #NPNZ16_STATUS_SWAP_TARGET
code2=mov [w0 + #AltMinOutput], w6
code3=cpslt w4, w6

[anti_windup_min_options_start]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=jump to override label if control output < lower limit
code0=bra %PREFIXU%_CLAMP_MIN_OVERRIDE

[anti_windup_min_options_start_pterm]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=jump to override label if control output < lower limit
code0=bra %PREFIXU%_PTERM_CLAMP_MIN_OVERRIDE

[anti_windup_min_options_override_bypass]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=jump to exit
code0=bra %PREFIXU%_CLAMP_MIN_EXIT

[anti_windup_min_options_override_bypass_pterm]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=jump to exit
code0=bra %PREFIXU%_PTERM_CLAMP_MIN_EXIT

[anti_windup_min_options_override_start]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_CLAMP_MIN_OVERRIDE:

[anti_windup_min_options_override_start_pterm]
head_comment=%EMPTY%
cycles=2
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_PTERM_CLAMP_MIN_OVERRIDE:

[anti_windup_min_set_status_flag]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=set lower limit saturation flag bit
code0=bset [w0], #NPNZ16_STATUS_LSAT

[anti_windup_min_clear_status_flag]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=clear lower limit saturation flag bit
code0=bclr [w0], #NPNZ16_STATUS_LSAT

[anti_windup_min_override]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=override controller output
code0=mov w6, w4

[anti_windup_min_options_end]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_CLAMP_MIN_EXIT:

[anti_windup_min_options_end_pterm]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=%EMPTY%
code0=%PREFIXU%_PTERM_CLAMP_MIN_EXIT:

[comp_read_input]
head_comment=%SEPARATOR%; Read data from input source and calculate error input to transfer function
cycles=2
lines=2
comment0=load pointer to input source register
comment1=move value from input source into working register
code0=mov [w0 + #ptrSourceRegister], w2
code1=mov [w2], w1

[comp_read_input_from_alt_source_switch]
head_comment=%SEPARATOR%; Read data from primary or alternate input source and calculate error input to transfer function
cycles=5
lines=4
comment0=load pointer to primary input source register
comment1=test SWAP_SOURCE status bit in status word and skip following instruction if cleared
comment2=load pointer to alternate input source register
comment3=move value of primary or alternate input source into working register
code0=mov [w0 + #ptrSourceRegister], w2
code1=btsc [w0], #NPNZ16_STATUS_SWAP_SOURCE
code2=mov [w0 + #ptrAltSourceRegister], w2
code3=mov [w2], w1

[comp_zero_input]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load input offset value into working register
comment1=remove offset from control input
code0=mov [w0 + #SourceOffset], w2
code1=subr w2, w1, w1

[comp_invert_input]
head_comment=%EMPTY%
cycles=3
lines=2
comment0=Test control bit if value should be inverted
comment1=invert value
code0=btsc [w0], #NPNZ16_STATUS_INVERT_INPUT
code1=neg w1, w1

[shadow_copy_control_input_raw]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load pointer address of target buffer of most recent raw controller input from data structure
comment1=copy most recent controller input value to given data buffer target
code0=mov [w0 + #ptrDProvControlInput], w2
code1=mov w1, [w2]

[shadow_copy_control_input_compensated]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load pointer address of target buffer of most recent, compensated controller input from data structure
comment1=copy most recent controller input value to given data buffer target
code0=mov [w0 + #ptrDProvControlInputComp], w2
code1=mov w1, [w2]

[comp_get_error]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=move pointer to control reference into working register
comment1=calculate error (=reference - input)
code0=mov [w0 + #ptrControlReference], w2
code1=subr w1, [w2], w1

[comp_norm_error]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=move error input scaler into working register
comment1=normalize error result to fractional number format
code0=mov [w0 + #normPreShift], w2
code1=sl w1, w2, w1

[shadow_copy_error_input]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load pointer address of target buffer of most recent error value from data structure
comment1=copy most recent error value to given data buffer target
code0=mov [w0 + #ptrDProvControlError], w2
code1=mov w1, [w2]

[shadow_copy_control_output]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load pointer address of target buffer of most recent controller output value from data structure
comment1=copy most recent controller output value to given data buffer target
code0=mov [w0 + #ptrDProvControlOutput], w2
code1=mov w4, [w2]

[shadow_copy_control_output_zeroed_when_disabled]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=load pointer address of target buffer of most recent controller output value from data structure
comment1=copy most recent controller output value to given data buffer target
code0=mov [w0 + #ptrDProvControlOutput], w2
code1=clr [w2]

[comp_error_history_update]
address_loop=b
head_comment=%SEPARATOR%; Update error history (move error one tick down the delay line)
cycles=2
lines=2
comment0=move entry (n-%FO-INDEX%) into buffer 
comment1=move buffered value one tick down the delay line
code0=mov [w10 + #%(FO-INDEX-1)*ADDR_DATA%], w6
code1=mov w6, [w10 + #%(FO-INDEX)*ADDR_DATA%]

[comp_error_history_update_reverse]
address_loop=b
head_comment=%SEPARATOR%; Update error history in reverse order (move error one tick down the delay line)
cycles=2
lines=2
comment0=move entry (n-%FO-INDEX%) one tick down the delay line
code0=mov [w10 + #%(FO-INDEX-1)*ADDR_DATA%], w6
code1=mov w6, [w10 + #%(FO-INDEX)*ADDR_DATA%]

[comp_error_add_most_recent_to_mac]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=load most recent error input into MAC working register
code0=mov w1, w6

[comp_error_add_most_recent_to_history]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent error input to history array
code0=mov w1, [w10]

[comp_error_add_most_recent_to_history_reverse]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent error input to history array
code0=mov w1, [w10 + #%FO*ADDR_DATA% - %FO*ADDR_DATA%]

[comp_control_history_update]
address_loop=a
head_comment=%SEPARATOR%; Update control output history (move entries one tick down the delay line)
cycles=2
lines=2
comment0=move entry (n-%FO-INDEX%) one tick down the delay line
code0=mov [w10 + #%(FO-INDEX-1)*ADDR_DATA%], w6
code1=mov w6, [w10 + #%(FO-INDEX)*ADDR_DATA%]

[comp_control_history_update_reverse]
address_loop=a
head_comment=%SEPARATOR%; Update control history in reverse order (move error one tick along the delay line)
cycles=2
lines=2
comment0=move entry (n-%FO-INDEX%) one tick down the delay line
code0=mov [w10 + #%FO*ADDR_DATA% - #%INDEX*ADDR_DATA+ADDR_DATA%], w6
code1=mov w6, [w10 + #%FO*ADDR_DATA% - #%INDEX*ADDR_DATA%]

[comp_control_add_most_recent_to_history]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent control output to history
code0=mov w4, [w10]

[comp_control_add_most_recent_to_history_reverse]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent control output to history
code0=mov w4, [w10 - %FO*ADDR_DATA%]

[comp_control_add_most_recent_to_history_indirect]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add most recent control output to history
code0=mov w4, [w0 + #ptrControlHistory]

[load_a_coeff_array_ptr]
head_comment=%SEPARATOR%; Setup pointers to A-Term data arrays
cycles=1
lines=1
comment0=load pointer to first index of A coefficients array
code0=mov [w0 + #ptrACoefficients], w8

[load_a_coeff_array_ptr_reverse]
head_comment=%SEPARATOR%; Setup pointers to end of A-Term data arrays
cycles=2
lines=2
comment0=load pointer to end of A coefficients array
code0=mov [w0 + #ptrBCoefficients], w8
code1=add w8, #%FO*ADDR_COEF%, w8

[load_b_coeff_array_ptr]
head_comment=%SEPARATOR%; Setup pointers to B-Term data arrays
cycles=1
lines=1
comment0=load pointer to first index of B coefficients array
code0=mov [w0 + #ptrBCoefficients], w8

[load_b_coeff_array_ptr_reverse]
head_comment=%SEPARATOR%; Setup pointers to end of B-Term data arrays
cycles=2
lines=2
comment0=load pointer to end of B coefficients array
code0=mov [w0 + #ptrBCoefficients], w8
code1=add w8, #%FO*ADDR_COEF%, w8

[load_b0_coeff_to_wreg]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=Load coefficient B0 into working register
code0=mov [w8], w6

[load_error_history_array_ptr]
head_comment=%SEPARATOR%; Setup pointer to first element of error history array
cycles=1
lines=1
comment0=load pointer address into working register
code0=mov [w0 + #ptrErrorHistory], w10

[load_error_history_array_ptr_reverse]
head_comment=%SEPARATOR%; Setup pointer to first element of error history array
cycles=2
lines=2
comment0=load pointer address into working register
code0=mov [w0 + #ptrErrorHistory], w10
code1=add w10, #%FO*ADDR_DATA%, w10

[load_error_history_before_update_array_ptr]
head_comment=%SEPARATOR%; Setup pointer to second element of error history array
cycles=2
lines=2
comment0=load pointer address into working register
code0=mov [w0 + #ptrErrorHistory], w10
code1=add w10, #%ADDR_DATA%, w10

[load_error_history_before_update_array_ptr_reverse]
head_comment=%SEPARATOR%; Setup pointer to penultimate element of error history array
cycles=2
lines=2
comment0=load pointer address into working register
code0=mov [w0 + #ptrErrorHistory], w10
code1=add w10, #%FO*ADDR_DATA-ADDR_DATA%, w10

[load_control_history_array_ptr]
head_comment=%SEPARATOR%; Load pointer to first element of control history array
cycles=1
lines=1
comment0=load pointer address into working register
code0=mov [w0 + #ptrControlHistory], w10

[load_control_history_array_ptr_reverse]
head_comment=%SEPARATOR%; Load pointer to last element of control history array (reverse addressing)
cycles=2
lines=2
comment0=load pointer address into working register
code0=mov [w0 + #ptrControlHistory], w10
code1=add w10, #%FO*ADDR_DATA%, w10

[load_control_history_before_update_array_ptr]
head_comment=%SEPARATOR%; Load pointer to second element of control history array
cycles=2
lines=2
comment0=load pointer address into working register
code0=mov [w0 + #ptrControlHistory], w10
code1=add w10, #%ADDR_DATA%, w10

[load_control_history_array_before_update_ptr_reverse]
head_comment=%SEPARATOR%; Load pointer to penultimate element of control history array (reverse addressing)
cycles=2
lines=2
comment0=load pointer address into working register
code0=mov [w0 + #ptrControlHistory + %FO*ADDR_DATA-ADDR_DATA%], w10

[comp_mac_start_acca_clear_no_prefetch]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=clear accumulator A without prefetch of operands
code0=clr a

[comp_mac_start_acca_clear_prefetch]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=clear accumulator A and prefetch first operands
code0=clr a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_start_acca_reverse_clear]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=clear accumulator A and prefetch last operands
code0=clr a, [w8]-=%ADDR_COEF%, w4, [w10 + #%FO*ADDR_DATA%]-=%ADDR_DATA%, w6

[comp_mac_start_acca_resume]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=leave contents accumulator A untouched and prefetch first operands
code0=movsac a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_start_acca_reverse_resume]
head_comment=%SEPARATOR%; Compute compensation filter term
cycles=1
lines=1
comment0=leave contents accumulator A untouched and prefetch last operands
code0=movsac a, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_start_accb_clear_no_prefetch]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=clear accumulator B without prefetch of operands
code0=clr b

[comp_mac_start_accb_clear_prefetch]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=clear accumulator B and prefetch first operands
code0=clr b, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_start_accb_reverse_clear]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=clear accumulator B and prefetch last operands
code0=clr b, [w8]-=%ADDR_COEF%, w4, [w10 + #%FO*ADDR_DATA%]-=%ADDR_DATA%, w6

[comp_mac_start_accb_resume]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=leave contents of accumulator B untouched and prefetch first operands
code0=movsac b, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_start_accb_reverse_resume]
head_comment=%SEPARATOR%; Compute B-Term of the compensation filter
cycles=1
lines=1
comment0=leave contents of accumulator B untouched and prefetch last operands
code0=movsac b, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_loop_a_term_acca]
address_loop=a
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply control output (n-%INDEX%) from the delay line with coefficient A%INDEX%
code0=mac w4*w6, a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_loop_a_term_reverse_acca]
address_loop=a
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply control output (n-%FO-INDEX%) from the delay line with coefficient A%FO-INDEX%
code0=mac w4*w6, a, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_loop_a_term_accb]
address_loop=a
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply control output (n-%INDEX%) from the delay line with coefficient A%INDEX%
code0=mac w4*w6, b, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_loop_a_term_reverse_accb]
address_loop=a
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply control output (n-%FO-INDEX%) from the delay line with coefficient A%FO-INDEX%
code0=mac w4*w6, b, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_loop_b_term_acca]
address_loop=b
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate error input (n-%INDEX%) from the delay line with coefficient B%INDEX% and prefetch next operands
code0=mac w4*w6, a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_loop_b_term_reverse_acca]
address_loop=b
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate error input (n-%FO-INDEX%) from the delay line with coefficient B%FO-INDEX% and prefetch next operands
code0=mac w4*w6, a, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_loop_b_term_accb]
address_loop=b
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate error input (n-%INDEX%) from the delay line with coefficient B%INDEX% and prefetch next operands
code0=mac w4*w6, b, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[comp_mac_loop_b_term_reverse_accb]
address_loop=b
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate error input (n-%FO-INDEX%) from the delay line with coefficient B%FO-INDEX% and prefetch next operands
code0=mac w4*w6, b, [w8]-=%ADDR_COEF%, w4, [w10]-=%ADDR_DATA%, w6

[comp_mac_end_acca]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate last control output with coefficient of the delay line (no more prefetch)
code0=mac w4*w6, a

[comp_mac_end_accb]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=multiply & accumulate last error input with coefficient of the delay line (no more prefetch)
code0=mac w4*w6, b

[comp_backward_norm_a_acca]
head_comment=%SEPARATOR%; Backward normalization of recent result
cycles=2
lines=2
comment0=load A-coefficients post bit-shift scaler value into working register
comment1=shift accumulator A by number of bits loaded in working register
code0=mov [w0 + #normPostShiftA], w6
code1=sftac a, w6

[comp_backward_norm_a_accb]
head_comment=%SEPARATOR%; Backward normalization of recent result
cycles=2
lines=2
comment0=load A-coefficients post bit-shift scaler value into working register
comment1=shift accumulator A by number of bits loaded in working register
code0=mov [w0 + #normPostShiftA], w6
code1=sftac b, w6

[comp_backward_norm_b_acca]
head_comment=%SEPARATOR%; Backward normalization of recent result
cycles=2
lines=2
comment0=load B-coefficients post bit-shift scaler value into working register
comment1=shift accumulator B by number of bits loaded in working register
code0=mov [w0 + #normPostShiftB], w6
code1=sftac a, w6

[comp_backward_norm_b_accb]
head_comment=%SEPARATOR%; Backward normalization of recent result
cycles=2
lines=2
comment0=load B-coefficients post bit-shift scaler value into working register
comment1=shift accumulator B by number of bits loaded in working register
code0=mov [w0 + #normPostShiftB], w6
code1=sftac b, w6

[comp_backward_norm_coeff_scaler_acca]
head_comment=%SEPARATOR%; Initialize Output Factor Scaleing and multiply control output with scaling factor\n; (includes Backward normalization with accumulator scaling)
cycles=10
lines=10
comment0=Load pointer to accumulator A high word into working register
comment1=Find first bit change from left and store position in working register
comment2=shift accumulator A by 'n' bits to scale number into ACCH
comment3=store accumulator A high register contents in working register
comment4=load post scaler fractional value into working register
comment5=multiply control output by scaler value loaded into working register
comment6=load post scaler bit-shift scaler value into working register
comment7=negate previously stored accumulator shift value
comment8=add post scaler bit-shift scaler and accumulator scaler
comment9=shift accumulator A by 'n' bits to scale control output
code0=mov  #ACCAH, w2
code1=fbcl [w2], w1
code2=sftac a, w1
code3=sac.r a, w4
code4=mov [w0 + #normPostScaler],  w6
code5=mpy w4*w6, a
code6=mov [w0 + #normPostShiftA], w6
code7=neg w1, w1
code8=add w1, w6, w6
code9=sftac a, w6

[comp_mac_store_acca]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=store most recent accumulator result in working register
code0=sac.r a, w4

[comp_mac_store_accb]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=store most recent accumulator result in working register
code0=sac.r b, w4

[comp_mac_load32b_a]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=load value of saved accumulator upper word into accumulator A
comment1=load value of saved accumulator high word into accumulator A
comment2=load value of saved accumulator low word into accumulator A
code0=mov [w0 + #ACCxU], accau
code1=mov [w0 + #ACCxH], accah
code2=mov [w0 + #ACCxL], accal

[comp_mac_load32b_accb]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=load value of saved accumulator upper word into accumulator B
comment1=load value of saved accumulator high word into accumulator B
comment2=load value of saved accumulator low word into accumulator B
code0=mov [w0 + #ACCxU], accbu
code1=mov [w0 + #ACCxH], accbh
code2=mov [w0 + #ACCxL], accbl

[comp_mac_store32b_a]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=store value of accumulator A upper word into data structure
comment1=store value of accumulator A high word into data structure
comment2=store value of accumulator A low word into data structure
code0=mov accau, [w0 + #ACCxU]
code1=mov accah, [w0 + #ACCxH]
code2=mov accal, [w0 + #ACCxL]

[comp_mac_store32b_accb]
head_comment=%EMPTY%
cycles=3
lines=3
comment0=store value of accumulator B upper word into data structure
comment1=store value of accumulator B high word into data structure
comment2=store value of accumulator B low word into data structure
code0=mov accbu, [w0 + #ACCxU]
code1=mov accbh, [w0 + #ACCxH]
code2=mov accbl, [w0 + #ACCxL]

[comp_add_acca_to_accb]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=add accumulator a to accumulator b
code0=add b

[comp_add_accb_to_acca]
head_comment=%SEPARATOR%; Add accumulators finalizing LDE computation
cycles=1
lines=1
comment0=add accumulator b to accumulator a
code0=add a

[comp_writeback_start]
head_comment=%SEPARATOR%; Write control output value to target
cycles=1
lines=1
comment0=capture pointer to target in working register
code0=mov [w0 + #ptrTargetRegister], w8

[comp_writeback_to_alt_target_switch]
head_comment=%EMPTY%
cycles=3
lines=2
comment0=if SWAP TARGET option is enabled, execute next instruction
comment1=overwrite pointer in working register with alternate target address 
code0=btsc [w0], #NPNZ16_STATUS_SWAP_TARGET
code1=mov [w0 + #ptrAltTargetRegister], w8

[comp_writeback_end]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=move control output to target address
code0=mov w4, [w8]

[comp_writeback_mirror_to_alt_target]
head_comment=%EMPTY%
cycles=2
lines=2
comment0=capture pointer to alternate target in working register
comment1=move control output to alternate target address
code0=mov [w0 + #ptrAltTargetRegister], w8
code1=mov w4, [w8]

[comp_writeback_ssm]
head_comment=%SEPARATOR%; Add spread specturm modulator
cycles=3
lines=3
comment0=%EMPTY%
code0=mov [w0 + #ptrTargetRegister], w8
code1=mov [w0 + #ssmFactor], w6
code2=mpy w4*w6, [w8]

[adc_trigger_placement_start]
head_comment=%SEPARATOR%; Update ADC trigger locations
cycles=1
lines=1
comment0=half control output by shifting value one bit to the right
code0=asr w4, #1, w6

[adc_trigger_a_placement]
head_comment=; Update ADC trigger A position
cycles=4
lines=4
comment0=load user-defined ADC trigger A offset value into working register
comment1=add user-defined ADC trigger A offset to half of control output
comment2=load pointer to ADC trigger A register into working register
comment3=push new ADC trigger value to ADC trigger A register
code0=mov [w0 + #ADCTriggerAOffset], w8
code1=add w6, w8, w10
code2=mov [w0 + #ptrADCTriggerARegister], w8
code3=mov w10, [w8]

[adc_trigger_b_placement]
head_comment=; Update ADC trigger B position
cycles=4
lines=4
comment0=load user-defined ADC trigger B offset value into working register
comment1=add user-defined ADC trigger B offset to half of control output
comment2=load pointer to ADC trigger B register into working register
comment3=push new ADC trigger value to ADC trigger B register
code0=mov [w0 + #ADCTriggerBOffset], w8
code1=add w6, w8, w10
code2=mov [w0 + #ptrADCTriggerBRegister], w8
code3=mov w10, [w8]

[return]
head_comment=%SEPARATOR%; End of routine
cycles=1
lines=2
comment0=end of function; return to caller
code0=return
code1=%SEPARATOR%

[end]
head_comment=%SEPARATOR%; End of file
cycles=1
lines=2
comment0=end of file %PREFIX%_asm.s
code0=.end
code1=%SEPARATOR%

;
; Specific projected floating point instruction blocks
;

[context_save_mac_registers_fscl]
item_loop=wreg_usage
head_comment=%EMPTY%
cycles=5
lines=5
comment0=save working registers used for MAC operations (w4, w5, w6, w8, w10)
code0=push w4
code1=push w5
code2=push w6
code3=push w8
code4=push w10

[context_restore_mac_registers_fscl]
item_loop=wreg_usage
head_comment=%EMPTY%
cycles=5
lines=5
comment0=restore working registers used for MAC operations (w4, w5, w6, w8, w10)
code0=pop w10
code1=pop w8
code2=pop w6
code3=pop w5
code4=pop w4

[fscl_comp_mac_start_clear]
head_comment=%SEPARATOR%; Compute compensation filter B-term
cycles=2
lines=2
comment0=clear both accumulators and prefetch first operands
code0=clr b, [w8]+=%ADDR_DATA%, w5
code1=clr a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[fscl_comp_mac_start_resume]
head_comment=%SEPARATOR%; Compute compensation filter A-term
cycles=2
lines=2
comment0=leave contents of accumulator B unchanged
comment1=clear accumulator A and prefetch first operands
code0=movsac b, [w8]+=%ADDR_DATA%, w5
code1=clr a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6

[fscl_comp_mac_first]
head_comment=%EMPTY%
cycles=4
lines=4
comment0=multiply control output (n-%INDEX%) from the delay line with coefficient X%INDEX%
comment1=shift accumulator to post-scale floating number
comment2=add accumulator a to accumulator b
code0=mpy w4*w6, a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6
code1=sftac a, w5
code2=add b

[fscl_comp_mac_a_loop]
address_loop=as
head_comment=%EMPTY%
cycles=4
lines=4
comment0=load scaler into working register
comment1=multiply control output (n-%INDEX%) from the delay line with coefficient X%INDEX%
comment2=shift accumulator to post-scale floating number
comment3=add accumulator a to accumulator b
code0=mov [w8 - #%ADDR_DATA*3%], w5
code1=mpy w4*w6, a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6
code2=sftac a, w5
code3=add b

[fscl_comp_mac_b_loop]
address_loop=bs
head_comment=%EMPTY%
cycles=4
lines=4
comment0=load scaler into working register
comment1=multiply control output (n-%INDEX%) from the delay line with coefficient X%INDEX%
comment2=shift accumulator to post-scale floating number
comment3=add accumulator a to accumulator b
code0=mov [w8 - #%ADDR_DATA*3%], w5
code1=mpy w4*w6, a, [w8]+=%ADDR_COEF%, w4, [w10]+=%ADDR_DATA%, w6
code2=sftac a, w5
code3=add b

[fscl_comp_mac_end]
head_comment=%EMPTY%
cycles=4
lines=4
comment0=load scaler into working register
comment1=multiply & accumulate last control output with coefficient of the delay line (no more prefetch)
comment2=shift accumulator to post-scale floating number
comment3=add accumulator a to accumulator b
code0=mov [w8 - #%ADDR_DATA*3%], w5
code1=mpy w4*w6, a
code2=sftac a, w5
code3=add b

[pterm_comp_load_gain_factor]
head_comment=%SEPARATOR%; Load P-gain factor from data structure
cycles=3
lines=3
comment0=move P-coefficient fractional into working register
comment1=move P-coefficient scaler into working register
comment2=move error to MPY working register 
code0=mov [w0 + #PTermFactor], w6
code1=mov [w0 + #PTermScaler], w2 
code2=mov w1, w4

[pterm_comp_exec_pterm]
head_comment=; calculate P-control result
cycles=3
lines=3
comment0=multiply most recent error with P-coefficient
comment1=shift accumulator to post-scale floating number
comment2=store accumulator result to working register
code0=mpy w4*w6, a
code1=sftac a, w2
code2=sac.r a, w4

[agc_factor_multiply_start]
head_comment=%SEPARATOR%; Adaptive Loop Gain Modulation
cycles=0
lines=0

[agc_factor_multiply_enable_start]
head_comment=%EMPTY%
cycles=3
lines=2
comment0=check status bit if Adaptive Gain Control is enabled
comment1=branch to end of AGC calculation if not
code0=btss [w0], #NPNZ16_STATUS_AGC_ENABLED
code1=bra %PREFIXU%_BYPASS_AGC

[agc_factor_multiply_enable_end]
head_comment=%EMPTY%
cycles=0
lines=1
comment0=branch target for AGC enable-/disable-switch
code0=%PREFIXU%_BYPASS_AGC:

[agc_factor_multiply_store_accb_high_res]
head_comment=%EMPTY%
cycles=4
lines=4
comment0=capture address of accumulator B high word and store it in working register
comment1=find first bit change from left in accumulator B and store position in working register
comment2=shift accumulator by 'n' bits to scale contents into ACCH window
comment3=store result of accumulator B in working register
code0=mov  #ACCBH, w2
code1=fbcl [w2], w3
code2=sftac b, w3
code3=sac.r b, w6

[agc_factor_multiply_store_accb]
head_comment=%EMPTY%
cycles=1
lines=1
comment0=store result of accumulator B in working register
code0=sac.r b, w6

[agc_factor_multiply_factor_update_call]
head_comment=%EMPTY%
cycles=5
lines=2
comment0=load function pointer to observer function
comment1=call extern observer function to update gain modulation factor
code0=mov [w0 + ptrAgcObserverFunction], w1
code1=call w1

[agc_factor_multiply_scaled_high_res]
head_comment=%EMPTY%
cycles=6
lines=6
comment0=load AGC modulation factor into working register
comment1=load AGC modulation factor scaler into working register
comment2=multiply accumulator B result with AGC modulation factor
comment3=negate previously stored accumulator shift value
comment4=add post scaler bit-shift scaler and accumulator scaler
comment5=shift result by AGC scaler with accumulator scaling
code0=mov [w0 + #AgcFactor], w4  
code1=mov [w0 + #AgcScaler], w2
code2=mpy w4*w6, b
code3=neg w3, w3
code4=add w3, w2, w2
code5=sftac b, w2

[agc_factor_multiply_scaled]
head_comment=%EMPTY%
cycles=4
lines=4
comment0=load AGC modulation factor into working register
comment1=load AGC modulation factor scaler into working register
comment2=multiply accumulator B result with AGC modulation factor
comment3=shift result by AGC scaler with accumulator scaling
code0=mov [w0 + #AgcFactor], w4  
code1=mov [w0 + #AgcScaler], w2
code2=mpy w4*w6, b
code3=sftac b, w2

[agc_factor_get_factor]
head_comment=%SEPARATOR%; Global function declaration %PREFIX%_GetGainFactor\n; This function calculates a the gain modulation factor \n; by deviding Alternate Source by Source%SEPARATOR%
cycles=9
lines=21
comment0=provide global scope to routine
comment1=local function label
comment2=load pointer to most recent input voltage register
comment3=load value into w1
comment4=load most recent input voltage normalization scaler
comment5=normalize input voltage value
comment6=load pointer to most recent output voltage register
comment7=load value into w2
comment8=load most recent output voltage normalization scaler
comment9=normalize output voltage value
comment10=calculate most recent VL, place result in w6
comment11=load pointer to nominal VL
comment12=Save working register WREG0 (holds data structure start address)
comment13=clear divider target register #0
comment14=clear divider target register #1
comment15=repeat divide instructions n-times
comment16=divide nominal VL by instantaneous VL
comment17=normalize result to Q15 number
comment18=move result outo f WREG0
comment19=restore WREG0 to restore access to data structure
comment20=move gain factor result back into data structure
code0=.global _%PREFIX%_GetGainFactor
code1=_%PREFIX%_GetGainFactor:\n
code2=mov [w0 + #ptrAltSourceRegister], w1
code3=mov [w1], w1 
code4=mov [w0 + AltSourceNormShift], w3
code5=sl  w1, w3, w1
code6=mov [w0 + #ptrSourceRegister], w2
code7=mov [w2], w2
code8=mov [w0 + SourceNormShift], w3
code9=sl  w2, w2, w2
code10=sub w1, w2, w6
code11=mov [w0 + #AgcMedian], w4
code12=push w0
code13=clr  w0
code14=clr  w1
code15=repeat #[%P33C%$5][%P33E%$17][%P33F%$17]
code16=divf w4, w6
code17=sl w0, #1, w0
code18=mov w0, w2
code19=pop w0
code20=mov w2, [w0 + #AgcFactor]


[ccode:blocks]
count=70
0=c_code_head_comment
1=c_code_tool_link
2=c_source_include_c_header
3=c_source_declarations_comment
4=c_source_array_declarations
5=c_source_coefficient_declarations
6=c_source_pterm_declarations
7=c_source_agc_declarations
8=c_source_controller_declarations
9=c_source_init_comment
10=c_source_init_start
11=c_source_init_controller
12=c_source_init_pterm
13=c_source_init_agc
14=c_source_init_end
15=c_header_guard_start
16=c_header_include
17=c_header_declarations_comment
18=c_header_array_declarations
19=c_header_pterm_declarations
20=c_header_agc_declarations
21=c_header_controller_declarations
22=c_header_function_prototypes
23=c_header_function_prototypes_pterm
24=c_header_guard_end
25=c_libheader_head_comment
26=c_libheader_guard_start
27=c_libheader_include
28=c_libheader_dcld_macro
29=c_libheader_npnz_object_declaration
30=c_libheader_guard_end
31=c_config_head_comment
32=c_config_function_head
33=c_config_function_end
34=c_config_primary_source
35=c_config_alternate_source
36=c_config_primary_target
37=c_config_alternate_target
38=c_config_reference
39=c_config_limits_start
40=c_config_limits_min
41=c_config_limits_max
42=c_config_limits_stop
43=c_config_alternate_limits_start
44=c_config_alternate_limits_min
45=c_config_alternate_limits_max
46=c_config_alternate_limits_stop
47=c_config_adc_trigger_start
48=c_config_adc_trigger_a
49=c_config_adc_trigger_b
50=c_config_data_providers_start
51=c_config_data_provider_a
52=c_config_data_provider_b
53=c_config_data_provider_c
54=c_config_data_provider_d
55=c_config_data_providers_stop
56=c_config_cascade_trigger
57=c_config_gain_control
58=c_config_gain_control_observer_call
59=c_config_gain_control_stop
60=c_config_user_data_buffer
61=c_config_status_word_start
62=c_config_status_word_enable
63=c_config_status_word_invert_input
64=c_config_status_word_alternate_source
65=c_config_status_word_alternate_target
66=c_config_status_word_agc_enable
67=c_config_status_word_upper_saturation
68=c_config_status_word_lower_saturation
69=c_config_control_interrupt_service_routine

[c_code_head_comment]
count=21
line0=%NOIDENT%/* *********************************************************************************
line1=%SPACE%* %APP_PRODUCT_NAME%, Version %APP_PRODUCT_VERSION%
line2=%SPACE%* *********************************************************************************
line3=%SPACE%* %FILTER_ORDER%p%FILTER_ORDER%z controller function declarations and compensation filter coefficients
line4=%SPACE%* derived for following operating conditions:
line5=%SPACE%* *********************************************************************************
line6=%SPACE%*
line7=%SPACE%*  Controller Type:    %COMP_TYPE_NAME%
line8=%SPACE%*  Sampling Frequency: %SAMPLING_FREQUENCY% Hz 
line9=%SPACE%*  Fixed Point Format: %Q_FORMAT%
line10=%SPACE%*  Scaling Mode:       %SCALING_MODE%
line11=%SPACE%*  Input Gain:         %INPUT_GAIN%
line12=%SPACE%*
line13=%SPACE%* *********************************************************************************
line14=%SPACE%* CGS Version:         %CGS_VERSION%
line15=%SPACE%* CGS Date:            %CGS_VERSION_DATE%
line16=%SPACE%* *********************************************************************************
line17=%SPACE%* User:                %USER_NAME%
line18=%SPACE%* Date/Time:           %DATE_TIME_NOW%
line19=%SPACE%* ********************************************************************************/
line20=%EMPTY%

[c_code_tool_link]
count=5
line0=%EMPTY%
line1=//**********************************************************************************
line2=// Download latest version of this tool here: %TOOL_HOME_URL%
line3=//**********************************************************************************
line4=%EMPTY%

[c_source_include_c_header]
count=2
line0=#include "%C_HEADER_INCLUDE_PATH%%PREFIX%.h"
line1=%EMPTY%

[c_source_declarations_comment]
count=15
line0=%NOIDENT%/* *********************************************************************************
line1=%SPACE%* Data Arrays:
line2=%SPACE%* This source file declares the default parameters of the z-domain compensation  
line3=%SPACE%* filter. The NPNZ16b_t data structure contains two pointers to A- and B- 
line4=%SPACE%* coefficient arrays and two pointers to control and error history arrays.
line5=%SPACE%*
line6=%SPACE%* For optimized data processing during DSP computations, these arrays must be 
line7=%SPACE%* located in specific memory locations (X-space for coefficient arrays and 
line8=%SPACE%* Y-space for control and error history arrays). 
line9=%SPACE%*
line10=%SPACE%* The following declarations are used to define the array data contents, their 
line11=%SPACE%* length and memory location. These declarations are made publicly accessible 
line12=%SPACE%* through extern declarations in header file %PREFIX%.h
line13=%SPACE%* ********************************************************************************/
line14=%EMPTY%

[c_source_array_declarations]
count=8
line0=volatile struct %PREFIXU%_CONTROL_LOOP_COEFFICIENTS_s __attribute__((space(xmemory), near)) %PREFIX%_coefficients; // A/B-Coefficients 
line1=volatile uint16_t %PREFIX%_ACoefficients_size = (sizeof(%PREFIX%_coefficients.ACoefficients)/sizeof(%PREFIX%_coefficients.ACoefficients[0])); // A-coefficient array size
line2=volatile uint16_t %PREFIX%_BCoefficients_size = (sizeof(%PREFIX%_coefficients.BCoefficients)/sizeof(%PREFIX%_coefficients.BCoefficients[0])); // B-coefficient array size
line3=%EMPTY%
line4=volatile struct %PREFIXU%_CONTROL_LOOP_HISTORIES_s __attribute__((space(ymemory), far)) %PREFIX%_histories; // Control/Error Histories 
line5=volatile uint16_t %PREFIX%_ControlHistory_size = (sizeof(%PREFIX%_histories.ControlHistory)/sizeof(%PREFIX%_histories.ControlHistory[0])); // Control history array size
line6=volatile uint16_t %PREFIX%_ErrorHistory_size = (sizeof(%PREFIX%_histories.ErrorHistory)/sizeof(%PREFIX%_histories.ErrorHistory[0])); // Error history array size
line7=%EMPTY%

[c_source_coefficient_declarations]
count=27
line0=      /* *********************************************************************************
line1=%SPACE%* Pole&Zero Placement:
line2=%SPACE%* *********************************************************************************
line3=%SPACE%*
line4=%SPACE%*%IDENT%fP%INDEX%:%IDENT%%LOOP_POLE_LOCATION_LIST% Hz
line5=%SPACE%*%IDENT%fZ%INDEX%:%IDENT%%LOOP_ZERO_LOCATION_LIST% Hz
line6=%SPACE%*
line7=%SPACE%* *********************************************************************************
line8=%SPACE%* Filter Coefficients and Parameters:
line9=%SPACE%* ********************************************************************************/
line10=%EMPTY%
line11=volatile %COEFF_DATA_TYPE% %PREFIX%_ACoefficients [%FILTER_ORDER%] =
line12={
line13=%IDENT%%LOOP_A_COEFFICIENTS_LIST% // %LOOP_A%Coefficient A%INDEX% will be multiplied with controller output u(n-%INDEX%)
line14=};
line15=%EMPTY%
line16=volatile %COEFF_DATA_TYPE% %PREFIX%_BCoefficients [%FILTER_ORDER+1%] =
line17={
line18=%IDENT%%LOOP_B_COEFFICIENTS_LIST% // %LOOP_B%Coefficient B%INDEX% will be multiplied with error input e(n-%INDEX%)
line19=};
line20=%EMPTY%
line21=// Coefficient normalization factors
line22=volatile int16_t %PREFIX%_pre_scaler = %PRESCALER%; // Bit-shift value used to perform input value normalization
line23=volatile int16_t %PREFIX%_post_shift_A = %POSTSHIFT_A%; // Bit-shift value A used to perform control output value backfward normalization
line24=volatile int16_t %PREFIX%_post_shift_B = %POSTSHIFT_B%; // Bit-shift value B used to perform control output value backfward normalization
line25=volatile fractional %PREFIX%_post_scaler = %POSTSCALER%; // Q15 fractional factor used to perform control output value backfward normalization
line26=%EMPTY%

[c_source_pterm_declarations]
count=4
line0=// P-Term Coefficient for Plant Measurements
line1=volatile int16_t %PREFIX%_pterm_factor = %PTERMFACTOR%; // Q15 fractional of the Pterm factor
line2=volatile int16_t %PREFIX%_pterm_scaler = %PTERMSCALER%; // Bit-shift scaler of the Pterm factor
line3=%EMPTY%

[c_source_agc_declarations]
count=4
line0=//Adaptive Gain Control Coefficient
line1=volatile int16_t %PREFIX%_agc_factor_default = %AGCFACTOR%; // Q15 fractional of the Pterm factor
line2=volatile int16_t %PREFIX%_agc_scaler_default = %AGCSCALER%; // Bit-shift scaler of the AGC factor
line3=%EMPTY%

[c_source_controller_declarations]
count=6
line0=%EMPTY%
line1=// User-defined NPNZ16b_t controller data object
line2=volatile struct %STRUCTURE_LABEL%_s %PREFIX%; // user-controller data object
line3=%EMPTY%
line4=%NOIDENT%/* ********************************************************************************/
line5=%EMPTY%

[c_source_init_comment]
count=23
line0=      /*@@%PREFIX%_Initialize()
line1=%SPACE%* *********************************************************************************
line2=%SPACE%* Summary: Initializes controller coefficient arrays and normalization
line3=%SPACE%* 
line4=%SPACE%* Parameters:
line5=%SPACE%*     - struct %STRUCTURE_LABEL%_s* controller
line6=%SPACE%* 
line7=%SPACE%* Returns:
line8=%SPACE%*     - uint16_t:  0->failure
line9=%SPACE%*                  1->success
line10=%SPACE%* 
line11=%SPACE%* Description:
line12=%SPACE%* This function needs to be called from user code once to initialize coefficient 
line13=%SPACE%* arrays and number normalization settings of the %PREFIX% controller 
line14=%SPACE%* object.
line15=%SPACE%* 
line16=%SPACE%* PLEASE NOTE:
line17=%SPACE%* This routine DOES NOT initialize the complete controller object.
line18=%SPACE%* User-defined settings such as pointers to the control reference, source and  
line19=%SPACE%* target registers, output minima and maxima and further, design-dependent  
line20=%SPACE%* settings, need to be specified in user code.
line21=%SPACE%* ********************************************************************************/
line22=%EMPTY%

[c_source_init_start]
count=2
line0=volatile uint16_t %PREFIX%_Initialize(volatile struct %STRUCTURE_LABEL%_s* controller)
line1={

[c_source_init_controller]
count=33
line0=%IDENT%volatile uint16_t i=0;
line1=%EMPTY%
line2=%IDENT%// Initialize controller data structure at runtime with pre-defined default values
line3=%IDENT%controller->status.value = NPNZ16_CONTROL_STATUS_CLEAR;  // clear all status flag bits (will turn off execution))
line4=%EMPTY%
line5=%IDENT%controller->Filter.ptrACoefficients = &%PREFIX%_coefficients.ACoefficients[0]; // initialize pointer to A-coefficients array
line6=%IDENT%controller->Filter.ptrBCoefficients = &%PREFIX%_coefficients.BCoefficients[0]; // initialize pointer to B-coefficients array
line7=%IDENT%controller->Filter.ptrControlHistory = &%PREFIX%_histories.ControlHistory[0]; // initialize pointer to control history array
line8=%IDENT%controller->Filter.ptrErrorHistory = &%PREFIX%_histories.ErrorHistory[0]; // initialize pointer to error history array
line9=%IDENT%controller->Filter.normPostShiftA = %PREFIX%_post_shift_A; // initialize A-coefficients/single bit-shift scaler
line10=%IDENT%controller->Filter.normPostShiftB = %PREFIX%_post_shift_B; // initialize B-coefficients/dual/post scale factor bit-shift scaler
line11=%IDENT%controller->Filter.normPostScaler = %PREFIX%_post_scaler; // initialize control output value normalization scaling factor
line12=%IDENT%controller->Filter.normPreShift = %PREFIX%_pre_scaler; // initialize A-coefficients/single bit-shift scaler
line13=%IDENT%
line14=%IDENT%controller->Filter.ACoefficientsArraySize = %PREFIX%_ACoefficients_size; // initialize A-coefficients array size
line15=%IDENT%controller->Filter.BCoefficientsArraySize = %PREFIX%_BCoefficients_size; // initialize A-coefficients array size
line16=%IDENT%controller->Filter.ControlHistoryArraySize = %PREFIX%_ControlHistory_size; // initialize control history array size
line17=%IDENT%controller->Filter.ErrorHistoryArraySize = %PREFIX%_ErrorHistory_size; // initialize error history array size
line18=%EMPTY%
line19=%IDENT%// Load default set of A-coefficients from user RAM into controller A-array located in X-Space
line20=%IDENT%for(i=0; i<controller->Filter.ACoefficientsArraySize; i++)
line21=%IDENT%{
line22=%IDENT%%IDENT%%PREFIX%_coefficients.ACoefficients[i] = %PREFIX%_ACoefficients[i]; // %LOOP_A%Load coefficient A%INDEX% value into %PREFIX% coefficient data space
line23=%IDENT%}
line24=%EMPTY%
line25=%IDENT%// Load default set of B-coefficients from user RAM into controller B-array located in X-Space
line26=%IDENT%for(i=0; i<controller->Filter.BCoefficientsArraySize; i++)
line27=%IDENT%{
line28=%IDENT%%IDENT%%PREFIX%_coefficients.BCoefficients[i] = %PREFIX%_BCoefficients[i]; // %LOOP_B%Load coefficient B%INDEX% value into %PREFIX% coefficient data space
line29=%IDENT%}
line30=%EMPTY%
line31=%IDENT%// Clear error and control histories of the 3P3Z controller
line32=%IDENT%%PREFIX%_Reset(&%PREFIX%);

[c_source_init_pterm]
count=4
line0=%IDENT%
line1=%IDENT%// Load P-Term factor and scaler into data structure
line2=%IDENT%controller->Filter.PTermFactor = %PREFIX%_pterm_factor;
line3=%IDENT%controller->Filter.PTermScaler = %PREFIX%_pterm_scaler;

[c_source_init_agc]
count=4
line0=%IDENT%
line1=%IDENT%// Load initial AGC factor and scaler into data structure
line2=%IDENT%controller->GainControl.AgcFactor = %PREFIX%_agc_factor_default;
line3=%IDENT%controller->GainControl.AgcScaler = %PREFIX%_agc_scaler_default;

[c_source_init_end]
count=4
line0=%IDENT%
line1=%IDENT%return(1);
line2=}
line3=%EMPTY%

[c_header_guard_start]
count=5
line0=// This is a guard condition so that contents of this file are not included
line1=// more than once.  
line2=#ifndef __SPECIAL_FUNCTION_LAYER_%PREFIXU%_H__
line3=#define __SPECIAL_FUNCTION_LAYER_%PREFIXU%_H__
line4=%EMPTY%

[c_header_include]
count=7
line0=#include <xc.h> // include processor files - each processor file is guarded 
line1=#include <dsp.h> // include DSP data types (e.g. fractional)
line2=#include <stdint.h> // include standard integer number data types 
line3=#include <stdbool.h> // include standard boolean data types (true/false)
line4=%EMPTY%
line5=#include "%LIB_HEADER_INCLUDE_PATH%npnz16b.h" // include NPNZ library header file
line6=%EMPTY%

[c_header_declarations_comment]
count=14
line0=      /* *******************************************************************************
line1=%SPACE%* Data Arrays:
line2=%SPACE%* The NPNZ16b_t data structure contains pointers to coefficient, control and error  
line3=%SPACE%* history arrays. The pointer target objects (variables and arrays) are defined 
line4=%SPACE%* in controller source file %PREFIX%.c
line5=%SPACE%*
line6=%SPACE%* Type definitions for A- and B- coefficient arrays as well as error- and control 
line7=%SPACE%* history arrays are aligned in memory using the 'packed' attribute for optimized    
line8=%SPACE%* addressing during DSP computations. These aligned data structures need to be   
line9=%SPACE%* placed in specific memory locations to allow direct X/Y-access from the DSP. 
line10=%SPACE%* This X/Y-memory placement is covered by the declarations used in controller 
line11=%SPACE%* source file %PREFIXL%.c
line12=%SPACE%* ******************************************************************************/
line13=%EMPTY%

[c_header_array_declarations]
count=12
line0=typedef struct %PREFIXU%_CONTROL_LOOP_COEFFICIENTS_s
line1={
line2=%IDENT%volatile %COEFF_DATA_TYPE% ACoefficients[%FILTER_ORDER%]; // A-Coefficients
line3=%IDENT%volatile %COEFF_DATA_TYPE% BCoefficients[%FILTER_ORDER+1%]; // B-Coefficients
line4=} __attribute__((packed)) %PREFIXU%_CONTROL_LOOP_COEFFICIENTS_t; // Data structure packing A- and B- coefficient arrays in a linear memory space for optimized DSP code execution
line5=%EMPTY%
line6=typedef struct %PREFIXU%_CONTROL_LOOP_HISTORIES_s
line7={
line8=%IDENT%volatile %HISTORY_DATA_TYPE% ControlHistory[%FILTER_ORDER%];  // Control History Array
line9=%IDENT%volatile %HISTORY_DATA_TYPE% ErrorHistory[%FILTER_ORDER+1%];  // Error History Array
line10=} __attribute__((packed)) %PREFIXU%_CONTROL_LOOP_HISTORIES_t; // Data structure packing control and error histories arrays in a linear memory space for optimized DSP code execution
line11=%EMPTY%

[c_header_pterm_declarations]
count=4
line0=// P-Term Coefficient for Plant Measurements
line1=extern volatile int16_t %PREFIX%_pterm_factor; // Q15 fractional of the Pterm factor
line2=extern volatile int16_t %PREFIX%_pterm_scaler; // Bit-shift scaler of the Pterm factor
line3=%EMPTY%

[c_header_agc_declarations]
count=4
line0=//Adaptive Gain Control Coefficient
line1=extern volatile int16_t %PREFIX%_agc_factor_default; // Q15 fractional of the AGC factor
line2=extern volatile int16_t %PREFIX%_agc_scaler_default; // Bit-shift scaler of the Pterm factor
line3=%EMPTY%

[c_header_controller_declarations]
count=5
line0=%EMPTY%
line1=// User-defined NPNZ16b_s controller data object
line2=extern volatile struct %STRUCTURE_LABEL%_s %PREFIX%; // user-controller data object
line3=%EMPTY%
line4=%EMPTY%

[c_header_function_prototypes]
count=26
line0=      /* *******************************************************************************
line1=%SPACE%* Function call prototypes for initialization routines and control loops
line2=%SPACE%* ******************************************************************************/
line3=%EMPTY%
line4=// Initialization of %PREFIX% controller object
line5=extern volatile uint16_t %PREFIX%_Initialize( // %PREFIX% initialization function call
line6=%IDENT%%IDENT%volatile struct %STRUCTURE_LABEL%_s* controller // Pointer to NPNZ16b data type object
line7=%IDENT%);
line8=%EMPTY%
line9=// Clears the %FILTER_ORDER%P%FILTER_ORDER%Z controller output and error histories
line10=extern void %PREFIX%_Reset( // %PREFIX% reset function call (Assembly)
line11=%IDENT%%IDENT%volatile struct %STRUCTURE_LABEL%_s* controller // Pointer to NPNZ16b data type object
line12=%IDENT%);
line13=%EMPTY%
line14=// Loads user-defined values into %FILTER_ORDER%P%FILTER_ORDER%Z controller output and error histories
line15=extern void %PREFIX%_Precharge( // %PREFIX% history pre-charge function call (Assembly)
line16=%IDENT%%IDENT%volatile struct %STRUCTURE_LABEL%_s* controller, // Pointer to NPNZ16b data type object
line17=%IDENT%%IDENT%volatile %HISTORY_DATA_TYPE% ctrl_input, // user-defined, constant error history value
line18=%IDENT%%IDENT%volatile %HISTORY_DATA_TYPE% ctrl_output // user-defined, constant control output history value
line19=%IDENT%);
line20=%EMPTY%
line21=// Calls the %PREFIX% control loop
line22=extern void %PREFIX%_Update( // Calls the %FILTER_ORDER%P%FILTER_ORDER%Z controller (Assembly)
line23=%IDENT%%IDENT%volatile struct %STRUCTURE_LABEL%_s* controller // Pointer to NPNZ16b data type object
line24=%IDENT%);
line25=%EMPTY%

[c_header_function_prototypes_pterm]
count=8
line0=// Calls the %PREFIX% P-Term controller during measurements of plant transfer functions
line1=// THIS CONTROLLER IS USED FOR MEASUREMENTS OF THE PLANT TRANSFER FUNCTION ONLY.
line2=// THIS LOOP IS BY DEFAULT UNSTABLE AND ONLY WORKS UNDER STABLE TEST CONDITIONS
line3=// DO NOT USE THIS CONTROLLER TYPE FOR NORMAL OPERATION
line4=extern void %PREFIX%_PTermUpdate( // Calls the P-Term controller (Assembly)
line5=%IDENT%%IDENT%volatile struct %STRUCTURE_LABEL%_s* controller // Pointer to NPNZ16b data type object
line6=%IDENT%);
line7=%EMPTY%

[c_header_guard_end]
count=2
line0=#endif // end of __SPECIAL_FUNCTION_LAYER_%PREFIXU%_H__
line1=%EMPTY%

[c_libheader_head_comment]
count=7
line0=      /* *********************************************************************************
line1=%SPACE%* %APP_PRODUCT_NAME%, Version %APP_PRODUCT_VERSION%
line2=%SPACE%* *********************************************************************************
line3=%SPACE%* Generic library header for z-domain compensation filter assembly functions
line4=%SPACE%* CGS Version: %CGS_VERSION%
line5=%SPACE%* CGS Date:    %CGS_VERSION_DATE%
line6=%SPACE%* ********************************************************************************/

[c_libheader_guard_start]
count=5
line0=// This is a guard condition so that contents of this file are not included
line1=// more than once.  
line2=#ifndef __SPECIAL_FUNCTION_LAYER_LIB_NPNZ16B_H__
line3=#define __SPECIAL_FUNCTION_LAYER_LIB_NPNZ16B_H__
line4=%EMPTY%

[c_libheader_include]
count=6
line0=#include <xc.h> // include processor files - each processor file is guarded
line1=#include <dsp.h> // include DSP data types (e.g. fractional)
line2=#include <stdint.h> // include standard integer number data types
line3=#include <stddef.h> // include standard definition data types
line4=#include <stdbool.h> // include standard boolean data types (true/false)
line5=%EMPTY%

[c_libheader_dcld_macro]
count=21
line0=      /*@@PSDCLD_VERSION macro
line1=%SPACE%* *************************************************************************************************
line2=%SPACE%* Summary:
line3=%SPACE%* Generic macro allowing to identify the file version of 'npnz16b.h'
line4=%SPACE%* 
line5=%SPACE%* Description:
line6=%SPACE%* This version key represents the product version of PS-DCLD as integer number
line7=%SPACE%* of the form [MAJOR][MINOR][REVISION] => version 0.9.3.xxx would be shown as 903.
line8=%SPACE%* User code can check if the file version is compliant with the proprietary user 
line9=%SPACE%* code by using pre-compiler directives such as 
line10=%SPACE%* 
line11=%SPACE%* #if (__PSDCLD_VERSION > 908)
line12=%SPACE%*  #pragma message "This code has not been tested with the recently included version of npnz16b.h"
line13=%SPACE%* #endif
line14=%SPACE%*  
line15=%SPACE%* *************************************************************************************************/
line16=%EMPTY%
line17=#ifndef __PSDCLD_VERSION
line18=%IDENT%#define __PSDCLD_VERSION    %PSDCLD_VERSION_CODE%
line19=#endif 
line20=%EMPTY%

[c_libheader_npnz_object_declaration]
count=351
line0=      /*@@NPNZ_STATUS_t data object
line1=%SPACE%* *************************************************************************************************
line2=%SPACE%* Summary:
line3=%SPACE%* Common Controller Status and Control Flag Bits
line4=%SPACE%* 
line5=%SPACE%* Description:
line6=%SPACE%* The 16-bit wide NPNZ_STATUS_t data object holds status and control bits for  
line7=%SPACE%* monitoring and control of the NPNZ16b_t controller during runtime. The lower 8 bit
line8=%SPACE%* of the status word are used for status indication while the upper 8 bit are used
line9=%SPACE%* by control bits.
line10=%SPACE%* 
line11=%SPACE%* For enhanced programming convenience definitions of status and control flags are 
line12=%SPACE%* provided
line13=%SPACE%*  
line14=%SPACE%* *************************************************************************************************/
line15=%EMPTY%
line16=      /* Status word values */
line17=#define NPNZ16_CONTROL_STATUS_CLEAR     0b0000000000000000
line18=#define NPNZ16_CONTROL_SATUATION_MSK    0b0000000000000011
line19=#define NPNZ16_CONTROL_LSAT_ACTIVE      0b0000000000000001
line20=#define NPNZ16_CONTROL_LSAT_CLEAR       0b0000000000000000
line21=#define NPNZ16_CONTROL_USAT_ACTIVE      0b0000000000000010
line22=#define NPNZ16_CONTROL_USAT_CLEAR       0b0000000000000000
line23=#define NPNZ16_CONTROL_AGC_DISABLE      0b0000000000000000
line24=#define NPNZ16_CONTROL_AGC_ENABLED      0b0000100000000000
line25=#define NPNZ16_CONTROL_TARGET_DEFAULT   0b0000000000000000
line26=#define NPNZ16_CONTROL_TARGET_SWAPED    0b0001000000000000
line27=#define NPNZ16_CONTROL_SOURCE_DEFAULT   0b0000000000000000
line28=#define NPNZ16_CONTROL_SOURCE_SWAPED    0b0010000000000000
line29=#define NPNZ16_CONTROL_INV_INPUT_OFF    0b0000000000000000
line30=#define NPNZ16_CONTROL_INV_INPUT_ON     0b0100000000000000
line31=#define NPNZ16_CONTROL_ENABLE_OFF       0b0000000000000000
line32=#define NPNZ16_CONTROL_ENABLE_ON        0b1000000000000000
line33=%EMPTY%
line34=      /* Status flags (bit-field) */
line35=typedef enum {
line36=%IDENT%NPNZ_SAT_CLEAR   = 0b0,     // No saturation condition detected
line37=%IDENT%NPNZ_SAT_ACTIVE = 0b1,      // Saturation limit violation detected
line38=}NPNZ_CONTROL_STATUS_SATURATION_e; // NPNZ output saturation status bits
line39=extern volatile NPNZ_CONTROL_STATUS_SATURATION_e npnzEnumControlStatusSaturation;
line40=%EMPTY%
line41=      /* Control flags (bit-field) */
line42=typedef enum {
line43=%IDENT%NPNZ_AGC_DISABLED   = 0b0,  // Adaptive Gain Modulation is disabled
line44=%IDENT%NPNZ_AGC_ENABLED = 0b1      // Adaptive Gain Modulation is enabled
line45=}NPNZ_CONTROL_AGC_ENABLE_e;     // Adaptive Gain Modulation control bits
line46=extern volatile NPNZ_CONTROL_AGC_ENABLE_e npnzEnumControlAgcEnable;
line47=%EMPTY%
line48=typedef enum {
line49=%IDENT%NPNZ_SOURCE_DEFAULT = 0b0,  // Controller source ports are not swapped, primary source is active input
line50=%IDENT%NPNZ_SOURCE_SWAPED = 0b1    // Controller source ports are swapped, alternate source is active input
line51=}NPNZ_CONTROL_SOURCE_SWAP_e;    // NPNZ Source Port Swap Control bits
line52=extern volatile NPNZ_CONTROL_SOURCE_SWAP_e npnzEnumControlSourceSwap;
line53=%EMPTY%
line54=typedef enum {
line55=%IDENT%NPNZ_TARGET_DEFAULT = 0b0,  // Controller target ports are not swapped, primary source is active output
line56=%IDENT%NPNZ_TARGET_SWAPED = 0b1    // Controller target ports are swapped, alternate target is active output
line57=}NPNZ_CONTROL_TARGET_SWAP_e;    // NPNZ Target Port Swap Control bits
line58=extern volatile NPNZ_CONTROL_TARGET_SWAP_e npnzEnumControlTargetSwap;
line59=%EMPTY%
line60=typedef enum {
line61=%IDENT%NPNZ_INPUT_DEFAULT = 0b0,   // Controller error value is not inverted
line62=%IDENT%NPNZ_INPUT_INVERTED = 0b1   // Controller error value is inverted
line63=}NPNZ_CONTROL_INPUT_INV_e;      // NPNZ Error Value Inversion Control bit
line64=extern volatile NPNZ_CONTROL_INPUT_INV_e npnzEnumControlInputInversion;
line65=%EMPTY%
line66=typedef enum {
line67=%IDENT%NPNZ_DISABLED = 0b0,        // Controller error value is not inverted
line68=%IDENT%NPNZ_ENABLED = 0b1          // Controller error value is inverted
line69=}NPNZ_CONTROL_ENABLE_e;         // NPNZ Controller Enable Control bit
line70=extern volatile NPNZ_CONTROL_ENABLE_e npnzEnumControlEnable;
line71=%EMPTY%
line72=      /* Controller status data structure */
line73=typedef struct NPNZ_STATUS_s {
line74=%IDENT%union {
line75=%IDENT%struct {
line76=%IDENT%%IDENT%volatile bool lower_saturation_event : 1; // Bit 0: control loop is clamped at minimum output level
line77=%IDENT%%IDENT%volatile bool upper_saturation_event : 1; // Bit 1: control loop is clamped at maximum output level
line78=%IDENT%%IDENT%volatile unsigned : 1; // Bit 2: reserved
line79=%IDENT%%IDENT%volatile unsigned : 1; // Bit 3: reserved
line80=%IDENT%%IDENT%volatile unsigned : 1; // Bit 4: reserved
line81=%IDENT%%IDENT%volatile unsigned : 1; // Bit 5: reserved
line82=%IDENT%%IDENT%volatile unsigned : 1; // Bit 6: reserved
line83=%IDENT%%IDENT%volatile unsigned : 1; // Bit 7: reserved
line84=%IDENT%%IDENT%volatile unsigned : 1; // Bit 8: reserved
line85=%IDENT%%IDENT%volatile unsigned : 1; // Bit 9: reserved
line86=%IDENT%%IDENT%volatile unsigned : 1; // Bit 11: reserved
line87=%IDENT%%IDENT%volatile bool agc_enabled: 1; // Bit 11: when set, Adaptive Gain Control Modulation is enabled
line88=%IDENT%%IDENT%volatile bool swap_target: 1; // Bit 12: when set, AltTarget is used as data output of controller
line89=%IDENT%%IDENT%volatile bool swap_source: 1; // Bit 13: when set, AltSource is used as data input to controller
line90=%IDENT%%IDENT%volatile bool invert_input: 1; // Bit 14: when set, most recent error input value to controller is inverted
line91=%IDENT%%IDENT%volatile bool enabled : 1; // Bit 15: enables/disables control loop execution
line92=%IDENT%} __attribute__((packed))bits;    // Controller status bit-field for direct bit access
line93=%IDENT%volatile uint16_t value;          // Controller status full register access
line94=%IDENT%};
line95=} __attribute__((packed)) NPNZ_STATUS_t; // Controller status word data structure allowing bit-wise access to status and control bits
line96=%EMPTY%
line97=      /*@@NPNZ_PORTS_t data object
line98=%SPACE%* *************************************************************************************************
line99=%SPACE%* Summary:
line100=%SPACE%* Filter Coefficient Arrays, Number Format Handling and Input/Output History Parameters
line101=%SPACE%* 
line102=%SPACE%* Description:
line103=%SPACE%* The NPNZ_PORTS_t data object holds a list of nested NPNZ_PORT_t data objects, each
line104=%SPACE%* defining an individual controller input or output port. The NPNZ16b_t data objects defines 
line105=%SPACE%* up to two input and two output ports of type struct NPNZ_PORT_t and one additional 
line106=%SPACE%* pointer to an external, user-defined 16-bit reference source variable. Each port of type 
line107=%SPACE%* struct NPNZ_PORT_t declares its individual source/target memory address, normalization 
line108=%SPACE%* scaler and offset:
line109=%SPACE%* 
line110=%SPACE%*  - Primary Source:   common feedback input object
line111=%SPACE%*  - Alternate Source: additional, alternate feedback input object (optional)
line112=%SPACE%*  - Primary Target:   common control output target object 
line113=%SPACE%*  - Alternate Target: additional, alternate control output target object (optional)
line114=%SPACE%*  - Control Reference: pointer to external 16-bit reference source variable
line115=%SPACE%* 
line116=%SPACE%* *************************************************************************************************/
line117=%EMPTY%
line118=      /* Controller Input/Output Port */
line119=typedef struct NPNZ_PORT_s{
line120=%EMPTY%
line121=%IDENT%volatile uint16_t* ptrAddress; // Pointer to register or variable where the value is read from (e.g. ADCBUFx) or written to (e.g. PGxDC)
line122=%IDENT%volatile int16_t   NormScaler; // Bit-shift scaler of the Q15 normalization factor
line123=%IDENT%volatile fractional NormFactor; // Q15 normalization factor
line124=%IDENT%volatile int16_t   Offset; // Value/signal offset of this port
line125=%EMPTY%
line126=} __attribute__((packed)) NPNZ_PORT_t; // Data structure defining parameters of a controller input or output port
line127=%EMPTY%
line128=      /* List of Controller Input/Output Ports */
line129=typedef struct NPNZ_PORTS_s{
line130=%EMPTY%
line131=%IDENT%volatile struct NPNZ_PORT_s Source; // Primary data input port declaration
line132=%IDENT%volatile struct NPNZ_PORT_s AltSource; // Secondary data input port declaration
line133=%IDENT%volatile struct NPNZ_PORT_s Target; // Primary data output port declaration
line134=%IDENT%volatile struct NPNZ_PORT_s AltTarget; // Secondary data output port declaration
line135=%IDENT%volatile uint16_t* ptrControlReference; // Pointer to global variable of input register holding the controller reference value (e.g. uint16_t my_ref)
line136=%EMPTY%
line137=} __attribute__((packed)) NPNZ_PORTS_t; // Data structure merging all defined controller input and output ports
line138=%EMPTY%
line139=      /*@@NPNZ_FILTER_PARAMS_t data object
line140=%SPACE%* *************************************************************************************************
line141=%SPACE%* Summary:
line142=%SPACE%* Filter Coefficient Arrays, Number Format Handling and Input/Output History Parameters
line143=%SPACE%* 
line144=%SPACE%* Description:
line145=%SPACE%* The NPNZ_FILTER_PARAMS_t data object holds all configuration parameters of the compensation
line146=%SPACE%* filter. These parameters include pointers to external arrays of filter coefficients, error
line147=%SPACE%* and control history as well as number format normalization parameters like pre- and post-
line148=%SPACE%* scalers.
line149=%SPACE%*  
line150=%SPACE%* *************************************************************************************************/
line151=%EMPTY%
line152=typedef struct NPNZ_FILTER_PARAMS_s{
line153=%EMPTY%
line154=%IDENT%volatile int32_t* ptrACoefficients; // Pointer to A coefficients located in X-space
line155=%IDENT%volatile int32_t* ptrBCoefficients; // Pointer to B coefficients located in X-space
line156=%IDENT%volatile fractional* ptrControlHistory; // Pointer to n delay-line samples located in Y-space with first sample being the most recent
line157=%IDENT%volatile fractional* ptrErrorHistory; // Pointer to n+1 delay-line samples located in Y-space with first sample being the most recent
line158=%EMPTY%
line159=%IDENT%// Array size information
line160=%IDENT%volatile uint16_t ACoefficientsArraySize; // Size of the A coefficients array in X-space
line161=%IDENT%volatile uint16_t BCoefficientsArraySize; // Size of the B coefficients array in X-space
line162=%IDENT%volatile uint16_t ControlHistoryArraySize; // Size of the control history array in Y-space
line163=%IDENT%volatile uint16_t ErrorHistoryArraySize; // Size of the error history array in Y-space
line164=%EMPTY%
line165=%IDENT%// Feedback scaling Input/Output Normalization
line166=%IDENT%volatile int16_t normPreShift; // Normalization of ADC-resolution to Q15 (R/W)
line167=%IDENT%volatile int16_t normPostShiftA; // Normalization of A-term control output to Q15 (R/W)
line168=%IDENT%volatile int16_t normPostShiftB; // Normalization of B-term control output to Q15 (R/W)
line169=%IDENT%volatile int16_t normPostScaler; // Control output normalization factor (Q15) (R/W)
line170=%EMPTY%
line171=%IDENT%// P-Term Coefficients (for plant measurements only)
line172=%IDENT%volatile int16_t PTermScaler; // Q15 P-Term Coefficient Bit-Shift Scaler (R/W)
line173=%IDENT%volatile int16_t PTermFactor; // Q15 P-Term Coefficient Factor (R/W)
line174=%EMPTY%
line175=} __attribute__((packed)) NPNZ_FILTER_PARAMS_t; // Data structure for filter parameters such as pointer to history and coefficient arrays and number scaling factors
line176=%EMPTY%
line177=      /*@@NPNZ_LIMITS_t data object
line178=%SPACE%* *************************************************************************************************
line179=%SPACE%* Summary:
line180=%SPACE%* System Anti-Windup (Output Clamping) Thresholds
line181=%SPACE%* 
line182=%SPACE%* Description:
line183=%SPACE%* The NPNZ_LIMITS_t data object holds all parameters required to automatically clamp the 
line184=%SPACE%* most recent control output to user-defined thresholds. This data type allows the 
line185=%SPACE%* definition of individual minimum and maximum output values for the NPNZ controller primary 
line186=%SPACE%* and alternate output port.
line187=%SPACE%* 
line188=%SPACE%* This feature is optional and needs to be enabled, configured and managed manually in
line189=%SPACE%* user code.
line190=%SPACE%*  
line191=%SPACE%* *************************************************************************************************/
line192=%EMPTY%
line193=typedef struct NPNZ_LIMITS_s{
line194=%EMPTY%
line195=%IDENT%volatile int16_t MinOutput; // Minimum output value used for clamping (R/W)
line196=%IDENT%volatile int16_t MaxOutput; // Maximum output value used for clamping (R/W)
line197=%IDENT%volatile int16_t AltMinOutput; // Alternate minimum output value used for clamping (R/W)
line198=%IDENT%volatile int16_t AltMaxOutput; // Alternate maximum output value used for clamping (R/W)
line199=%EMPTY%
line200=} __attribute__((packed)) NPNZ_LIMITS_t; // Data strucure holding control output clamping threshold values
line201=%EMPTY%
line202=      /*@@NPNZ_ADC_TRGCTRL_t data object
line203=%SPACE%* *************************************************************************************************
line204=%SPACE%* Summary:
line205=%SPACE%* Automated ADC Trigger handling
line206=%SPACE%* 
line207=%SPACE%* Description:
line208=%SPACE%* The NPNZ_ADC_TRGCTRL_t data object holds all parameters required to automatically position
line209=%SPACE%* ADC triggers based on the most recent control output. This feature is used in voltage or
line210=%SPACE%* average current mode control to automatically track average values in triangular feedback
line211=%SPACE%* signal waveforms.
line212=%SPACE%* 
line213=%SPACE%* This feature is optional and needs to be enabled, configured and managed manually in
line214=%SPACE%* user code.
line215=%SPACE%*  
line216=%SPACE%* *************************************************************************************************/
line217=%EMPTY%
line218=typedef struct NPNZ_ADC_TRGCTRL_s{
line219=%EMPTY%
line220=%IDENT%volatile uint16_t* ptrADCTriggerARegister; // Pointer to ADC trigger #1 register (e.g. TRIG1)
line221=%IDENT%volatile uint16_t ADCTriggerAOffset; // ADC trigger #1 offset to compensate propagation delays
line222=%IDENT%volatile uint16_t* ptrADCTriggerBRegister; // Pointer to ADC trigger #2 register (e.g. TRIG2)
line223=%IDENT%volatile uint16_t ADCTriggerBOffset; // ADC trigger #2 offset to compensate propagation delays
line224=%EMPTY%
line225=} __attribute__((packed)) NPNZ_ADC_TRGCTRL_t; // Automatic ADC trigger placement parameters for primary ADC trigger A and secondary trigger B
line226=%EMPTY%
line227=      /*@@NPNZ_DATA_PROVIDERS_t data object
line228=%SPACE%* *************************************************************************************************
line229=%SPACE%* Summary:
line230=%SPACE%* Data Provider Target Memory Addresses
line231=%SPACE%* 
line232=%SPACE%* Description:
line233=%SPACE%* The NPNZ_DATA_PROVIDERS_t data object holds pointers to external, user-defined, global
line234=%SPACE%* variables allowing the NPNZ controller to push internal data to external, user-defined,
line235=%SPACE%* global variables during the execution of the NPNZ controller, resulting in an automated
line236=%SPACE%* updated of user-code variable values during runtime.
line237=%SPACE%* 
line238=%SPACE%* This feature is optional and needs to be enabled, configured and managed manually in
line239=%SPACE%* user code.
line240=%SPACE%*  
line241=%SPACE%* *************************************************************************************************/
line242=%EMPTY%
line243=typedef struct NPNZ_DATA_PROVIDERS_s{
line244=%EMPTY%
line245=%IDENT%volatile uint16_t* ptrDProvControlInput; // Pointer to external data buffer of most recent, raw control input
line246=%IDENT%volatile uint16_t* ptrDProvControlInputCompensated; // Pointer to external data buffer of most recent, compensated control input
line247=%IDENT%volatile uint16_t* ptrDProvControlError; // Pointer to external data buffer of most recent control error
line248=%IDENT%volatile uint16_t* ptrDProvControlOutput; // Pointer to external data buffer of most recent control output
line249=%EMPTY%
line250=} __attribute__((packed)) NPNZ_DATA_PROVIDERS_t; // Automated data provider pointers used to push most recent data points to user-defined variables
line251=%EMPTY%
line252=      /*@@NPNZ_CASCADE_TRG_t data object
line253=%SPACE%* *************************************************************************************************
line254=%SPACE%* Summary:
line255=%SPACE%* Cascaded Function Call Parameters
line256=%SPACE%* 
line257=%SPACE%* Description:
line258=%SPACE%* The NPNZ_CASCADE_TRG_t data object holds all parameters required to perform cascaded 
line259=%SPACE%* function call triggers. When enabled, the NPNZ controller can automatically call any
line260=%SPACE%* user-defined function after the execution of the control loop. This data object declares
line261=%SPACE%* a function pointer <ptrCascadedFunction> and one additional, 16-bit wide function parameter
line262=%SPACE%* <CascadedFunctionParam>.
line263=%SPACE%* 
line264=%SPACE%* This feature is optional and needs to be enabled, configured and managed manually in
line265=%SPACE%* user code.
line266=%SPACE%*  
line267=%SPACE%* *************************************************************************************************/
line268=%EMPTY%
line269=typedef struct NPNZ_CASCADE_TRG_s{
line270=%EMPTY%
line271=%IDENT%volatile uint16_t ptrCascadedFunction; // Pointer to Function which should be called at the end of the control loop
line272=%IDENT%volatile uint16_t CascadedFunctionParam; // Parameter of function called (can be a pointer to a data structure)
line273=%EMPTY%
line274=} __attribute__((packed)) NPNZ_CASCADE_TRG_t; // Function pointer and parameters used to build cascaded, daisy chained function sequences by calling an user-defined, external function at the end of the control loop execution 
line275=%EMPTY%
line276=      /*@@NPNZ_GAIN_CONTROL_t data object
line277=%SPACE%* *************************************************************************************************
line278=%SPACE%* Summary:
line279=%SPACE%* Adaptive Gain Control Modulation Parameters
line280=%SPACE%* 
line281=%SPACE%* Description:
line282=%SPACE%* The NPNZ_GAIN_CONTROL_t data object holds all parameters required to perform real-time 
line283=%SPACE%* gain modulation of the z-domain feedback loop. The loop gain is modulated by multiplying
line284=%SPACE%* the result of the NPNZ controller B-term with an additional scaling factor. This scaling
line285=%SPACE%* factor is represented by a fast floating point number, consisting of a factional factor
line286=%SPACE%* <AgcFactor> between -1 and 1 and an integer bit-shift scaler <AgcScaler>.
line287=%SPACE%* 
line288=%SPACE%* This feature is optional and needs to be enabled, configured and managed manually in
line289=%SPACE%* user code.
line290=%SPACE%*  
line291=%SPACE%* *************************************************************************************************/
line292=%EMPTY%
line293=typedef struct NPNZ_GAIN_CONTROL_s{
line294=%EMPTY%
line295=%IDENT%volatile uint16_t AgcScaler; // Bit-shift scaler of Adaptive Gain Modulation factor
line296=%IDENT%volatile fractional AgcFactor; // Q15 value of Adaptive Gain Modulation factor
line297=%IDENT%volatile fractional AgcMedian; // Q15 value of Adaptive Gain Modulation nominal operating point
line298=%IDENT%volatile uint16_t ptrAgcObserverFunction; // Function Pointer to Observer function updating the AGC modulation factor
line299=%EMPTY%
line300=} __attribute__((packed)) NPNZ_GAIN_CONTROL_t; // Data structure holding parameters required for adaptive or manual loop gain manipulation during runtime
line301=%EMPTY%
line302=      /*@@NPNZ_USER_DATA_BUFFER_t data object
line303=%SPACE%* *************************************************************************************************
line304=%SPACE%* Summary:
line305=%SPACE%* User Data Space for Advanced Control Functions  
line306=%SPACE%* 
line307=%SPACE%* Description:
line308=%SPACE%* The NPNZ_USER_DATA_BUFFER_t data object reserves four word of additional data space for 
line309=%SPACE%* user parameters. These parameters may be handled by user code and are not assigned to any
line310=%SPACE%* specific, pre-defined functions.
line311=%SPACE%*  
line312=%SPACE%* *************************************************************************************************/
line313=%EMPTY%
line314=typedef struct NPNZ_USER_DATA_BUFFER_s{
line315=%EMPTY%
line316=%IDENT%volatile uint16_t usrParam1; // generic 16-bit wide, user-defined parameter #1 for advanced control options
line317=%IDENT%volatile uint16_t usrParam2; // generic 16-bit wide, user-defined parameter #2 for advanced control options
line318=%IDENT%volatile uint16_t usrParam3; // generic 16-bit wide, user-defined parameter #3 for advanced control options
line319=%IDENT%volatile uint16_t usrParam4; // generic 16-bit wide, user-defined parameter #4 for advanced control options
line320=%EMPTY%
line321=} __attribute__((packed)) NPNZ_USER_DATA_BUFFER_t; // Generic data buffer for undetermined use. These data buffers may be used by advanced control algorithms or be used by proprietary user code modules
line322=%EMPTY%
line323=      /*@@NPNZ16b_t data structure
line324=%SPACE%* *************************************************************************************************
line325=%SPACE%* Summary:
line326=%SPACE%* Global NPNZ controller data object  
line327=%SPACE%* 
line328=%SPACE%* Description:
line329=%SPACE%* The NPNZ16b_t data object holds all configuration, status, control and monitoring values 
line330=%SPACE%* of a z-domain lead-lag compensator based controller. All data types of this data object,
line331=%SPACE%* including floating, are scaled to a 16 bit number space, optimized for code execution on
line332=%SPACE%* Microchip dsPIC33 family of devices. Please refer to the description of nested data 
line333=%SPACE%* structures above for more information about nested data objects.
line334=%SPACE%*  
line335=%SPACE%* *************************************************************************************************/
line336=%EMPTY%
line337=typedef struct NPNZ16b_s {
line338=%EMPTY%
line339=%IDENT%volatile struct NPNZ_STATUS_s status; // Control Loop Status and Control flags
line340=%IDENT%volatile struct NPNZ_PORTS_s Ports; // Controller input and output ports
line341=%IDENT%volatile struct NPNZ_FILTER_PARAMS_s Filter; // Filter parameters such as pointer to history and coefficient arrays and number scaling
line342=%IDENT%volatile struct NPNZ_LIMITS_s Limits; // Input and output clamping values
line343=%IDENT%volatile struct NPNZ_ADC_TRGCTRL_s ADCTriggerControl; // Automatic ADC trigger placement options for ADC Trigger A and B
line344=%IDENT%volatile struct NPNZ_DATA_PROVIDERS_s DataProviders; // Automated data sources pushing recent data points to user-defined variables
line345=%IDENT%volatile struct NPNZ_CASCADE_TRG_s CascadeTrigger; // Cascade triggers with parameters for next function call
line346=%IDENT%volatile struct NPNZ_GAIN_CONTROL_s GainControl; // Parameter section for advanced control options
line347=%IDENT%volatile struct NPNZ_USER_DATA_BUFFER_s Advanced; // Parameter section for advanced user control options
line348=%EMPTY%
line349=} __attribute__((packed)) NPNZ16b_t; // Generic NPNZ16b Controller Object. This data structure is the main API data object providing single-point access to all controller settings and parameters
line350=%EMPTY%

[c_libheader_guard_end]
count=3
line0=      /* ********************************************************************************/
line1=#endif  // end of __SPECIAL_FUNCTION_LAYER_LIB_NPNZ16B_H__ header file section
line2=%EMPTY%

[c_config_head_comment]
count=31
line0=      /* ********************************************************************************
line1=%SPACE%* %FILTER_ORDER%p%FILTER_ORDER%z Controller Configuration Code Example
line2=%SPACE%* ********************************************************************************
line3=%SPACE%* 
line4=%SPACE%* The following code example covers all user-defined configurations of the
line5=%SPACE%* control object '%PREFIX%' required to run the recently configured controller.
line6=%SPACE%* 
line7=%SPACE%* Please note:
line8=%SPACE%* This is no executable code and serves only as template for the integration into
line9=%SPACE%* a proprietary firmware project. You can copy & paste this entire code example 
line10=%SPACE%* to your code project by clicking the 'Copy to Clipboard' above or pick specific
line11=%SPACE%* section by selecting a text section and pressing <CTRL>+'C'.
line12=%SPACE%* 
line13=%SPACE%* Once code has been copied to user code, each setting has to be configured by
line14=%SPACE%* replacing the placeholders <[data type]> in each code line by your individual
line15=%SPACE%* configuration values.
line16=%SPACE%* 
line17=%SPACE%* This code example only lists configurations of features which have been selected
line18=%SPACE%* in this tool. Enabling/disabling code generation options may also change the 
line19=%SPACE%* contents of this code example. Unused options are EXCLUDED from this code example.
line20=%SPACE%* 
line21=%SPACE%* ********************************************************************************/
line22=%EMPTY%
line23=%NOIDENT%// Standard Include Files
line24=%NOIDENT%#include <stdint.h> // include standard integer data types
line25=%NOIDENT%#include <stdbool.h> // include standard boolean data types
line26=%NOIDENT%#include <stddef.h> // include standard definition data types
line27=%EMPTY%
line28=%NOIDENT%// %FILTER_ORDER%p%FILTER_ORDER%z Controller Include Files
line29=%NOIDENT%#include "%C_HEADER_INCLUDE_PATH%%PREFIX%.h" // include '%PREFIX%' controller header file
line30=%EMPTY%

[c_config_function_head]
count=4
line0=%NOIDENT%volatile uint16_t %PREFIX%_ControlObject_Initialize(void)
line1=%NOIDENT%{
line2=%IDENT%volatile uint16_t retval = 0; // Auxiliary variable for function call verification (initially set to ZERO = false)
line3=%EMPTY%

[c_config_function_end]
count=8
line0=%EMPTY%
line1=%IDENT%// Call Assembly Control Library Initialization Function
line2=%IDENT%retval = %PREFIX%_Initialize(&%PREFIX%); // Initialize controller data arrays and number scalers
line3=%EMPTY%
line4=%IDENT%return(retval);
line5=%EMPTY%
line6=%NOIDENT%}
line7=%EMPTY%

[c_config_primary_source]
count=8
line0=%IDENT%/* Controller Input and Output Ports Configuration */
line1=%EMPTY%
line2=%IDENT%// Configure Controller Primary Input Port
line3=%IDENT%%PREFIX%.Ports.Source.ptrAddress = &<unsigned int>; // Pointer to primary feedback source (e.g. ADC buffer register or variable)
line4=%IDENT%%PREFIX%.Ports.Source.Offset = <signed int>; // Primary feedback signal offset 
line5=%IDENT%%PREFIX%.Ports.Source.NormScaler = <signed int>; // Primary feedback normalization factor bit-shift scaler 
line6=%IDENT%%PREFIX%.Ports.Source.NormFactor = <signed int/Q15 fractional>; // Primary feedback normalization factor fractional
line7=%EMPTY%

[c_config_alternate_source]
count=6
line0=%IDENT%// Configure Controller Alternate Input Port
line1=%IDENT%%PREFIX%.Ports.AltSource.ptrAddress = &<unsigned int>; // Pointer to alternate feedback source (e.g. ADC buffer register or variable)
line2=%IDENT%%PREFIX%.Ports.AltSource.Offset = <signed int>; // // Alternate feedback signal offset 
line3=%IDENT%%PREFIX%.Ports.AltSource.NormScaler = <signed int>; // Alternate feedback normalization factor bit-shift scaler 
line4=%IDENT%%PREFIX%.Ports.AltSource.NormFactor = <signed int/Q15 fractional>; // Alternate feedback normalization factor fractional
line5=%EMPTY%

[c_config_primary_target]
count=6
line0=%IDENT%// Configure Controller Primary Output Port
line1=%IDENT%%PREFIX%.Ports.Target.ptrAddress = &<unsigned int>; // Pointer to primary output target (e.g. SFR register or variable)
line2=%IDENT%%PREFIX%.Ports.Target.Offset = <signed int>; // Primary output offset value
line3=%IDENT%%PREFIX%.Ports.Target.NormScaler = <signed int>; // Primary output normalization factor bit-shift scaler 
line4=%IDENT%%PREFIX%.Ports.Target.NormFactor = <signed int/Q15 fractional>; // Primary output normalization factor fractional
line5=%EMPTY%

[c_config_alternate_target]
count=6
line0=%IDENT%// Configure Controller Alternate Output Port
line1=%IDENT%%PREFIX%.Ports.AltTarget.ptrAddress = &<unsigned int>; // Pointer to alternate output target (e.g. SFR or variable)
line2=%IDENT%%PREFIX%.Ports.AltTarget.Offset = <signed int>; // Alternate output offset value
line3=%IDENT%%PREFIX%.Ports.AltTarget.NormScaler = <signed int>; // Alternate output normalization factor bit-shift scaler 
line4=%IDENT%%PREFIX%.Ports.AltTarget.NormFactor = <signed int/Q15 fractional>; // Alternate output normalization factor fractional
line5=%EMPTY%

[c_config_reference]
count=3
line0=%IDENT%// Configure Control Reference Port
line1=%IDENT%%PREFIX%.Ports.ptrControlReference = &<unsigned int>; // Pointer to control reference (user-variable)
line2=%EMPTY%

[c_config_limits_start]
count=3
line0=%IDENT%/* Controller Output Limits Configuration */
line1=%EMPTY%
line2=%IDENT%// Primary Control Output Limit Configuration

[c_config_limits_min]
count=1
line0=%IDENT%%PREFIX%.Limits.MinOutput = <signed int>; // Minimum control output value

[c_config_limits_max]
count=1
line0=%IDENT%%PREFIX%.Limits.MaxOutput = <signed int>; // Maximum control output value

[c_config_limits_stop]
count=1
line0=%EMPTY%

[c_config_alternate_limits_start]
count=1
line0=%IDENT%// Alternate Control Output Limit Configuration

[c_config_alternate_limits_min]
count=1
line0=%IDENT%%PREFIX%.Limits.AltMinOutput = <signed int>; // Minimum alternate control output value

[c_config_alternate_limits_max]
count=1
line0=%IDENT%%PREFIX%.Limits.AltMaxOutput = <signed int>; // Maximum alternate control output value

[c_config_alternate_limits_stop]
count=1
line0=%EMPTY%

[c_config_adc_trigger_start]
count=2
line0=%IDENT%/* ADC Trigger Positioning Configuration */
line1=%EMPTY%

[c_config_adc_trigger_a]
count=4
line0=%IDENT%// ADC Trigger A Control Configuration
line1=%IDENT%%PREFIX%.ADCTriggerControl.ptrADCTriggerARegister = &<unsigned int>; // Pointer to ADC trigger A register
line2=%IDENT%%PREFIX%.ADCTriggerControl.ADCTriggerAOffset = <unsigned int>; // user-defined trigger delay (
line3=%EMPTY%

[c_config_adc_trigger_b]
count=4
line0=%IDENT%// ADC Trigger B Control Configuration
line1=%IDENT%%PREFIX%.ADCTriggerControl.ptrADCTriggerBRegister = &<unsigned int>; // Pointer to ADC trigger B register
line2=%IDENT%%PREFIX%.ADCTriggerControl.ADCTriggerBOffset = <unsigned int>; // user-defined trigger delay (
line3=%EMPTY%

[c_config_data_providers_start]
count=2
line0=%IDENT%/* Data Provider Configuration Configuration */
line1=%EMPTY%

[c_config_data_provider_a]
count=1
line0=%IDENT%%PREFIX%.DataProviders.ptrDProvControlInput = &<unsigned int>; // Pointer to user specified buffer variable (raw control input value)

[c_config_data_provider_b]
count=1
line0=%IDENT%%PREFIX%.DataProviders.ptrDProvControlInputCompensated = &<unsigned int>; // Pointer to user specified buffer variable (compensated control input value)

[c_config_data_provider_c]
count=1
line0=%IDENT%%PREFIX%.DataProviders.ptrDProvControlError = &<unsigned int>; // Pointer to user specified buffer variable (control error value)

[c_config_data_provider_d]
count=1
line0=%IDENT%%PREFIX%.DataProviders.ptrDProvControlOutput = &<unsigned int>; // Pointer to user specified buffer variable (control output value)

[c_config_data_providers_stop]
count=1
line0=%EMPTY%

[c_config_cascade_trigger]
count=6
line0=%IDENT%/* Function Cascade Configuration */
line1=%EMPTY%
line2=%IDENT%// Call Function Declaration
line3=%IDENT%%PREFIX%.CascadeTrigger.ptrCascadedFunction = (uint16_t)&<unsigned int>; // Pointer to user specified function
line4=%IDENT%%PREFIX%.CascadeTrigger.CascadedFunctionParam = (uint16_t)&<unsigned int>; // User specified function parameter
line5=%EMPTY%

[c_config_gain_control]
count=6
line0=%IDENT%/* Gain Control Interface Configuration */
line1=%EMPTY%
line2=%IDENT%// Initialize Gain Control Tuning Factors
line3=%IDENT%%PREFIX%.GainControl.AgcFactor = <signed int/Q15 fractional>; // Adaptive Gain Control factor fractional
line4=%IDENT%%PREFIX%.GainControl.AgcScaler = <signed int>; // Adaptive Gain Control factor bit-shift scaler
line5=%IDENT%%PREFIX%.GainControl.AgcMedian = <signed int/Q15 fractional>; // Q15 number representing normalized Nominal Operating Point

[c_config_gain_control_observer_call]
count=1
line0=%IDENT%%PREFIX%.GainControl.ptrAgcObserverFunction = (uint16_t)&<unsigned int>; // Function Pointer to user-defined observer function updating the AGC modulation factor

[c_config_gain_control_stop]
count=1
line0=%EMPTY%

[c_config_user_data_buffer]
count=8
line0=%IDENT%/* Advanced Parameter Configuration */
line1=%EMPTY%
line2=%IDENT%// Initialize User Data Space Buffer Variables
line3=%IDENT%%PREFIX%.Advanced.usrParam1 = 0; // No additional advanced control options used
line4=%IDENT%%PREFIX%.Advanced.usrParam2 = 0; // No additional advanced control options used
line5=%IDENT%%PREFIX%.Advanced.usrParam3 = 0; // No additional advanced control options used
line6=%IDENT%%PREFIX%.Advanced.usrParam4 = 0; // No additional advanced control options used
line7=%EMPTY%

[c_config_status_word_start]
count=2
line0=%IDENT%/* Controller Status Word Configuration */
line1=%EMPTY%

[c_config_status_word_enable]
count=1
line0=%IDENT%%PREFIX%.status.bits.enabled = false; // Keep controller disabled

[c_config_status_word_invert_input]
count=1
line0=%IDENT%%PREFIX%.status.bits.invert_input = false; // Do not invert input value

[c_config_status_word_alternate_source]
count=1
line0=%IDENT%%PREFIX%.status.bits.swap_source = false; // Use Primary Source as major control input

[c_config_status_word_alternate_target]
count=1
line0=%IDENT%%PREFIX%.status.bits.swap_target = false; // Use Primary Target as major control output

[c_config_status_word_agc_enable]
count=1
line0=%IDENT%%PREFIX%.status.bits.agc_enabled = false;   // Enable Adaptive Gain Modulation by default

[c_config_status_word_upper_saturation]
count=1
line0=%IDENT%%PREFIX%.status.bits.upper_saturation_event = false; // Reset Anti-Windup Minimum Status bits

[c_config_status_word_lower_saturation]
count=1
line0=%IDENT%%PREFIX%.status.bits.lower_saturation_event = false; // Reset Anti-Windup Minimum Status bit

[c_config_control_interrupt_service_routine]
count=24
line0=%NOIDENT%/* %FILTER_ORDER%p%FILTER_ORDER%z Control Loop Interrupt Service Routine for Controller Object '%PREFIX%'
line1=%SPACE%* **************************************************************************************************
line2=%SPACE%* This code example of a interrupt service routine uses the tailored name label '_%PREFIX%'.
line3=%SPACE%* The assembly library code sequences of controller data objects generated by PS-DCLD are optimized
line4=%SPACE%* for being called by a PWM interrupt for minimum response time. However, in some applications
line5=%SPACE%* it might be desired to call the control loop from other interrupt sources. 
line6=%SPACE%* Using custom labels for interrupt routines allows using generic interrupt service routine 
line7=%SPACE%* function calls in code, which can be mapped to specific interrupt sources by adding a #define
line8=%SPACE%* pre-compiler directive declaration to your code, like the following example:
line9=%SPACE%* 
line10=%SPACE%*%IDENT%#define _%PREFIX%_Interrupt    _PWM1Interrupt // Define label for interrupt service routine function call
line11=%SPACE%*%IDENT%#define _%PREFIX%_ISRIF        _PWM1IF // Define label for interrupt flag bit
line12=%SPACE%* 
line13=%SPACE%* **************************************************************************************************/
line14=%EMPTY%
line15=%NOIDENT%void __attribute__((__interrupt__, no_auto_psv, context))_%PREFIXU%_Interrupt(void)
line16=%NOIDENT%{
line17=%EMPTY%
line18=%IDENT%%PREFIX%_Update(&%PREFIX%); // Call control loop
line19=%EMPTY%
line20=%IDENT%_%PREFIX%_ISRIF = 0;  // Clear the interrupt flag 
line21=%EMPTY%
line22=%NOIDENT%}
line23=%EMPTY%


[execlist_c_source]
description=NPNZ16b controller API C-source file providing function prototypes for assembly code modules and routines for initialization 
name=C code API source file of generated controller library 
count=15
0=c_code_head_comment
1=c_source_include_c_header
2=c_source_declarations_comment
3=c_source_array_declarations
4=c_source_coefficient_declarations
5=%{(1209)}%c_source_pterm_declarations
6=%{(1800)}%c_source_agc_declarations
7=c_source_controller_declarations
8=c_source_init_comment
9=c_source_init_start
10=c_source_init_controller
11=%{(1209)}%c_source_init_pterm
12=%{(1800)}%c_source_init_agc
13=c_source_init_end
14=c_code_tool_link


[execlist_c_header]
description=NPNZ16b controller API C-header file providing puclic access to function prototypes for assembly code modules and routines for initialization 
name=C code API header file of generated controller library 
count=12
0=c_code_head_comment
1=c_header_guard_start
2=c_header_include
3=c_header_declarations_comment
4=c_header_array_declarations
5=%{(1209)}%c_header_pterm_declarations
6=%{(1800)}%c_header_agc_declarations
7=c_header_controller_declarations
8=c_header_function_prototypes
9=%{(1209)}%c_header_function_prototypes_pterm
10=c_header_guard_end
11=c_code_tool_link


[execlist_c_lib_header]
description=Global NPNZ16b C code library data object declaration used by the API C header file. This file only needs to be present once per project.
name=Generic NPNZ Controller Library C-Header File
count=7
0=c_libheader_head_comment
1=c_libheader_guard_start
2=c_libheader_include
3=c_libheader_dcld_macro
4=c_libheader_npnz_object_declaration
5=c_libheader_guard_end
6=c_code_tool_link


[execlist_c_config]
description=This example code can be used as template for the initialization of the generated NPNZ16b controller
name=NPNZ16b data object initialization code example
count=40
0=c_config_head_comment
1=c_config_function_head
2=c_config_primary_source
3=%{(1300)&&(1301)}%c_config_alternate_source
4=c_config_primary_target
5=%{(1300)&&(1302)}%c_config_alternate_target
6=c_config_reference
7=%{(1500)}%%{(1501)||(1503)}%c_config_limits_start
8=%{(1500)&&(1503)}%c_config_limits_min
9=%{(1500)&&(1501)}%c_config_limits_max
10=%{(1500)}%%{(1501)||(1503)}%c_config_limits_stop
11=%{(1500)}%%{(1501)||(1503)}%%{(1300)&&(1302)&&(!1303)}%c_config_alternate_limits_start
12=%{(1500)&&(1503)}%%{(1300)&&(1302)&&(!1303)}%c_config_alternate_limits_min
13=%{(1500)&&(1501)}%%{(1300)&&(1302)&&(!1303)}%c_config_alternate_limits_max
14=%{(1500)}%%{(1501)||(1503)}%%{(1300)&&(1302)&&(!1303)}%c_config_alternate_limits_stop
15=%{(1200)}%%{(1206)||(1207)}%c_config_adc_trigger_start
16=%{(1200)&&(1206)}%c_config_adc_trigger_a
17=%{(1200)&&(1207)}%c_config_adc_trigger_b
18=%{(1400)}%%{(1401)||(1402)||(1403)||(1404)}%c_config_data_providers_start
19=%{(1400)&&(1401)}%c_config_data_provider_a
20=%{(1400)&&(1402)}%c_config_data_provider_b
21=%{(1400)&&(1403)}%c_config_data_provider_c
22=%{(1400)&&(1404)}%c_config_data_provider_d
23=%{(1400)}%%{(1401)||(1402)||(1403)||(1404)}%c_config_data_providers_stop
24=%{(1300)&&(1304)}%c_config_cascade_trigger
25=%{(1800)}%c_config_gain_control
26=%{(1800)&&(1802)}%c_config_gain_control_observer_call
27=%{(1800)}%c_config_gain_control_stop
28=c_config_user_data_buffer
29=c_config_status_word_start
30=%{(1200)&&(1203)}%c_config_status_word_enable
31=%{(1600)&&(1602)}%c_config_status_word_invert_input
32=%{(1300)&&(1301)}%c_config_status_word_alternate_source
33=%{(1300)&&(1302)&&(!1303)}%c_config_status_word_alternate_target
34=%{(1800)&&(1801)}%c_config_status_word_agc_enable
35=%{(1500)&&(1501)&&(1502)}%c_config_status_word_upper_saturation
36=%{(1500)&&(1503)&&(1504)}%c_config_status_word_lower_saturation
37=c_config_function_end
38=c_config_control_interrupt_service_routine
39=c_code_tool_link


[simplis:blocks]
count=3
0=simplis_section_symbol
1=simplis_section_instance
2=simplis_section_style_library

[simplis_section_symbol]
count=18
line0=.Symbol
line1=Attributes format=1.0 revision=8 name="MCP1703A-33" description="MCP1703A-33" catalog="Vendor;Linear Regulators"
line2=Segment x1=0 y1=-120 x2=960 y2=-120 
line3=Segment x1=0 y1=-120 x2=0 y2=600 
line4=Segment x1=960 y1=-120 x2=960 y2=600 
line5=Segment x1=-120 y1=0 x2=0 y2=0 
line6=Segment x1=1080 y1=0 x2=960 y2=0 
line7=Segment x1=0 y1=600 x2=960 y2=600 
line8=Segment x1=480 y1=720 x2=480 y2=600 
line9=Pin name="GND" order=2 x=480 y=720 visible=1 xlabel=-90 ylabel=-183 align=LeftBase rotated=0
line10=Pin name="VIN" order=1 x=-120 y=0 visible=1 xlabel=180 ylabel=0 align=LeftBase rotated=0
line11=Pin name="VOUT" order=3 x=1080 y=0 visible=1 xlabel=-170 ylabel=0 align=RightBase rotated=0
line12=Property name="Model" value="X" autopos=1 normal=Left rotated=Left visible=0 font=Default order=-1
line13=Property name="PART" value="MCP1703A-33" autopos=1 normal=Top rotated=Left linear=1 font=Default order=-1
line14=Property name="Ref" value="U?" autopos=1 normal=Top rotated=Right font=Default order=-1
line15=Property name="SIMULATOR" value="SIMetrix" autopos=1 normal=Left rotated=Left protected=1 visible=0 font=Default order=-1
line16=Property name="VALUE" value="MCP1703A-33" autopos=1 normal=Top rotated=Right visible=0 linear=1 font=Default order=-1
line17=.EndSymbol

[simplis_section_instance]
count=10
line0=.Instance
line1=Attributes type=symbol name="MCP1703A-33" selected=1 protected=0 x=840 y=480 orient=N0 
line2=Property name="Model" value="X" autopos=1 normal=Left rotated=Left visible=0 font=Default order=-1
line3=Property name="PART" value="MCP1703A-33" autopos=1 normal=Top rotated=Left linear=1 font=Default order=-1
line4=Property name="Ref" value="U1" autopos=1 normal=Top rotated=Right font=Default order=-1
line5=Property name="StyleNormal" value="DefaultInstance" autopos=1 normal=Left rotated=Left visible=0 font=Default order=-1
line6=Property name="StyleSelected" value="DefaultSelected" autopos=1 normal=Left rotated=Left visible=0 font=Default order=-1
line7=Property name="value" value="MCP1703A-33" autopos=1 normal=Top rotated=Right linear=1 font=Default order=-1
line8=Netnames
line9=.EndInstance

[simplis_section_style_library]
count=2
line0=Style name="DefaultInstance" lineColour="255" lineThickness="0" penstyle="solid" fontFamily="arial" fontSize="7" fontItalics="0" fontBold="0" fontColour="0" fontOverline="0" fontUnderline="0" propertyStyle=1
line1=Style name="DefaultSelected" lineColour="16711680" lineThickness="0" penstyle="solid" fontFamily="arial" fontSize="9" fontItalics="0" fontBold="0" fontColour="16711680" fontOverline="0" fontUnderline="0" propertyStyle=0


[execlist_simplis_symbol]
description=Simplis/SiMetrix NPNZ16b controller schematic symbol
name=Simplis/SiMetrix NPNZ16b controller schematic symbol
count=1
0=simplis_section_symbol


[execlist_simplis_instance]
description=Simplis/SiMetrix NPNZ16b controller model instance
name=Simplis/SiMetrix NPNZ16b controller model instance
count=1
0=simplis_section_instance


___________________________________________________
(C)2020, Microchipt Technology Inc.
